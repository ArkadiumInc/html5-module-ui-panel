(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\lib\\xml.js":[function(require,module,exports){
var xml2js = require('xml2js')

function xml() {

    this.parse = function(value, stripRoots) {
        stripRoots = stripRoots || false
        var parser = new xml2js.Parser({explicitRoot: !stripRoots, explicitArray: false});
        var results = {};
        parser.parseString(value,function(err,r){
            if (err) {
                throw err;
            } else {
                results = r;
            }
        });
        return (stripRoots) ? _stripXmlBloat(results) : results;
    };

    this.stringify = function(value, root, child) {
        var writer = new xml2js.Builder({explicitRoot: false});
        value = root && _addxmlBloat(value, root, child) || value;
        return writer.buildObject(value);
    };

    this.child = function(root) {
        return _singular(root);
    };

    var _stripXmlBloat = function(value) {

        var cnt = 0;
        var root = null;
        var isVal = false;

        for (var p in value) {
            root = p;
            isVal = !(typeof value[p] == "object") && !Array.isArray(value[p]);
            cnt++
        }

        if (root && cnt ==1 && !isVal) {
            return (Array.isArray(value[p])) ? value[root] : [value[root]];
        }

        return value;
    }

    var _addxmlBloat = function(value, root, child) {
        if (root) {
            var result = {};

            if (Array.isArray(value)) {
                var records = {};
                child = child || _singular(root);
                records[child] = value;
                result[root] = records;
            } else {
                result[root] = value;
            }

            return result
        }
        return value;
    }

    var _singular = function(value) {
        if (value && value != "") {
            if (value.slice(-1) == "s") {
                return value.slice(0,-1);
            }

            return value + "Record";
        }

        return value;
    };


}

exports = module.exports = new xml();

},{"xml2js":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\lib\\xml2js.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\lib\\bom.js":[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";
  var xml2js;

  xml2js = require('../lib/xml2js');

  exports.stripBOM = function(str) {
    if (str[0] === '\uFEFF') {
      return str.substring(1);
    } else {
      return str;
    }
  };

}).call(this);

},{"../lib/xml2js":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\lib\\xml2js.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\lib\\processors.js":[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";
  var prefixMatch;

  prefixMatch = new RegExp(/(?!xmlns)^.*:/);

  exports.normalize = function(str) {
    return str.toLowerCase();
  };

  exports.firstCharLowerCase = function(str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
  };

  exports.stripPrefix = function(str) {
    return str.replace(prefixMatch, '');
  };

  exports.parseNumbers = function(str) {
    if (!isNaN(str)) {
      str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
    }
    return str;
  };

  exports.parseBooleans = function(str) {
    if (/^(?:true|false)$/i.test(str)) {
      str = str.toLowerCase() === 'true';
    }
    return str;
  };

}).call(this);

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\lib\\xml2js.js":[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";
  var bom, builder, escapeCDATA, events, isEmpty, processName, processors, requiresCDATA, sax, setImmediate, wrapCDATA,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  sax = require('sax');

  events = require('events');

  builder = require('xmlbuilder');

  bom = require('./bom');

  processors = require('./processors');

  setImmediate = require('timers').setImmediate;

  isEmpty = function(thing) {
    return typeof thing === "object" && (thing != null) && Object.keys(thing).length === 0;
  };

  processName = function(processors, processedName) {
    var i, len, process;
    for (i = 0, len = processors.length; i < len; i++) {
      process = processors[i];
      processedName = process(processedName);
    }
    return processedName;
  };

  requiresCDATA = function(entry) {
    return entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0;
  };

  wrapCDATA = function(entry) {
    return "<![CDATA[" + (escapeCDATA(entry)) + "]]>";
  };

  escapeCDATA = function(entry) {
    return entry.replace(']]>', ']]]]><![CDATA[>');
  };

  exports.processors = processors;

  exports.defaults = {
    "0.1": {
      explicitCharkey: false,
      trim: true,
      normalize: true,
      normalizeTags: false,
      attrkey: "@",
      charkey: "#",
      explicitArray: false,
      ignoreAttrs: false,
      mergeAttrs: false,
      explicitRoot: false,
      validator: null,
      xmlns: false,
      explicitChildren: false,
      childkey: '@@',
      charsAsChildren: false,
      async: false,
      strict: true,
      attrNameProcessors: null,
      attrValueProcessors: null,
      tagNameProcessors: null,
      valueProcessors: null,
      emptyTag: ''
    },
    "0.2": {
      explicitCharkey: false,
      trim: false,
      normalize: false,
      normalizeTags: false,
      attrkey: "$",
      charkey: "_",
      explicitArray: true,
      ignoreAttrs: false,
      mergeAttrs: false,
      explicitRoot: true,
      validator: null,
      xmlns: false,
      explicitChildren: false,
      preserveChildrenOrder: false,
      childkey: '$$',
      charsAsChildren: false,
      async: false,
      strict: true,
      attrNameProcessors: null,
      attrValueProcessors: null,
      tagNameProcessors: null,
      valueProcessors: null,
      rootName: 'root',
      xmldec: {
        'version': '1.0',
        'encoding': 'UTF-8',
        'standalone': true
      },
      doctype: null,
      renderOpts: {
        'pretty': true,
        'indent': '  ',
        'newline': '\n'
      },
      headless: false,
      chunkSize: 10000,
      emptyTag: '',
      cdata: false
    }
  };

  exports.ValidationError = (function(superClass) {
    extend(ValidationError, superClass);

    function ValidationError(message) {
      this.message = message;
    }

    return ValidationError;

  })(Error);

  exports.Builder = (function() {
    function Builder(opts) {
      var key, ref, value;
      this.options = {};
      ref = exports.defaults["0.2"];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this.options[key] = value;
      }
      for (key in opts) {
        if (!hasProp.call(opts, key)) continue;
        value = opts[key];
        this.options[key] = value;
      }
    }

    Builder.prototype.buildObject = function(rootObj) {
      var attrkey, charkey, render, rootElement, rootName;
      attrkey = this.options.attrkey;
      charkey = this.options.charkey;
      if ((Object.keys(rootObj).length === 1) && (this.options.rootName === exports.defaults['0.2'].rootName)) {
        rootName = Object.keys(rootObj)[0];
        rootObj = rootObj[rootName];
      } else {
        rootName = this.options.rootName;
      }
      render = (function(_this) {
        return function(element, obj) {
          var attr, child, entry, index, key, value;
          if (typeof obj !== 'object') {
            if (_this.options.cdata && requiresCDATA(obj)) {
              element.raw(wrapCDATA(obj));
            } else {
              element.txt(obj);
            }
          } else {
            for (key in obj) {
              if (!hasProp.call(obj, key)) continue;
              child = obj[key];
              if (key === attrkey) {
                if (typeof child === "object") {
                  for (attr in child) {
                    value = child[attr];
                    element = element.att(attr, value);
                  }
                }
              } else if (key === charkey) {
                if (_this.options.cdata && requiresCDATA(child)) {
                  element = element.raw(wrapCDATA(child));
                } else {
                  element = element.txt(child);
                }
              } else if (Array.isArray(child)) {
                for (index in child) {
                  if (!hasProp.call(child, index)) continue;
                  entry = child[index];
                  if (typeof entry === 'string') {
                    if (_this.options.cdata && requiresCDATA(entry)) {
                      element = element.ele(key).raw(wrapCDATA(entry)).up();
                    } else {
                      element = element.ele(key, entry).up();
                    }
                  } else {
                    element = render(element.ele(key), entry).up();
                  }
                }
              } else if (typeof child === "object") {
                element = render(element.ele(key), child).up();
              } else {
                if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
                  element = element.ele(key).raw(wrapCDATA(child)).up();
                } else {
                  if (child == null) {
                    child = '';
                  }
                  element = element.ele(key, child.toString()).up();
                }
              }
            }
          }
          return element;
        };
      })(this);
      rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
        headless: this.options.headless,
        allowSurrogateChars: this.options.allowSurrogateChars
      });
      return render(rootElement, rootObj).end(this.options.renderOpts);
    };

    return Builder;

  })();

  exports.Parser = (function(superClass) {
    extend(Parser, superClass);

    function Parser(opts) {
      this.parseString = bind(this.parseString, this);
      this.reset = bind(this.reset, this);
      this.assignOrPush = bind(this.assignOrPush, this);
      this.processAsync = bind(this.processAsync, this);
      var key, ref, value;
      if (!(this instanceof exports.Parser)) {
        return new exports.Parser(opts);
      }
      this.options = {};
      ref = exports.defaults["0.2"];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this.options[key] = value;
      }
      for (key in opts) {
        if (!hasProp.call(opts, key)) continue;
        value = opts[key];
        this.options[key] = value;
      }
      if (this.options.xmlns) {
        this.options.xmlnskey = this.options.attrkey + "ns";
      }
      if (this.options.normalizeTags) {
        if (!this.options.tagNameProcessors) {
          this.options.tagNameProcessors = [];
        }
        this.options.tagNameProcessors.unshift(processors.normalize);
      }
      this.reset();
    }

    Parser.prototype.processAsync = function() {
      var chunk, err, error1;
      try {
        if (this.remaining.length <= this.options.chunkSize) {
          chunk = this.remaining;
          this.remaining = '';
          this.saxParser = this.saxParser.write(chunk);
          return this.saxParser.close();
        } else {
          chunk = this.remaining.substr(0, this.options.chunkSize);
          this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
          this.saxParser = this.saxParser.write(chunk);
          return setImmediate(this.processAsync);
        }
      } catch (error1) {
        err = error1;
        if (!this.saxParser.errThrown) {
          this.saxParser.errThrown = true;
          return this.emit(err);
        }
      }
    };

    Parser.prototype.assignOrPush = function(obj, key, newValue) {
      if (!(key in obj)) {
        if (!this.options.explicitArray) {
          return obj[key] = newValue;
        } else {
          return obj[key] = [newValue];
        }
      } else {
        if (!(obj[key] instanceof Array)) {
          obj[key] = [obj[key]];
        }
        return obj[key].push(newValue);
      }
    };

    Parser.prototype.reset = function() {
      var attrkey, charkey, ontext, stack;
      this.removeAllListeners();
      this.saxParser = sax.parser(this.options.strict, {
        trim: false,
        normalize: false,
        xmlns: this.options.xmlns
      });
      this.saxParser.errThrown = false;
      this.saxParser.onerror = (function(_this) {
        return function(error) {
          _this.saxParser.resume();
          if (!_this.saxParser.errThrown) {
            _this.saxParser.errThrown = true;
            return _this.emit("error", error);
          }
        };
      })(this);
      this.saxParser.onend = (function(_this) {
        return function() {
          if (!_this.saxParser.ended) {
            _this.saxParser.ended = true;
            return _this.emit("end", _this.resultObject);
          }
        };
      })(this);
      this.saxParser.ended = false;
      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
      this.resultObject = null;
      stack = [];
      attrkey = this.options.attrkey;
      charkey = this.options.charkey;
      this.saxParser.onopentag = (function(_this) {
        return function(node) {
          var key, newValue, obj, processedKey, ref;
          obj = {};
          obj[charkey] = "";
          if (!_this.options.ignoreAttrs) {
            ref = node.attributes;
            for (key in ref) {
              if (!hasProp.call(ref, key)) continue;
              if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                obj[attrkey] = {};
              }
              newValue = _this.options.attrValueProcessors ? processName(_this.options.attrValueProcessors, node.attributes[key]) : node.attributes[key];
              processedKey = _this.options.attrNameProcessors ? processName(_this.options.attrNameProcessors, key) : key;
              if (_this.options.mergeAttrs) {
                _this.assignOrPush(obj, processedKey, newValue);
              } else {
                obj[attrkey][processedKey] = newValue;
              }
            }
          }
          obj["#name"] = _this.options.tagNameProcessors ? processName(_this.options.tagNameProcessors, node.name) : node.name;
          if (_this.options.xmlns) {
            obj[_this.options.xmlnskey] = {
              uri: node.uri,
              local: node.local
            };
          }
          return stack.push(obj);
        };
      })(this);
      this.saxParser.onclosetag = (function(_this) {
        return function() {
          var cdata, emptyStr, err, error1, key, node, nodeName, obj, objClone, old, s, xpath;
          obj = stack.pop();
          nodeName = obj["#name"];
          if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
            delete obj["#name"];
          }
          if (obj.cdata === true) {
            cdata = obj.cdata;
            delete obj.cdata;
          }
          s = stack[stack.length - 1];
          if (obj[charkey].match(/^\s*$/) && !cdata) {
            emptyStr = obj[charkey];
            delete obj[charkey];
          } else {
            if (_this.options.trim) {
              obj[charkey] = obj[charkey].trim();
            }
            if (_this.options.normalize) {
              obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
            }
            obj[charkey] = _this.options.valueProcessors ? processName(_this.options.valueProcessors, obj[charkey]) : obj[charkey];
            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
              obj = obj[charkey];
            }
          }
          if (isEmpty(obj)) {
            obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
          }
          if (_this.options.validator != null) {
            xpath = "/" + ((function() {
              var i, len, results;
              results = [];
              for (i = 0, len = stack.length; i < len; i++) {
                node = stack[i];
                results.push(node["#name"]);
              }
              return results;
            })()).concat(nodeName).join("/");
            try {
              obj = _this.options.validator(xpath, s && s[nodeName], obj);
            } catch (error1) {
              err = error1;
              _this.emit("error", err);
            }
          }
          if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
            if (!_this.options.preserveChildrenOrder) {
              node = {};
              if (_this.options.attrkey in obj) {
                node[_this.options.attrkey] = obj[_this.options.attrkey];
                delete obj[_this.options.attrkey];
              }
              if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                node[_this.options.charkey] = obj[_this.options.charkey];
                delete obj[_this.options.charkey];
              }
              if (Object.getOwnPropertyNames(obj).length > 0) {
                node[_this.options.childkey] = obj;
              }
              obj = node;
            } else if (s) {
              s[_this.options.childkey] = s[_this.options.childkey] || [];
              objClone = {};
              for (key in obj) {
                if (!hasProp.call(obj, key)) continue;
                objClone[key] = obj[key];
              }
              s[_this.options.childkey].push(objClone);
              delete obj["#name"];
              if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                obj = obj[charkey];
              }
            }
          }
          if (stack.length > 0) {
            return _this.assignOrPush(s, nodeName, obj);
          } else {
            if (_this.options.explicitRoot) {
              old = obj;
              obj = {};
              obj[nodeName] = old;
            }
            _this.resultObject = obj;
            _this.saxParser.ended = true;
            return _this.emit("end", _this.resultObject);
          }
        };
      })(this);
      ontext = (function(_this) {
        return function(text) {
          var charChild, s;
          s = stack[stack.length - 1];
          if (s) {
            s[charkey] += text;
            if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && text.replace(/\\n/g, '').trim() !== '') {
              s[_this.options.childkey] = s[_this.options.childkey] || [];
              charChild = {
                '#name': '__text__'
              };
              charChild[charkey] = text;
              s[_this.options.childkey].push(charChild);
            }
            return s;
          }
        };
      })(this);
      this.saxParser.ontext = ontext;
      return this.saxParser.oncdata = (function(_this) {
        return function(text) {
          var s;
          s = ontext(text);
          if (s) {
            return s.cdata = true;
          }
        };
      })(this);
    };

    Parser.prototype.parseString = function(str, cb) {
      var err, error1;
      if ((cb != null) && typeof cb === "function") {
        this.on("end", function(result) {
          this.reset();
          return cb(null, result);
        });
        this.on("error", function(err) {
          this.reset();
          return cb(err);
        });
      }
      try {
        str = str.toString();
        if (str.trim() === '') {
          this.emit("end", null);
          return true;
        }
        str = bom.stripBOM(str);
        if (this.options.async) {
          this.remaining = str;
          setImmediate(this.processAsync);
          return this.saxParser;
        }
        return this.saxParser.write(str).close();
      } catch (error1) {
        err = error1;
        if (!(this.saxParser.errThrown || this.saxParser.ended)) {
          this.emit('error', err);
          return this.saxParser.errThrown = true;
        } else if (this.saxParser.ended) {
          throw err;
        }
      }
    };

    return Parser;

  })(events.EventEmitter);

  exports.parseString = function(str, a, b) {
    var cb, options, parser;
    if (b != null) {
      if (typeof b === 'function') {
        cb = b;
      }
      if (typeof a === 'object') {
        options = a;
      }
    } else {
      if (typeof a === 'function') {
        cb = a;
      }
      options = {};
    }
    parser = new exports.Parser(options);
    return parser.parseString(str, cb);
  };

}).call(this);

},{"./bom":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\lib\\bom.js","./processors":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\lib\\processors.js","events":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\events\\events.js","sax":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\sax\\lib\\sax.js","timers":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\timers-browserify\\main.js","xmlbuilder":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\index.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\sax\\lib\\sax.js":[function(require,module,exports){
(function (Buffer){
;(function (sax) { // wrapper for non-node envs
  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
  sax.SAXParser = SAXParser
  sax.SAXStream = SAXStream
  sax.createStream = createStream

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024

  var buffers = [
    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
    'procInstName', 'procInstBody', 'entity', 'attribName',
    'attribValue', 'cdata', 'script'
  ]

  sax.EVENTS = [
    'text',
    'processinginstruction',
    'sgmldeclaration',
    'doctype',
    'comment',
    'opentagstart',
    'attribute',
    'opentag',
    'closetag',
    'opencdata',
    'cdata',
    'closecdata',
    'error',
    'end',
    'ready',
    'script',
    'opennamespace',
    'closenamespace'
  ]

  function SAXParser (strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt)
    }

    var parser = this
    clearBuffers(parser)
    parser.q = parser.c = ''
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
    parser.opt = opt || {}
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
    parser.tags = []
    parser.closed = parser.closedRoot = parser.sawRoot = false
    parser.tag = parser.error = null
    parser.strict = !!strict
    parser.noscript = !!(strict || parser.opt.noscript)
    parser.state = S.BEGIN
    parser.strictEntities = parser.opt.strictEntities
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
    parser.attribList = []

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS)
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0
    }
    emit(parser, 'onready')
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F () {}
      F.prototype = o
      var newf = new F()
      return newf
    }
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    var maxActual = 0
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser)
            break

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata)
            parser.cdata = ''
            break

          case 'script':
            emitNode(parser, 'onscript', parser.script)
            parser.script = ''
            break

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i])
        }
      }
      maxActual = Math.max(maxActual, len)
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual
    parser.bufferCheckPosition = m + parser.position
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = ''
    }
  }

  function flushBuffers (parser) {
    closeText(parser)
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata)
      parser.cdata = ''
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }
  }

  SAXParser.prototype = {
    end: function () { end(this) },
    write: write,
    resume: function () { this.error = null; return this },
    close: function () { return this.write(null) },
    flush: function () { flushBuffers(this) }
  }

  var Stream
  try {
    Stream = require('stream').Stream
  } catch (ex) {
    Stream = function () {}
  }

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end'
  })

  function createStream (strict, opt) {
    return new SAXStream(strict, opt)
  }

  function SAXStream (strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt)
    }

    Stream.apply(this)

    this._parser = new SAXParser(strict, opt)
    this.writable = true
    this.readable = true

    var me = this

    this._parser.onend = function () {
      me.emit('end')
    }

    this._parser.onerror = function (er) {
      me.emit('error', er)

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null
    }

    this._decoder = null

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function () {
          return me._parser['on' + ev]
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev)
            me._parser['on' + ev] = h
            return h
          }
          me.on(ev, h)
        },
        enumerable: true,
        configurable: false
      })
    })
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  })

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' &&
      typeof Buffer.isBuffer === 'function' &&
      Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = require('string_decoder').StringDecoder
        this._decoder = new SD('utf8')
      }
      data = this._decoder.write(data)
    }

    this._parser.write(data.toString())
    this.emit('data', data)
    return true
  }

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk)
    }
    this._parser.end()
    return true
  }

  SAXStream.prototype.on = function (ev, handler) {
    var me = this
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
        args.splice(0, 0, ev)
        me.emit.apply(me, args)
      }
    }

    return Stream.prototype.on.call(me, ev, handler)
  }

  // character classes and tokens
  var whitespace = '\r\n\t '

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var number = '0124356789'
  var letter = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'

  // (Letter | "_" | ":")
  var quote = '\'"'
  var attribEnd = whitespace + '>'
  var CDATA = '[CDATA['
  var DOCTYPE = 'DOCTYPE'
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

  // turn all the string character sets into character class objects.
  whitespace = charClass(whitespace)
  number = charClass(number)
  letter = charClass(letter)

  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/

  quote = charClass(quote)
  attribEnd = charClass(attribEnd)

  function charClass (str) {
    return str.split('').reduce(function (s, c) {
      s[c] = true
      return s
    }, {})
  }

  function isRegExp (c) {
    return Object.prototype.toString.call(c) === '[object RegExp]'
  }

  function is (charclass, c) {
    return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]
  }

  function not (charclass, c) {
    return !is(charclass, c)
  }

  var S = 0
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  }

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  }

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  }

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
  })

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s
  }

  // shorthand
  S = sax.STATE

  function emit (parser, event, data) {
    parser[event] && parser[event](data)
  }

  function emitNode (parser, nodeType, data) {
    if (parser.textNode) closeText(parser)
    emit(parser, nodeType, data)
  }

  function closeText (parser) {
    parser.textNode = textopts(parser.opt, parser.textNode)
    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
    parser.textNode = ''
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim()
    if (opt.normalize) text = text.replace(/\s+/g, ' ')
    return text
  }

  function error (parser, er) {
    closeText(parser)
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line +
        '\nColumn: ' + parser.column +
        '\nChar: ' + parser.c
    }
    er = new Error(er)
    parser.error = er
    emit(parser, 'onerror', er)
    return parser
  }

  function end (parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
    if ((parser.state !== S.BEGIN) &&
      (parser.state !== S.BEGIN_WHITESPACE) &&
      (parser.state !== S.TEXT)) {
      error(parser, 'Unexpected end')
    }
    closeText(parser)
    parser.c = ''
    parser.closed = true
    emit(parser, 'onend')
    SAXParser.call(parser, parser.strict, parser.opt)
    return parser
  }

  function strictFail (parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail')
    }
    if (parser.strict) {
      error(parser, message)
    }
  }

  function newTag (parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
    var parent = parser.tags[parser.tags.length - 1] || parser
    var tag = parser.tag = { name: parser.tagName, attributes: {} }

    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    if (parser.opt.xmlns) {
      tag.ns = parent.ns
    }
    parser.attribList.length = 0
    emitNode(parser, 'onopentagstart', tag)
  }

  function qname (name, attribute) {
    var i = name.indexOf(':')
    var qualName = i < 0 ? [ '', name ] : name.split(':')
    var prefix = qualName[0]
    var local = qualName[1]

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns'
      local = ''
    }

    return { prefix: prefix, local: local }
  }

  function attrib (parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]()
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = ''
      return
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true)
      var prefix = qn.prefix
      var local = qn.local

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser,
            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser,
            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else {
          var tag = parser.tag
          var parent = parser.tags[parser.tags.length - 1] || parser
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns)
          }
          tag.ns[local] = parser.attribValue
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue])
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      })
    }

    parser.attribName = parser.attribValue = ''
  }

  function openTag (parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag

      // add namespace info to tag
      var qn = qname(parser.tagName)
      tag.prefix = qn.prefix
      tag.local = qn.local
      tag.uri = tag.ns[qn.prefix] || ''

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' +
          JSON.stringify(parser.tagName))
        tag.uri = qn.prefix
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          })
        })
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i]
        var name = nv[0]
        var value = nv[1]
        var qualName = qname(name, true)
        var prefix = qualName.prefix
        var local = qualName.local
        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        }

        // if there's any attributes with an undefined namespace,
        // then fail on them now.
        if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' +
            JSON.stringify(prefix))
          a.uri = prefix
        }
        parser.tag.attributes[name] = a
        emitNode(parser, 'onattribute', a)
      }
      parser.attribList.length = 0
    }

    parser.tag.isSelfClosing = !!selfClosing

    // process the tag
    parser.sawRoot = true
    parser.tags.push(parser.tag)
    emitNode(parser, 'onopentag', parser.tag)
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT
      } else {
        parser.state = S.TEXT
      }
      parser.tag = null
      parser.tagName = ''
    }
    parser.attribName = parser.attribValue = ''
    parser.attribList.length = 0
  }

  function closeTag (parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.')
      parser.textNode += '</>'
      parser.state = S.TEXT
      return
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>'
        parser.tagName = ''
        parser.state = S.SCRIPT
        return
      }
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length
    var tagName = parser.tagName
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]()
    }
    var closeTo = tagName
    while (t--) {
      var close = parser.tags[t]
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag')
      } else {
        break
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
      parser.textNode += '</' + parser.tagName + '>'
      parser.state = S.TEXT
      return
    }
    parser.tagName = tagName
    var s = parser.tags.length
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop()
      parser.tagName = parser.tag.name
      emitNode(parser, 'onclosetag', parser.tagName)

      var x = {}
      for (var i in tag.ns) {
        x[i] = tag.ns[i]
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p]
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
        })
      }
    }
    if (t === 0) parser.closedRoot = true
    parser.tagName = parser.attribValue = parser.attribName = ''
    parser.attribList.length = 0
    parser.state = S.TEXT
  }

  function parseEntity (parser) {
    var entity = parser.entity
    var entityLC = entity.toLowerCase()
    var num
    var numStr = ''

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2)
        num = parseInt(entity, 16)
        numStr = num.toString(16)
      } else {
        entity = entity.slice(1)
        num = parseInt(entity, 10)
        numStr = num.toString(10)
      }
    }
    entity = entity.replace(/^0+/, '')
    if (numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity')
      return '&' + parser.entity + ';'
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace (parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA
      parser.startTagPosition = parser.position
    } else if (not(whitespace, c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.')
      parser.textNode = c
      parser.state = S.TEXT
    }
  }

  function charAt (chunk, i) {
    var result = ''
    if (i < chunk.length) {
      result = chunk.charAt(i)
    }
    return result
  }

  function write (chunk) {
    var parser = this
    if (this.error) {
      throw this.error
    }
    if (parser.closed) {
      return error(parser,
        'Cannot write after close. Assign an onready handler.')
    }
    if (chunk === null) {
      return end(parser)
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString()
    }
    var i = 0
    var c = ''
    while (true) {
      c = charAt(chunk, i++)
      parser.c = c
      if (!c) {
        break
      }
      if (parser.trackPosition) {
        parser.position++
        if (c === '\n') {
          parser.line++
          parser.column = 0
        } else {
          parser.column++
        }
      }
      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE
          if (c === '\uFEFF') {
            continue
          }
          beginWhiteSpace(parser, c)
          continue

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c)
          continue

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++)
              if (c && parser.trackPosition) {
                parser.position++
                if (c === '\n') {
                  parser.line++
                  parser.column = 0
                } else {
                  parser.column++
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1)
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else {
            if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.')
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY
            } else {
              parser.textNode += c
            }
          }
          continue

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING
          } else {
            parser.script += c
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG
          } else {
            parser.script += '<' + c
            parser.state = S.SCRIPT
          }
          continue

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL
            parser.sgmlDecl = ''
          } else if (is(whitespace, c)) {
            // wait for it...
          } else if (is(nameStart, c)) {
            parser.state = S.OPEN_TAG
            parser.tagName = c
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG
            parser.tagName = ''
          } else if (c === '?') {
            parser.state = S.PROC_INST
            parser.procInstName = parser.procInstBody = ''
          } else {
            strictFail(parser, 'Unencoded <')
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition
              c = new Array(pad).join(' ') + c
            }
            parser.textNode += '<' + c
            parser.state = S.TEXT
          }
          continue

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata')
            parser.state = S.CDATA
            parser.sgmlDecl = ''
            parser.cdata = ''
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT
            parser.comment = ''
            parser.sgmlDecl = ''
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser,
                'Inappropriately located doctype declaration')
            }
            parser.doctype = ''
            parser.sgmlDecl = ''
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
            parser.sgmlDecl = ''
            parser.state = S.TEXT
          } else if (is(quote, c)) {
            parser.state = S.SGML_DECL_QUOTED
            parser.sgmlDecl += c
          } else {
            parser.sgmlDecl += c
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL
            parser.q = ''
          }
          parser.sgmlDecl += c
          continue

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT
            emitNode(parser, 'ondoctype', parser.doctype)
            parser.doctype = true // just remember that we saw it.
          } else {
            parser.doctype += c
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD
            } else if (is(quote, c)) {
              parser.state = S.DOCTYPE_QUOTED
              parser.q = c
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.q = ''
            parser.state = S.DOCTYPE
          }
          continue

        case S.DOCTYPE_DTD:
          parser.doctype += c
          if (c === ']') {
            parser.state = S.DOCTYPE
          } else if (is(quote, c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED
            parser.q = c
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD
            parser.q = ''
          }
          continue

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING
          } else {
            parser.comment += c
          }
          continue

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED
            parser.comment = textopts(parser.opt, parser.comment)
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment)
            }
            parser.comment = ''
          } else {
            parser.comment += '-' + c
            parser.state = S.COMMENT
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment')
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c
            parser.state = S.COMMENT
          } else {
            parser.state = S.TEXT
          }
          continue

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING
          } else {
            parser.cdata += c
          }
          continue

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2
          } else {
            parser.cdata += ']' + c
            parser.state = S.CDATA
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata)
            }
            emitNode(parser, 'onclosecdata')
            parser.cdata = ''
            parser.state = S.TEXT
          } else if (c === ']') {
            parser.cdata += ']'
          } else {
            parser.cdata += ']]' + c
            parser.state = S.CDATA
          }
          continue

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else if (is(whitespace, c)) {
            parser.state = S.PROC_INST_BODY
          } else {
            parser.procInstName += c
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && is(whitespace, c)) {
            continue
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else {
            parser.procInstBody += c
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            })
            parser.procInstName = parser.procInstBody = ''
            parser.state = S.TEXT
          } else {
            parser.procInstBody += '?' + c
            parser.state = S.PROC_INST_BODY
          }
          continue

        case S.OPEN_TAG:
          if (is(nameBody, c)) {
            parser.tagName += c
          } else {
            newTag(parser)
            if (c === '>') {
              openTag(parser)
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH
            } else {
              if (not(whitespace, c)) {
                strictFail(parser, 'Invalid character in tag name')
              }
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true)
            closeTag(parser)
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >')
            parser.state = S.ATTRIB
          }
          continue

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (is(whitespace, c)) {
            continue
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (is(nameStart, c)) {
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value')
            parser.attribValue = parser.attribName
            attrib(parser)
            openTag(parser)
          } else if (is(whitespace, c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE
          } else if (is(nameBody, c)) {
            parser.attribName += c
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (is(whitespace, c)) {
            continue
          } else {
            strictFail(parser, 'Attribute without value')
            parser.tag.attributes[parser.attribName] = ''
            parser.attribValue = ''
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            })
            parser.attribName = ''
            if (c === '>') {
              openTag(parser)
            } else if (is(nameStart, c)) {
              parser.attribName = c
              parser.state = S.ATTRIB_NAME
            } else {
              strictFail(parser, 'Invalid attribute name')
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (is(whitespace, c)) {
            continue
          } else if (is(quote, c)) {
            parser.q = c
            parser.state = S.ATTRIB_VALUE_QUOTED
          } else {
            strictFail(parser, 'Unquoted attribute value')
            parser.state = S.ATTRIB_VALUE_UNQUOTED
            parser.attribValue = c
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          parser.q = ''
          parser.state = S.ATTRIB_VALUE_CLOSED
          continue

        case S.ATTRIB_VALUE_CLOSED:
          if (is(whitespace, c)) {
            parser.state = S.ATTRIB
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (is(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes')
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (not(attribEnd, c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          if (c === '>') {
            openTag(parser)
          } else {
            parser.state = S.ATTRIB
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (is(whitespace, c)) {
              continue
            } else if (not(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c
                parser.state = S.SCRIPT
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.')
              }
            } else {
              parser.tagName = c
            }
          } else if (c === '>') {
            closeTag(parser)
          } else if (is(nameBody, c)) {
            parser.tagName += c
          } else if (parser.script) {
            parser.script += '</' + parser.tagName
            parser.tagName = ''
            parser.state = S.SCRIPT
          } else {
            if (not(whitespace, c)) {
              strictFail(parser, 'Invalid tagname in closing tag')
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (is(whitespace, c)) {
            continue
          }
          if (c === '>') {
            closeTag(parser)
          } else {
            strictFail(parser, 'Invalid characters in closing tag')
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState
          var buffer
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT
              buffer = 'textNode'
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED
              buffer = 'attribValue'
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED
              buffer = 'attribValue'
              break
          }

          if (c === ';') {
            parser[buffer] += parseEntity(parser)
            parser.entity = ''
            parser.state = returnState
          } else if (is(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c
          } else {
            strictFail(parser, 'Invalid character in entity name')
            parser[buffer] += '&' + parser.entity + c
            parser.entity = ''
            parser.state = returnState
          }

          continue

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state)
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser)
    }
    return parser
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode
      var floor = Math.floor
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000
        var codeUnits = []
        var highSurrogate
        var lowSurrogate
        var index = -1
        var length = arguments.length
        if (!length) {
          return ''
        }
        var result = ''
        while (++index < length) {
          var codePoint = Number(arguments[index])
          if (
            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 0x10FFFF || // not a valid Unicode code point
            floor(codePoint) !== codePoint // not an integer
          ) {
            throw RangeError('Invalid code point: ' + codePoint)
          }
          if (codePoint <= 0xFFFF) { // BMP code point
            codeUnits.push(codePoint)
          } else { // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000
            highSurrogate = (codePoint >> 10) + 0xD800
            lowSurrogate = (codePoint % 0x400) + 0xDC00
            codeUnits.push(highSurrogate, lowSurrogate)
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits)
            codeUnits.length = 0
          }
        }
        return result
      }
      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        })
      } else {
        String.fromCodePoint = fromCodePoint
      }
    }())
  }
})(typeof exports === 'undefined' ? this.sax = {} : exports)

}).call(this,require("buffer").Buffer)

},{"buffer":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\buffer\\index.js","stream":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\stream-browserify\\index.js","string_decoder":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\string_decoder\\index.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLAttribute.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLAttribute, create;

  create = require('lodash/create');

  module.exports = XMLAttribute = (function() {
    function XMLAttribute(parent, name, value) {
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing attribute name of element " + parent.name);
      }
      if (value == null) {
        throw new Error("Missing attribute value for attribute " + name + " of element " + parent.name);
      }
      this.name = this.stringify.attName(name);
      this.value = this.stringify.attValue(value);
    }

    XMLAttribute.prototype.clone = function() {
      return create(XMLAttribute.prototype, this);
    };

    XMLAttribute.prototype.toString = function(options, level) {
      return ' ' + this.name + '="' + this.value + '"';
    };

    return XMLAttribute;

  })();

}).call(this);

},{"lodash/create":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\create.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLBuilder.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLBuilder, XMLDeclaration, XMLDocType, XMLElement, XMLStringifier;

  XMLStringifier = require('./XMLStringifier');

  XMLDeclaration = require('./XMLDeclaration');

  XMLDocType = require('./XMLDocType');

  XMLElement = require('./XMLElement');

  module.exports = XMLBuilder = (function() {
    function XMLBuilder(name, options) {
      var root, temp;
      if (name == null) {
        throw new Error("Root element needs a name");
      }
      if (options == null) {
        options = {};
      }
      this.options = options;
      this.stringify = new XMLStringifier(options);
      temp = new XMLElement(this, 'doc');
      root = temp.element(name);
      root.isRoot = true;
      root.documentObject = this;
      this.rootObject = root;
      if (!options.headless) {
        root.declaration(options);
        if ((options.pubID != null) || (options.sysID != null)) {
          root.doctype(options);
        }
      }
    }

    XMLBuilder.prototype.root = function() {
      return this.rootObject;
    };

    XMLBuilder.prototype.end = function(options) {
      return this.toString(options);
    };

    XMLBuilder.prototype.toString = function(options) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      r = '';
      if (this.xmldec != null) {
        r += this.xmldec.toString(options);
      }
      if (this.doctype != null) {
        r += this.doctype.toString(options);
      }
      r += this.rootObject.toString(options);
      if (pretty && r.slice(-newline.length) === newline) {
        r = r.slice(0, -newline.length);
      }
      return r;
    };

    return XMLBuilder;

  })();

}).call(this);

},{"./XMLDeclaration":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLDeclaration.js","./XMLDocType":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLDocType.js","./XMLElement":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLElement.js","./XMLStringifier":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLStringifier.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLCData.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLCData, XMLNode, create,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = require('lodash/create');

  XMLNode = require('./XMLNode');

  module.exports = XMLCData = (function(superClass) {
    extend(XMLCData, superClass);

    function XMLCData(parent, text) {
      XMLCData.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing CDATA text");
      }
      this.text = this.stringify.cdata(text);
    }

    XMLCData.prototype.clone = function() {
      return create(XMLCData.prototype, this);
    };

    XMLCData.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<![CDATA[' + this.text + ']]>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLCData;

  })(XMLNode);

}).call(this);

},{"./XMLNode":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLNode.js","lodash/create":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\create.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLComment.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLComment, XMLNode, create,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = require('lodash/create');

  XMLNode = require('./XMLNode');

  module.exports = XMLComment = (function(superClass) {
    extend(XMLComment, superClass);

    function XMLComment(parent, text) {
      XMLComment.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing comment text");
      }
      this.text = this.stringify.comment(text);
    }

    XMLComment.prototype.clone = function() {
      return create(XMLComment.prototype, this);
    };

    XMLComment.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!-- ' + this.text + ' -->';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLComment;

  })(XMLNode);

}).call(this);

},{"./XMLNode":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLNode.js","lodash/create":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\create.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLDTDAttList.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLDTDAttList, create;

  create = require('lodash/create');

  module.exports = XMLDTDAttList = (function() {
    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      this.stringify = parent.stringify;
      if (elementName == null) {
        throw new Error("Missing DTD element name");
      }
      if (attributeName == null) {
        throw new Error("Missing DTD attribute name");
      }
      if (!attributeType) {
        throw new Error("Missing DTD attribute type");
      }
      if (!defaultValueType) {
        throw new Error("Missing DTD attribute default");
      }
      if (defaultValueType.indexOf('#') !== 0) {
        defaultValueType = '#' + defaultValueType;
      }
      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
        throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");
      }
      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
        throw new Error("Default value only applies to #FIXED or #DEFAULT");
      }
      this.elementName = this.stringify.eleName(elementName);
      this.attributeName = this.stringify.attName(attributeName);
      this.attributeType = this.stringify.dtdAttType(attributeType);
      this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
      this.defaultValueType = defaultValueType;
    }

    XMLDTDAttList.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!ATTLIST ' + this.elementName + ' ' + this.attributeName + ' ' + this.attributeType;
      if (this.defaultValueType !== '#DEFAULT') {
        r += ' ' + this.defaultValueType;
      }
      if (this.defaultValue) {
        r += ' "' + this.defaultValue + '"';
      }
      r += '>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLDTDAttList;

  })();

}).call(this);

},{"lodash/create":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\create.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLDTDElement.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLDTDElement, create;

  create = require('lodash/create');

  module.exports = XMLDTDElement = (function() {
    function XMLDTDElement(parent, name, value) {
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing DTD element name");
      }
      if (!value) {
        value = '(#PCDATA)';
      }
      if (Array.isArray(value)) {
        value = '(' + value.join(',') + ')';
      }
      this.name = this.stringify.eleName(name);
      this.value = this.stringify.dtdElementValue(value);
    }

    XMLDTDElement.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!ELEMENT ' + this.name + ' ' + this.value + '>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLDTDElement;

  })();

}).call(this);

},{"lodash/create":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\create.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLDTDEntity.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLDTDEntity, create, isObject;

  create = require('lodash/create');

  isObject = require('lodash/isObject');

  module.exports = XMLDTDEntity = (function() {
    function XMLDTDEntity(parent, pe, name, value) {
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing entity name");
      }
      if (value == null) {
        throw new Error("Missing entity value");
      }
      this.pe = !!pe;
      this.name = this.stringify.eleName(name);
      if (!isObject(value)) {
        this.value = this.stringify.dtdEntityValue(value);
      } else {
        if (!value.pubID && !value.sysID) {
          throw new Error("Public and/or system identifiers are required for an external entity");
        }
        if (value.pubID && !value.sysID) {
          throw new Error("System identifier is required for a public external entity");
        }
        if (value.pubID != null) {
          this.pubID = this.stringify.dtdPubID(value.pubID);
        }
        if (value.sysID != null) {
          this.sysID = this.stringify.dtdSysID(value.sysID);
        }
        if (value.nData != null) {
          this.nData = this.stringify.dtdNData(value.nData);
        }
        if (this.pe && this.nData) {
          throw new Error("Notation declaration is not allowed in a parameter entity");
        }
      }
    }

    XMLDTDEntity.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!ENTITY';
      if (this.pe) {
        r += ' %';
      }
      r += ' ' + this.name;
      if (this.value) {
        r += ' "' + this.value + '"';
      } else {
        if (this.pubID && this.sysID) {
          r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
        } else if (this.sysID) {
          r += ' SYSTEM "' + this.sysID + '"';
        }
        if (this.nData) {
          r += ' NDATA ' + this.nData;
        }
      }
      r += '>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLDTDEntity;

  })();

}).call(this);

},{"lodash/create":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\create.js","lodash/isObject":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isObject.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLDTDNotation.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLDTDNotation, create;

  create = require('lodash/create');

  module.exports = XMLDTDNotation = (function() {
    function XMLDTDNotation(parent, name, value) {
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing notation name");
      }
      if (!value.pubID && !value.sysID) {
        throw new Error("Public or system identifiers are required for an external entity");
      }
      this.name = this.stringify.eleName(name);
      if (value.pubID != null) {
        this.pubID = this.stringify.dtdPubID(value.pubID);
      }
      if (value.sysID != null) {
        this.sysID = this.stringify.dtdSysID(value.sysID);
      }
    }

    XMLDTDNotation.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!NOTATION ' + this.name;
      if (this.pubID && this.sysID) {
        r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
      } else if (this.pubID) {
        r += ' PUBLIC "' + this.pubID + '"';
      } else if (this.sysID) {
        r += ' SYSTEM "' + this.sysID + '"';
      }
      r += '>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLDTDNotation;

  })();

}).call(this);

},{"lodash/create":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\create.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLDeclaration.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLDeclaration, XMLNode, create, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = require('lodash/create');

  isObject = require('lodash/isObject');

  XMLNode = require('./XMLNode');

  module.exports = XMLDeclaration = (function(superClass) {
    extend(XMLDeclaration, superClass);

    function XMLDeclaration(parent, version, encoding, standalone) {
      var ref;
      XMLDeclaration.__super__.constructor.call(this, parent);
      if (isObject(version)) {
        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
      }
      if (!version) {
        version = '1.0';
      }
      this.version = this.stringify.xmlVersion(version);
      if (encoding != null) {
        this.encoding = this.stringify.xmlEncoding(encoding);
      }
      if (standalone != null) {
        this.standalone = this.stringify.xmlStandalone(standalone);
      }
    }

    XMLDeclaration.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<?xml';
      r += ' version="' + this.version + '"';
      if (this.encoding != null) {
        r += ' encoding="' + this.encoding + '"';
      }
      if (this.standalone != null) {
        r += ' standalone="' + this.standalone + '"';
      }
      r += '?>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLDeclaration;

  })(XMLNode);

}).call(this);

},{"./XMLNode":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLNode.js","lodash/create":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\create.js","lodash/isObject":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isObject.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLDocType.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLProcessingInstruction, create, isObject;

  create = require('lodash/create');

  isObject = require('lodash/isObject');

  XMLCData = require('./XMLCData');

  XMLComment = require('./XMLComment');

  XMLDTDAttList = require('./XMLDTDAttList');

  XMLDTDEntity = require('./XMLDTDEntity');

  XMLDTDElement = require('./XMLDTDElement');

  XMLDTDNotation = require('./XMLDTDNotation');

  XMLProcessingInstruction = require('./XMLProcessingInstruction');

  module.exports = XMLDocType = (function() {
    function XMLDocType(parent, pubID, sysID) {
      var ref, ref1;
      this.documentObject = parent;
      this.stringify = this.documentObject.stringify;
      this.children = [];
      if (isObject(pubID)) {
        ref = pubID, pubID = ref.pubID, sysID = ref.sysID;
      }
      if (sysID == null) {
        ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
      }
      if (pubID != null) {
        this.pubID = this.stringify.dtdPubID(pubID);
      }
      if (sysID != null) {
        this.sysID = this.stringify.dtdSysID(sysID);
      }
    }

    XMLDocType.prototype.element = function(name, value) {
      var child;
      child = new XMLDTDElement(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      var child;
      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.entity = function(name, value) {
      var child;
      child = new XMLDTDEntity(this, false, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.pEntity = function(name, value) {
      var child;
      child = new XMLDTDEntity(this, true, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.notation = function(name, value) {
      var child;
      child = new XMLDTDNotation(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.cdata = function(value) {
      var child;
      child = new XMLCData(this, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.comment = function(value) {
      var child;
      child = new XMLComment(this, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.instruction = function(target, value) {
      var child;
      child = new XMLProcessingInstruction(this, target, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.root = function() {
      return this.documentObject.root();
    };

    XMLDocType.prototype.document = function() {
      return this.documentObject;
    };

    XMLDocType.prototype.toString = function(options, level) {
      var child, i, indent, len, newline, offset, pretty, r, ref, ref1, ref2, ref3, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!DOCTYPE ' + this.root().name;
      if (this.pubID && this.sysID) {
        r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
      } else if (this.sysID) {
        r += ' SYSTEM "' + this.sysID + '"';
      }
      if (this.children.length > 0) {
        r += ' [';
        if (pretty) {
          r += newline;
        }
        ref3 = this.children;
        for (i = 0, len = ref3.length; i < len; i++) {
          child = ref3[i];
          r += child.toString(options, level + 1);
        }
        r += ']';
      }
      r += '>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    XMLDocType.prototype.ele = function(name, value) {
      return this.element(name, value);
    };

    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
    };

    XMLDocType.prototype.ent = function(name, value) {
      return this.entity(name, value);
    };

    XMLDocType.prototype.pent = function(name, value) {
      return this.pEntity(name, value);
    };

    XMLDocType.prototype.not = function(name, value) {
      return this.notation(name, value);
    };

    XMLDocType.prototype.dat = function(value) {
      return this.cdata(value);
    };

    XMLDocType.prototype.com = function(value) {
      return this.comment(value);
    };

    XMLDocType.prototype.ins = function(target, value) {
      return this.instruction(target, value);
    };

    XMLDocType.prototype.up = function() {
      return this.root();
    };

    XMLDocType.prototype.doc = function() {
      return this.document();
    };

    return XMLDocType;

  })();

}).call(this);

},{"./XMLCData":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLCData.js","./XMLComment":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLComment.js","./XMLDTDAttList":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLDTDAttList.js","./XMLDTDElement":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLDTDElement.js","./XMLDTDEntity":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLDTDEntity.js","./XMLDTDNotation":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLDTDNotation.js","./XMLProcessingInstruction":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLProcessingInstruction.js","lodash/create":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\create.js","lodash/isObject":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isObject.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLElement.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLAttribute, XMLElement, XMLNode, XMLProcessingInstruction, create, every, isFunction, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = require('lodash/create');

  isObject = require('lodash/isObject');

  isFunction = require('lodash/isFunction');

  every = require('lodash/every');

  XMLNode = require('./XMLNode');

  XMLAttribute = require('./XMLAttribute');

  XMLProcessingInstruction = require('./XMLProcessingInstruction');

  module.exports = XMLElement = (function(superClass) {
    extend(XMLElement, superClass);

    function XMLElement(parent, name, attributes) {
      XMLElement.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing element name");
      }
      this.name = this.stringify.eleName(name);
      this.children = [];
      this.instructions = [];
      this.attributes = {};
      if (attributes != null) {
        this.attribute(attributes);
      }
    }

    XMLElement.prototype.clone = function() {
      var att, attName, clonedSelf, i, len, pi, ref, ref1;
      clonedSelf = create(XMLElement.prototype, this);
      if (clonedSelf.isRoot) {
        clonedSelf.documentObject = null;
      }
      clonedSelf.attributes = {};
      ref = this.attributes;
      for (attName in ref) {
        if (!hasProp.call(ref, attName)) continue;
        att = ref[attName];
        clonedSelf.attributes[attName] = att.clone();
      }
      clonedSelf.instructions = [];
      ref1 = this.instructions;
      for (i = 0, len = ref1.length; i < len; i++) {
        pi = ref1[i];
        clonedSelf.instructions.push(pi.clone());
      }
      clonedSelf.children = [];
      this.children.forEach(function(child) {
        var clonedChild;
        clonedChild = child.clone();
        clonedChild.parent = clonedSelf;
        return clonedSelf.children.push(clonedChild);
      });
      return clonedSelf;
    };

    XMLElement.prototype.attribute = function(name, value) {
      var attName, attValue;
      if (name != null) {
        name = name.valueOf();
      }
      if (isObject(name)) {
        for (attName in name) {
          if (!hasProp.call(name, attName)) continue;
          attValue = name[attName];
          this.attribute(attName, attValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        if (!this.options.skipNullAttributes || (value != null)) {
          this.attributes[name] = new XMLAttribute(this, name, value);
        }
      }
      return this;
    };

    XMLElement.prototype.removeAttribute = function(name) {
      var attName, i, len;
      if (name == null) {
        throw new Error("Missing attribute name");
      }
      name = name.valueOf();
      if (Array.isArray(name)) {
        for (i = 0, len = name.length; i < len; i++) {
          attName = name[i];
          delete this.attributes[attName];
        }
      } else {
        delete this.attributes[name];
      }
      return this;
    };

    XMLElement.prototype.instruction = function(target, value) {
      var i, insTarget, insValue, instruction, len;
      if (target != null) {
        target = target.valueOf();
      }
      if (value != null) {
        value = value.valueOf();
      }
      if (Array.isArray(target)) {
        for (i = 0, len = target.length; i < len; i++) {
          insTarget = target[i];
          this.instruction(insTarget);
        }
      } else if (isObject(target)) {
        for (insTarget in target) {
          if (!hasProp.call(target, insTarget)) continue;
          insValue = target[insTarget];
          this.instruction(insTarget, insValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        instruction = new XMLProcessingInstruction(this, target, value);
        this.instructions.push(instruction);
      }
      return this;
    };

    XMLElement.prototype.toString = function(options, level) {
      var att, child, i, indent, instruction, j, len, len1, name, newline, offset, pretty, r, ref, ref1, ref2, ref3, ref4, ref5, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      ref3 = this.instructions;
      for (i = 0, len = ref3.length; i < len; i++) {
        instruction = ref3[i];
        r += instruction.toString(options, level);
      }
      if (pretty) {
        r += space;
      }
      r += '<' + this.name;
      ref4 = this.attributes;
      for (name in ref4) {
        if (!hasProp.call(ref4, name)) continue;
        att = ref4[name];
        r += att.toString(options);
      }
      if (this.children.length === 0 || every(this.children, function(e) {
        return e.value === '';
      })) {
        r += '/>';
        if (pretty) {
          r += newline;
        }
      } else if (pretty && this.children.length === 1 && (this.children[0].value != null)) {
        r += '>';
        r += this.children[0].value;
        r += '</' + this.name + '>';
        r += newline;
      } else {
        r += '>';
        if (pretty) {
          r += newline;
        }
        ref5 = this.children;
        for (j = 0, len1 = ref5.length; j < len1; j++) {
          child = ref5[j];
          r += child.toString(options, level + 1);
        }
        if (pretty) {
          r += space;
        }
        r += '</' + this.name + '>';
        if (pretty) {
          r += newline;
        }
      }
      return r;
    };

    XMLElement.prototype.att = function(name, value) {
      return this.attribute(name, value);
    };

    XMLElement.prototype.ins = function(target, value) {
      return this.instruction(target, value);
    };

    XMLElement.prototype.a = function(name, value) {
      return this.attribute(name, value);
    };

    XMLElement.prototype.i = function(target, value) {
      return this.instruction(target, value);
    };

    return XMLElement;

  })(XMLNode);

}).call(this);

},{"./XMLAttribute":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLAttribute.js","./XMLNode":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLNode.js","./XMLProcessingInstruction":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLProcessingInstruction.js","lodash/create":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\create.js","lodash/every":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\every.js","lodash/isFunction":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isFunction.js","lodash/isObject":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isObject.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLNode.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLRaw, XMLText, isEmpty, isFunction, isObject,
    hasProp = {}.hasOwnProperty;

  isObject = require('lodash/isObject');

  isFunction = require('lodash/isFunction');

  isEmpty = require('lodash/isEmpty');

  XMLElement = null;

  XMLCData = null;

  XMLComment = null;

  XMLDeclaration = null;

  XMLDocType = null;

  XMLRaw = null;

  XMLText = null;

  module.exports = XMLNode = (function() {
    function XMLNode(parent) {
      this.parent = parent;
      this.options = this.parent.options;
      this.stringify = this.parent.stringify;
      if (XMLElement === null) {
        XMLElement = require('./XMLElement');
        XMLCData = require('./XMLCData');
        XMLComment = require('./XMLComment');
        XMLDeclaration = require('./XMLDeclaration');
        XMLDocType = require('./XMLDocType');
        XMLRaw = require('./XMLRaw');
        XMLText = require('./XMLText');
      }
    }

    XMLNode.prototype.element = function(name, attributes, text) {
      var childNode, item, j, k, key, lastChild, len, len1, ref, val;
      lastChild = null;
      if (attributes == null) {
        attributes = {};
      }
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref = [attributes, text], text = ref[0], attributes = ref[1];
      }
      if (name != null) {
        name = name.valueOf();
      }
      if (Array.isArray(name)) {
        for (j = 0, len = name.length; j < len; j++) {
          item = name[j];
          lastChild = this.element(item);
        }
      } else if (isFunction(name)) {
        lastChild = this.element(name.apply());
      } else if (isObject(name)) {
        for (key in name) {
          if (!hasProp.call(name, key)) continue;
          val = name[key];
          if (isFunction(val)) {
            val = val.apply();
          }
          if ((isObject(val)) && (isEmpty(val))) {
            val = null;
          }
          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && key.indexOf(this.stringify.convertPIKey) === 0) {
            lastChild = this.instruction(key.substr(this.stringify.convertPIKey.length), val);
          } else if (!this.options.separateArrayItems && Array.isArray(val)) {
            for (k = 0, len1 = val.length; k < len1; k++) {
              item = val[k];
              childNode = {};
              childNode[key] = item;
              lastChild = this.element(childNode);
            }
          } else if (isObject(val)) {
            lastChild = this.element(key);
            lastChild.element(val);
          } else {
            lastChild = this.element(key, val);
          }
        }
      } else {
        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
          lastChild = this.text(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
          lastChild = this.cdata(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
          lastChild = this.comment(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
          lastChild = this.raw(text);
        } else {
          lastChild = this.node(name, attributes, text);
        }
      }
      if (lastChild == null) {
        throw new Error("Could not create any elements with: " + name);
      }
      return lastChild;
    };

    XMLNode.prototype.insertBefore = function(name, attributes, text) {
      var child, i, removed;
      if (this.isRoot) {
        throw new Error("Cannot insert elements at root level");
      }
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.element(name, attributes, text);
      Array.prototype.push.apply(this.parent.children, removed);
      return child;
    };

    XMLNode.prototype.insertAfter = function(name, attributes, text) {
      var child, i, removed;
      if (this.isRoot) {
        throw new Error("Cannot insert elements at root level");
      }
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.element(name, attributes, text);
      Array.prototype.push.apply(this.parent.children, removed);
      return child;
    };

    XMLNode.prototype.remove = function() {
      var i, ref;
      if (this.isRoot) {
        throw new Error("Cannot remove the root element");
      }
      i = this.parent.children.indexOf(this);
      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref = [])), ref;
      return this.parent;
    };

    XMLNode.prototype.node = function(name, attributes, text) {
      var child, ref;
      if (name != null) {
        name = name.valueOf();
      }
      if (attributes == null) {
        attributes = {};
      }
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref = [attributes, text], text = ref[0], attributes = ref[1];
      }
      child = new XMLElement(this, name, attributes);
      if (text != null) {
        child.text(text);
      }
      this.children.push(child);
      return child;
    };

    XMLNode.prototype.text = function(value) {
      var child;
      child = new XMLText(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.cdata = function(value) {
      var child;
      child = new XMLCData(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.comment = function(value) {
      var child;
      child = new XMLComment(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.raw = function(value) {
      var child;
      child = new XMLRaw(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.declaration = function(version, encoding, standalone) {
      var doc, xmldec;
      doc = this.document();
      xmldec = new XMLDeclaration(doc, version, encoding, standalone);
      doc.xmldec = xmldec;
      return doc.root();
    };

    XMLNode.prototype.doctype = function(pubID, sysID) {
      var doc, doctype;
      doc = this.document();
      doctype = new XMLDocType(doc, pubID, sysID);
      doc.doctype = doctype;
      return doctype;
    };

    XMLNode.prototype.up = function() {
      if (this.isRoot) {
        throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
      }
      return this.parent;
    };

    XMLNode.prototype.root = function() {
      var child;
      if (this.isRoot) {
        return this;
      }
      child = this.parent;
      while (!child.isRoot) {
        child = child.parent;
      }
      return child;
    };

    XMLNode.prototype.document = function() {
      return this.root().documentObject;
    };

    XMLNode.prototype.end = function(options) {
      return this.document().toString(options);
    };

    XMLNode.prototype.prev = function() {
      var i;
      if (this.isRoot) {
        throw new Error("Root node has no siblings");
      }
      i = this.parent.children.indexOf(this);
      if (i < 1) {
        throw new Error("Already at the first node");
      }
      return this.parent.children[i - 1];
    };

    XMLNode.prototype.next = function() {
      var i;
      if (this.isRoot) {
        throw new Error("Root node has no siblings");
      }
      i = this.parent.children.indexOf(this);
      if (i === -1 || i === this.parent.children.length - 1) {
        throw new Error("Already at the last node");
      }
      return this.parent.children[i + 1];
    };

    XMLNode.prototype.importXMLBuilder = function(xmlbuilder) {
      var clonedRoot;
      clonedRoot = xmlbuilder.root().clone();
      clonedRoot.parent = this;
      clonedRoot.isRoot = false;
      this.children.push(clonedRoot);
      return this;
    };

    XMLNode.prototype.ele = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.nod = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.txt = function(value) {
      return this.text(value);
    };

    XMLNode.prototype.dat = function(value) {
      return this.cdata(value);
    };

    XMLNode.prototype.com = function(value) {
      return this.comment(value);
    };

    XMLNode.prototype.doc = function() {
      return this.document();
    };

    XMLNode.prototype.dec = function(version, encoding, standalone) {
      return this.declaration(version, encoding, standalone);
    };

    XMLNode.prototype.dtd = function(pubID, sysID) {
      return this.doctype(pubID, sysID);
    };

    XMLNode.prototype.e = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.n = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.t = function(value) {
      return this.text(value);
    };

    XMLNode.prototype.d = function(value) {
      return this.cdata(value);
    };

    XMLNode.prototype.c = function(value) {
      return this.comment(value);
    };

    XMLNode.prototype.r = function(value) {
      return this.raw(value);
    };

    XMLNode.prototype.u = function() {
      return this.up();
    };

    return XMLNode;

  })();

}).call(this);

},{"./XMLCData":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLCData.js","./XMLComment":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLComment.js","./XMLDeclaration":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLDeclaration.js","./XMLDocType":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLDocType.js","./XMLElement":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLElement.js","./XMLRaw":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLRaw.js","./XMLText":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLText.js","lodash/isEmpty":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isEmpty.js","lodash/isFunction":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isFunction.js","lodash/isObject":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isObject.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLProcessingInstruction.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLProcessingInstruction, create;

  create = require('lodash/create');

  module.exports = XMLProcessingInstruction = (function() {
    function XMLProcessingInstruction(parent, target, value) {
      this.stringify = parent.stringify;
      if (target == null) {
        throw new Error("Missing instruction target");
      }
      this.target = this.stringify.insTarget(target);
      if (value) {
        this.value = this.stringify.insValue(value);
      }
    }

    XMLProcessingInstruction.prototype.clone = function() {
      return create(XMLProcessingInstruction.prototype, this);
    };

    XMLProcessingInstruction.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<?';
      r += this.target;
      if (this.value) {
        r += ' ' + this.value;
      }
      r += '?>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLProcessingInstruction;

  })();

}).call(this);

},{"lodash/create":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\create.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLRaw.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLNode, XMLRaw, create,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = require('lodash/create');

  XMLNode = require('./XMLNode');

  module.exports = XMLRaw = (function(superClass) {
    extend(XMLRaw, superClass);

    function XMLRaw(parent, text) {
      XMLRaw.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing raw text");
      }
      this.value = this.stringify.raw(text);
    }

    XMLRaw.prototype.clone = function() {
      return create(XMLRaw.prototype, this);
    };

    XMLRaw.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += this.value;
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLRaw;

  })(XMLNode);

}).call(this);

},{"./XMLNode":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLNode.js","lodash/create":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\create.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLStringifier.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLStringifier,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty;

  module.exports = XMLStringifier = (function() {
    function XMLStringifier(options) {
      this.assertLegalChar = bind(this.assertLegalChar, this);
      var key, ref, value;
      this.allowSurrogateChars = options != null ? options.allowSurrogateChars : void 0;
      this.noDoubleEncoding = options != null ? options.noDoubleEncoding : void 0;
      ref = (options != null ? options.stringify : void 0) || {};
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this[key] = value;
      }
    }

    XMLStringifier.prototype.eleName = function(val) {
      val = '' + val || '';
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.eleText = function(val) {
      val = '' + val || '';
      return this.assertLegalChar(this.elEscape(val));
    };

    XMLStringifier.prototype.cdata = function(val) {
      val = '' + val || '';
      if (val.match(/]]>/)) {
        throw new Error("Invalid CDATA text: " + val);
      }
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.comment = function(val) {
      val = '' + val || '';
      if (val.match(/--/)) {
        throw new Error("Comment text cannot contain double-hypen: " + val);
      }
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.raw = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.attName = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.attValue = function(val) {
      val = '' + val || '';
      return this.attEscape(val);
    };

    XMLStringifier.prototype.insTarget = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.insValue = function(val) {
      val = '' + val || '';
      if (val.match(/\?>/)) {
        throw new Error("Invalid processing instruction value: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlVersion = function(val) {
      val = '' + val || '';
      if (!val.match(/1\.[0-9]+/)) {
        throw new Error("Invalid version number: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlEncoding = function(val) {
      val = '' + val || '';
      if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-]|-)*$/)) {
        throw new Error("Invalid encoding: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlStandalone = function(val) {
      if (val) {
        return "yes";
      } else {
        return "no";
      }
    };

    XMLStringifier.prototype.dtdPubID = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdSysID = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdElementValue = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdAttType = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdAttDefault = function(val) {
      if (val != null) {
        return '' + val || '';
      } else {
        return val;
      }
    };

    XMLStringifier.prototype.dtdEntityValue = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdNData = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.convertAttKey = '@';

    XMLStringifier.prototype.convertPIKey = '?';

    XMLStringifier.prototype.convertTextKey = '#text';

    XMLStringifier.prototype.convertCDataKey = '#cdata';

    XMLStringifier.prototype.convertCommentKey = '#comment';

    XMLStringifier.prototype.convertRawKey = '#raw';

    XMLStringifier.prototype.assertLegalChar = function(str) {
      var chars, chr;
      if (this.allowSurrogateChars) {
        chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uFFFE-\uFFFF]/;
      } else {
        chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uD800-\uDFFF\uFFFE-\uFFFF]/;
      }
      chr = str.match(chars);
      if (chr) {
        throw new Error("Invalid character (" + chr + ") in string: " + str + " at index " + chr.index);
      }
      return str;
    };

    XMLStringifier.prototype.elEscape = function(str) {
      var ampregex;
      ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
    };

    XMLStringifier.prototype.attEscape = function(str) {
      var ampregex;
      ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;');
    };

    return XMLStringifier;

  })();

}).call(this);

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLText.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLNode, XMLText, create,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = require('lodash/create');

  XMLNode = require('./XMLNode');

  module.exports = XMLText = (function(superClass) {
    extend(XMLText, superClass);

    function XMLText(parent, text) {
      XMLText.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing element text");
      }
      this.value = this.stringify.eleText(text);
    }

    XMLText.prototype.clone = function() {
      return create(XMLText.prototype, this);
    };

    XMLText.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += this.value;
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLText;

  })(XMLNode);

}).call(this);

},{"./XMLNode":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLNode.js","lodash/create":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\create.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\index.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLBuilder, assign;

  assign = require('lodash/assign');

  XMLBuilder = require('./XMLBuilder');

  module.exports.create = function(name, xmldec, doctype, options) {
    options = assign({}, xmldec, doctype, options);
    return new XMLBuilder(name, options).root();
  };

}).call(this);

},{"./XMLBuilder":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\lib\\XMLBuilder.js","lodash/assign":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\assign.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_DataView.js":[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getNative.js","./_root":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_root.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_Hash.js":[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_hashClear.js","./_hashDelete":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_hashDelete.js","./_hashGet":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_hashGet.js","./_hashHas":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_hashHas.js","./_hashSet":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_hashSet.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_ListCache.js":[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_listCacheClear.js","./_listCacheDelete":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_listCacheDelete.js","./_listCacheGet":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_listCacheGet.js","./_listCacheHas":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_listCacheHas.js","./_listCacheSet":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_listCacheSet.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_Map.js":[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getNative.js","./_root":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_root.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_MapCache.js":[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_mapCacheClear.js","./_mapCacheDelete":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_mapCacheDelete.js","./_mapCacheGet":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_mapCacheGet.js","./_mapCacheHas":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_mapCacheHas.js","./_mapCacheSet":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_mapCacheSet.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_Promise.js":[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getNative.js","./_root":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_root.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_Set.js":[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getNative.js","./_root":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_root.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_SetCache.js":[function(require,module,exports){
var MapCache = require('./_MapCache'),
    setCacheAdd = require('./_setCacheAdd'),
    setCacheHas = require('./_setCacheHas');

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

},{"./_MapCache":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_MapCache.js","./_setCacheAdd":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_setCacheAdd.js","./_setCacheHas":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_setCacheHas.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_Stack.js":[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_ListCache.js","./_stackClear":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_stackClear.js","./_stackDelete":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_stackDelete.js","./_stackGet":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_stackGet.js","./_stackHas":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_stackHas.js","./_stackSet":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_stackSet.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_Symbol.js":[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_root.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_Uint8Array.js":[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_root.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_WeakMap.js":[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getNative.js","./_root":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_root.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_apply.js":[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  var length = args.length;
  switch (length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_arrayEvery.js":[function(require,module,exports){
/**
 * A specialized version of `_.every` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`.
 */
function arrayEvery(array, predicate) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (!predicate(array[index], index, array)) {
      return false;
    }
  }
  return true;
}

module.exports = arrayEvery;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_arrayMap.js":[function(require,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_arraySome.js":[function(require,module,exports){
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_assignValue.js":[function(require,module,exports){
var eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

module.exports = assignValue;

},{"./eq":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\eq.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_assocIndexOf.js":[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to search.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\eq.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseAssign.js":[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keys = require('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_copyObject.js","./keys":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\keys.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseCreate.js":[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

module.exports = baseCreate;

},{"./isObject":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isObject.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseEach.js":[function(require,module,exports){
var baseForOwn = require('./_baseForOwn'),
    createBaseEach = require('./_createBaseEach');

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;

},{"./_baseForOwn":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseForOwn.js","./_createBaseEach":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_createBaseEach.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseEvery.js":[function(require,module,exports){
var baseEach = require('./_baseEach');

/**
 * The base implementation of `_.every` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`
 */
function baseEvery(collection, predicate) {
  var result = true;
  baseEach(collection, function(value, index, collection) {
    result = !!predicate(value, index, collection);
    return result;
  });
  return result;
}

module.exports = baseEvery;

},{"./_baseEach":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseEach.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseFor.js":[function(require,module,exports){
var createBaseFor = require('./_createBaseFor');

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./_createBaseFor":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_createBaseFor.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseForOwn.js":[function(require,module,exports){
var baseFor = require('./_baseFor'),
    keys = require('./keys');

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

},{"./_baseFor":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseFor.js","./keys":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\keys.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseGet.js":[function(require,module,exports){
var castPath = require('./_castPath'),
    isKey = require('./_isKey'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;

},{"./_castPath":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_castPath.js","./_isKey":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isKey.js","./_toKey":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_toKey.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseHas.js":[function(require,module,exports){
var getPrototype = require('./_getPrototype');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,
  // that are composed entirely of index properties, return `false` for
  // `hasOwnProperty` checks of them.
  return hasOwnProperty.call(object, key) ||
    (typeof object == 'object' && key in object && getPrototype(object) === null);
}

module.exports = baseHas;

},{"./_getPrototype":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getPrototype.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseHasIn.js":[function(require,module,exports){
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return key in Object(object);
}

module.exports = baseHasIn;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseIsEqual.js":[function(require,module,exports){
var baseIsEqualDeep = require('./_baseIsEqualDeep'),
    isObject = require('./isObject'),
    isObjectLike = require('./isObjectLike');

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}

module.exports = baseIsEqual;

},{"./_baseIsEqualDeep":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseIsEqualDeep.js","./isObject":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isObject.js","./isObjectLike":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isObjectLike.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseIsEqualDeep.js":[function(require,module,exports){
var Stack = require('./_Stack'),
    equalArrays = require('./_equalArrays'),
    equalByTag = require('./_equalByTag'),
    equalObjects = require('./_equalObjects'),
    getTag = require('./_getTag'),
    isArray = require('./isArray'),
    isHostObject = require('./_isHostObject'),
    isTypedArray = require('./isTypedArray');

/** Used to compose bitmasks for comparison styles. */
var PARTIAL_COMPARE_FLAG = 2;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = getTag(object);
    objTag = objTag == argsTag ? objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = getTag(other);
    othTag = othTag == argsTag ? objectTag : othTag;
  }
  var objIsObj = objTag == objectTag && !isHostObject(object),
      othIsObj = othTag == objectTag && !isHostObject(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

module.exports = baseIsEqualDeep;

},{"./_Stack":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_Stack.js","./_equalArrays":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_equalArrays.js","./_equalByTag":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_equalByTag.js","./_equalObjects":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_equalObjects.js","./_getTag":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getTag.js","./_isHostObject":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isHostObject.js","./isArray":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArray.js","./isTypedArray":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isTypedArray.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseIsMatch.js":[function(require,module,exports){
var Stack = require('./_Stack'),
    baseIsEqual = require('./_baseIsEqual');

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;

},{"./_Stack":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_Stack.js","./_baseIsEqual":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseIsEqual.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseIteratee.js":[function(require,module,exports){
var baseMatches = require('./_baseMatches'),
    baseMatchesProperty = require('./_baseMatchesProperty'),
    identity = require('./identity'),
    isArray = require('./isArray'),
    property = require('./property');

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;

},{"./_baseMatches":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseMatches.js","./_baseMatchesProperty":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseMatchesProperty.js","./identity":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\identity.js","./isArray":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArray.js","./property":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\property.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseKeys.js":[function(require,module,exports){
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = Object.keys;

/**
 * The base implementation of `_.keys` which doesn't skip the constructor
 * property of prototypes or treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  return nativeKeys(Object(object));
}

module.exports = baseKeys;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseMatches.js":[function(require,module,exports){
var baseIsMatch = require('./_baseIsMatch'),
    getMatchData = require('./_getMatchData'),
    matchesStrictComparable = require('./_matchesStrictComparable');

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

},{"./_baseIsMatch":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseIsMatch.js","./_getMatchData":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getMatchData.js","./_matchesStrictComparable":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_matchesStrictComparable.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseMatchesProperty.js":[function(require,module,exports){
var baseIsEqual = require('./_baseIsEqual'),
    get = require('./get'),
    hasIn = require('./hasIn'),
    isKey = require('./_isKey'),
    isStrictComparable = require('./_isStrictComparable'),
    matchesStrictComparable = require('./_matchesStrictComparable'),
    toKey = require('./_toKey');

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
  };
}

module.exports = baseMatchesProperty;

},{"./_baseIsEqual":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseIsEqual.js","./_isKey":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isKey.js","./_isStrictComparable":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isStrictComparable.js","./_matchesStrictComparable":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_matchesStrictComparable.js","./_toKey":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_toKey.js","./get":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\get.js","./hasIn":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\hasIn.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseProperty.js":[function(require,module,exports){
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_basePropertyDeep.js":[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

},{"./_baseGet":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseGet.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseTimes.js":[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseToPairs.js":[function(require,module,exports){
var arrayMap = require('./_arrayMap');

/**
 * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
 * of key-value pairs for `object` corresponding to the property names of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the key-value pairs.
 */
function baseToPairs(object, props) {
  return arrayMap(props, function(key) {
    return [key, object[key]];
  });
}

module.exports = baseToPairs;

},{"./_arrayMap":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_arrayMap.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseToString.js":[function(require,module,exports){
var Symbol = require('./_Symbol'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;

},{"./_Symbol":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_Symbol.js","./isSymbol":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isSymbol.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_castPath.js":[function(require,module,exports){
var isArray = require('./isArray'),
    stringToPath = require('./_stringToPath');

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

module.exports = castPath;

},{"./_stringToPath":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_stringToPath.js","./isArray":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArray.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_checkGlobal.js":[function(require,module,exports){
/**
 * Checks if `value` is a global object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {null|Object} Returns `value` if it's a global object, else `null`.
 */
function checkGlobal(value) {
  return (value && value.Object === Object) ? value : null;
}

module.exports = checkGlobal;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_copyObject.js":[function(require,module,exports){
var assignValue = require('./_assignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : source[key];

    assignValue(object, key, newValue);
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_assignValue.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_createAssigner.js":[function(require,module,exports){
var isIterateeCall = require('./_isIterateeCall'),
    rest = require('./rest');

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return rest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"./_isIterateeCall":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isIterateeCall.js","./rest":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\rest.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_createBaseEach.js":[function(require,module,exports){
var isArrayLike = require('./isArrayLike');

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;

},{"./isArrayLike":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArrayLike.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_createBaseFor.js":[function(require,module,exports){
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_createToPairs.js":[function(require,module,exports){
var baseToPairs = require('./_baseToPairs'),
    getTag = require('./_getTag'),
    mapToArray = require('./_mapToArray'),
    setToPairs = require('./_setToPairs');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/**
 * Creates a `_.toPairs` or `_.toPairsIn` function.
 *
 * @private
 * @param {Function} keysFunc The function to get the keys of a given object.
 * @returns {Function} Returns the new pairs function.
 */
function createToPairs(keysFunc) {
  return function(object) {
    var tag = getTag(object);
    if (tag == mapTag) {
      return mapToArray(object);
    }
    if (tag == setTag) {
      return setToPairs(object);
    }
    return baseToPairs(object, keysFunc(object));
  };
}

module.exports = createToPairs;

},{"./_baseToPairs":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseToPairs.js","./_getTag":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getTag.js","./_mapToArray":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_mapToArray.js","./_setToPairs":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_setToPairs.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_equalArrays.js":[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arraySome = require('./_arraySome');

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

  stack.set(array, other);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!seen.has(othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, customizer, bitmask, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  return result;
}

module.exports = equalArrays;

},{"./_SetCache":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_SetCache.js","./_arraySome":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_arraySome.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_equalByTag.js":[function(require,module,exports){
var Symbol = require('./_Symbol'),
    Uint8Array = require('./_Uint8Array'),
    equalArrays = require('./_equalArrays'),
    mapToArray = require('./_mapToArray'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
      // Coerce dates and booleans to numbers, dates to milliseconds and
      // booleans to `1` or `0` treating invalid dates coerced to `NaN` as
      // not equal.
      return +object == +other;

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case numberTag:
      // Treat `NaN` vs. `NaN` as equal.
      return (object != +object) ? other != +other : object == +other;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/6.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= UNORDERED_COMPARE_FLAG;
      stack.set(object, other);

      // Recursively compare objects (susceptible to call stack limits).
      return equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;

},{"./_Symbol":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_Symbol.js","./_Uint8Array":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_Uint8Array.js","./_equalArrays":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_equalArrays.js","./_mapToArray":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_mapToArray.js","./_setToArray":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_setToArray.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_equalObjects.js":[function(require,module,exports){
var baseHas = require('./_baseHas'),
    keys = require('./keys');

/** Used to compose bitmasks for comparison styles. */
var PARTIAL_COMPARE_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : baseHas(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  return result;
}

module.exports = equalObjects;

},{"./_baseHas":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseHas.js","./keys":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\keys.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getLength.js":[function(require,module,exports){
var baseProperty = require('./_baseProperty');

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a
 * [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792) that affects
 * Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

module.exports = getLength;

},{"./_baseProperty":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseProperty.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getMapData.js":[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isKeyable.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getMatchData.js":[function(require,module,exports){
var isStrictComparable = require('./_isStrictComparable'),
    toPairs = require('./toPairs');

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = toPairs(object),
      length = result.length;

  while (length--) {
    result[length][2] = isStrictComparable(result[length][1]);
  }
  return result;
}

module.exports = getMatchData;

},{"./_isStrictComparable":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isStrictComparable.js","./toPairs":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\toPairs.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getNative.js":[function(require,module,exports){
var isNative = require('./isNative');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object[key];
  return isNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./isNative":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isNative.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getPrototype.js":[function(require,module,exports){
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetPrototype = Object.getPrototypeOf;

/**
 * Gets the `[[Prototype]]` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {null|Object} Returns the `[[Prototype]]`.
 */
function getPrototype(value) {
  return nativeGetPrototype(Object(value));
}

module.exports = getPrototype;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getTag.js":[function(require,module,exports){
var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    toSource = require('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function getTag(value) {
  return objectToString.call(value);
}

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_DataView.js","./_Map":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_Map.js","./_Promise":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_Promise.js","./_Set":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_Set.js","./_WeakMap":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_WeakMap.js","./_toSource":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_toSource.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_hasPath.js":[function(require,module,exports){
var castPath = require('./_castPath'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isIndex = require('./_isIndex'),
    isKey = require('./_isKey'),
    isLength = require('./isLength'),
    isString = require('./isString'),
    toKey = require('./_toKey');

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = isKey(path, object) ? [path] : castPath(path);

  var result,
      index = -1,
      length = path.length;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result) {
    return result;
  }
  var length = object ? object.length : 0;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isString(object) || isArguments(object));
}

module.exports = hasPath;

},{"./_castPath":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_castPath.js","./_isIndex":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isIndex.js","./_isKey":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isKey.js","./_toKey":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_toKey.js","./isArguments":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArguments.js","./isArray":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArray.js","./isLength":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isLength.js","./isString":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isString.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_hashClear.js":[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

module.exports = hashClear;

},{"./_nativeCreate":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_nativeCreate.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_hashDelete.js":[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

module.exports = hashDelete;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_hashGet.js":[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_nativeCreate.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_hashHas.js":[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_nativeCreate.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_hashSet.js":[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_nativeCreate.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_indexKeys.js":[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isLength = require('./isLength'),
    isString = require('./isString');

/**
 * Creates an array of index keys for `object` values of arrays,
 * `arguments` objects, and strings, otherwise `null` is returned.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array|null} Returns index keys, else `null`.
 */
function indexKeys(object) {
  var length = object ? object.length : undefined;
  if (isLength(length) &&
      (isArray(object) || isString(object) || isArguments(object))) {
    return baseTimes(length, String);
  }
  return null;
}

module.exports = indexKeys;

},{"./_baseTimes":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseTimes.js","./isArguments":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArguments.js","./isArray":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArray.js","./isLength":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isLength.js","./isString":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isString.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isHostObject.js":[function(require,module,exports){
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

module.exports = isHostObject;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isIndex.js":[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isIterateeCall.js":[function(require,module,exports){
var eq = require('./eq'),
    isArrayLike = require('./isArrayLike'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject');

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

},{"./_isIndex":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isIndex.js","./eq":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\eq.js","./isArrayLike":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArrayLike.js","./isObject":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isObject.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isKey.js":[function(require,module,exports){
var isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;

},{"./isArray":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArray.js","./isSymbol":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isSymbol.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isKeyable.js":[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isPrototype.js":[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isStrictComparable.js":[function(require,module,exports){
var isObject = require('./isObject');

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

},{"./isObject":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isObject.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_listCacheClear.js":[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

module.exports = listCacheClear;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_listCacheDelete.js":[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_assocIndexOf.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_listCacheGet.js":[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_assocIndexOf.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_listCacheHas.js":[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_assocIndexOf.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_listCacheSet.js":[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_assocIndexOf.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_mapCacheClear.js":[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_Hash.js","./_ListCache":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_ListCache.js","./_Map":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_Map.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_mapCacheDelete.js":[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

module.exports = mapCacheDelete;

},{"./_getMapData":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getMapData.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_mapCacheGet.js":[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getMapData.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_mapCacheHas.js":[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getMapData.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_mapCacheSet.js":[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getMapData.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_mapToArray.js":[function(require,module,exports){
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_matchesStrictComparable.js":[function(require,module,exports){
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_nativeCreate.js":[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getNative.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_root.js":[function(require,module,exports){
(function (global){
var checkGlobal = require('./_checkGlobal');

/** Used to determine if values are of the language type `Object`. */
var objectTypes = {
  'function': true,
  'object': true
};

/** Detect free variable `exports`. */
var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
  ? exports
  : undefined;

/** Detect free variable `module`. */
var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
  ? module
  : undefined;

/** Detect free variable `global` from Node.js. */
var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);

/** Detect free variable `self`. */
var freeSelf = checkGlobal(objectTypes[typeof self] && self);

/** Detect free variable `window`. */
var freeWindow = checkGlobal(objectTypes[typeof window] && window);

/** Detect `this` as the global object. */
var thisGlobal = checkGlobal(objectTypes[typeof this] && this);

/**
 * Used as a reference to the global object.
 *
 * The `this` value is used if it's the global object to avoid Greasemonkey's
 * restricted `window` object, otherwise the `window` object is used.
 */
var root = freeGlobal ||
  ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
    freeSelf || thisGlobal || Function('return this')();

module.exports = root;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_checkGlobal":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_checkGlobal.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_setCacheAdd.js":[function(require,module,exports){
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_setCacheHas.js":[function(require,module,exports){
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_setToArray.js":[function(require,module,exports){
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_setToPairs.js":[function(require,module,exports){
/**
 * Converts `set` to its value-value pairs.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the value-value pairs.
 */
function setToPairs(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = [value, value];
  });
  return result;
}

module.exports = setToPairs;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_stackClear.js":[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

module.exports = stackClear;

},{"./_ListCache":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_ListCache.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_stackDelete.js":[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

module.exports = stackDelete;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_stackGet.js":[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_stackHas.js":[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_stackSet.js":[function(require,module,exports){
var ListCache = require('./_ListCache'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache && cache.__data__.length == LARGE_ARRAY_SIZE) {
    cache = this.__data__ = new MapCache(cache.__data__);
  }
  cache.set(key, value);
  return this;
}

module.exports = stackSet;

},{"./_ListCache":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_ListCache.js","./_MapCache":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_MapCache.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_stringToPath.js":[function(require,module,exports){
var memoize = require('./memoize'),
    toString = require('./toString');

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  var result = [];
  toString(string).replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;

},{"./memoize":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\memoize.js","./toString":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\toString.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_toKey.js":[function(require,module,exports){
var isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;

},{"./isSymbol":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isSymbol.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_toSource.js":[function(require,module,exports){
/** Used to resolve the decompiled source of functions. */
var funcToString = Function.prototype.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\assign.js":[function(require,module,exports){
var assignValue = require('./_assignValue'),
    copyObject = require('./_copyObject'),
    createAssigner = require('./_createAssigner'),
    isArrayLike = require('./isArrayLike'),
    isPrototype = require('./_isPrototype'),
    keys = require('./keys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.c = 3;
 * }
 *
 * function Bar() {
 *   this.e = 5;
 * }
 *
 * Foo.prototype.d = 4;
 * Bar.prototype.f = 6;
 *
 * _.assign({ 'a': 1 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3, 'e': 5 }
 */
var assign = createAssigner(function(object, source) {
  if (nonEnumShadows || isPrototype(source) || isArrayLike(source)) {
    copyObject(source, keys(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty.call(source, key)) {
      assignValue(object, key, source[key]);
    }
  }
});

module.exports = assign;

},{"./_assignValue":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_assignValue.js","./_copyObject":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_copyObject.js","./_createAssigner":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_createAssigner.js","./_isPrototype":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isPrototype.js","./isArrayLike":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArrayLike.js","./keys":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\keys.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\constant.js":[function(require,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var getter = _.constant(object);
 *
 * getter() === object;
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\create.js":[function(require,module,exports){
var baseAssign = require('./_baseAssign'),
    baseCreate = require('./_baseCreate');

/**
 * Creates an object that inherits from the `prototype` object. If a
 * `properties` object is given, its own enumerable string keyed properties
 * are assigned to the created object.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Object
 * @param {Object} prototype The object to inherit from.
 * @param {Object} [properties] The properties to assign to the object.
 * @returns {Object} Returns the new object.
 * @example
 *
 * function Shape() {
 *   this.x = 0;
 *   this.y = 0;
 * }
 *
 * function Circle() {
 *   Shape.call(this);
 * }
 *
 * Circle.prototype = _.create(Shape.prototype, {
 *   'constructor': Circle
 * });
 *
 * var circle = new Circle;
 * circle instanceof Circle;
 * // => true
 *
 * circle instanceof Shape;
 * // => true
 */
function create(prototype, properties) {
  var result = baseCreate(prototype);
  return properties ? baseAssign(result, properties) : result;
}

module.exports = create;

},{"./_baseAssign":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseAssign.js","./_baseCreate":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseCreate.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\eq.js":[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'user': 'fred' };
 * var other = { 'user': 'fred' };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\every.js":[function(require,module,exports){
var arrayEvery = require('./_arrayEvery'),
    baseEvery = require('./_baseEvery'),
    baseIteratee = require('./_baseIteratee'),
    isArray = require('./isArray'),
    isIterateeCall = require('./_isIterateeCall');

/**
 * Checks if `predicate` returns truthy for **all** elements of `collection`.
 * Iteration is stopped once `predicate` returns falsey. The predicate is
 * invoked with three arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array|Function|Object|string} [predicate=_.identity]
 *  The function invoked per iteration.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`.
 * @example
 *
 * _.every([true, 1, null, 'yes'], Boolean);
 * // => false
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': false },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * // The `_.matches` iteratee shorthand.
 * _.every(users, { 'user': 'barney', 'active': false });
 * // => false
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.every(users, ['active', false]);
 * // => true
 *
 * // The `_.property` iteratee shorthand.
 * _.every(users, 'active');
 * // => false
 */
function every(collection, predicate, guard) {
  var func = isArray(collection) ? arrayEvery : baseEvery;
  if (guard && isIterateeCall(collection, predicate, guard)) {
    predicate = undefined;
  }
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = every;

},{"./_arrayEvery":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_arrayEvery.js","./_baseEvery":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseEvery.js","./_baseIteratee":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseIteratee.js","./_isIterateeCall":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isIterateeCall.js","./isArray":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArray.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\get.js":[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is used in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

},{"./_baseGet":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseGet.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\hasIn.js":[function(require,module,exports){
var baseHasIn = require('./_baseHasIn'),
    hasPath = require('./_hasPath');

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

},{"./_baseHasIn":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseHasIn.js","./_hasPath":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_hasPath.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\identity.js":[function(require,module,exports){
/**
 * This method returns the first argument given to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArguments.js":[function(require,module,exports){
var isArrayLikeObject = require('./isArrayLikeObject');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

module.exports = isArguments;

},{"./isArrayLikeObject":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArrayLikeObject.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArray.js":[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @type {Function}
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArrayLike.js":[function(require,module,exports){
var getLength = require('./_getLength'),
    isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value)) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./_getLength":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getLength.js","./isFunction":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isFunction.js","./isLength":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isLength.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArrayLikeObject.js":[function(require,module,exports){
var isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

},{"./isArrayLike":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArrayLike.js","./isObjectLike":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isObjectLike.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isBuffer.js":[function(require,module,exports){
var constant = require('./constant'),
    root = require('./_root');

/** Used to determine if values are of the language type `Object`. */
var objectTypes = {
  'function': true,
  'object': true
};

/** Detect free variable `exports`. */
var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
  ? exports
  : undefined;

/** Detect free variable `module`. */
var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
  ? module
  : undefined;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = (freeModule && freeModule.exports === freeExports)
  ? freeExports
  : undefined;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = !Buffer ? constant(false) : function(value) {
  return value instanceof Buffer;
};

module.exports = isBuffer;

},{"./_root":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_root.js","./constant":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\constant.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isEmpty.js":[function(require,module,exports){
var getTag = require('./_getTag'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isArrayLike = require('./isArrayLike'),
    isBuffer = require('./isBuffer'),
    isFunction = require('./isFunction'),
    isObjectLike = require('./isObjectLike'),
    isString = require('./isString'),
    keys = require('./keys');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (isArrayLike(value) &&
      (isArray(value) || isString(value) || isFunction(value.splice) ||
        isArguments(value) || isBuffer(value))) {
    return !value.length;
  }
  if (isObjectLike(value)) {
    var tag = getTag(value);
    if (tag == mapTag || tag == setTag) {
      return !value.size;
    }
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return !(nonEnumShadows && keys(value).length);
}

module.exports = isEmpty;

},{"./_getTag":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_getTag.js","./isArguments":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArguments.js","./isArray":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArray.js","./isArrayLike":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArrayLike.js","./isBuffer":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isBuffer.js","./isFunction":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isFunction.js","./isObjectLike":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isObjectLike.js","./isString":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isString.js","./keys":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\keys.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isFunction.js":[function(require,module,exports){
var isObject = require('./isObject');

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array and weak map constructors,
  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

module.exports = isFunction;

},{"./isObject":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isObject.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isLength.js":[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length,
 *  else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isNative.js":[function(require,module,exports){
var isFunction = require('./isFunction'),
    isHostObject = require('./_isHostObject'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (!isObject(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = isNative;

},{"./_isHostObject":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isHostObject.js","./_toSource":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_toSource.js","./isFunction":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isFunction.js","./isObject":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isObject.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isObject.js":[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isObjectLike.js":[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isString.js":[function(require,module,exports){
var isArray = require('./isArray'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var stringTag = '[object String]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
}

module.exports = isString;

},{"./isArray":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArray.js","./isObjectLike":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isObjectLike.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isSymbol.js":[function(require,module,exports){
var isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

module.exports = isSymbol;

},{"./isObjectLike":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isObjectLike.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isTypedArray.js":[function(require,module,exports){
var isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
function isTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

module.exports = isTypedArray;

},{"./isLength":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isLength.js","./isObjectLike":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isObjectLike.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\keys.js":[function(require,module,exports){
var baseHas = require('./_baseHas'),
    baseKeys = require('./_baseKeys'),
    indexKeys = require('./_indexKeys'),
    isArrayLike = require('./isArrayLike'),
    isIndex = require('./_isIndex'),
    isPrototype = require('./_isPrototype');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  var isProto = isPrototype(object);
  if (!(isProto || isArrayLike(object))) {
    return baseKeys(object);
  }
  var indexes = indexKeys(object),
      skipIndexes = !!indexes,
      result = indexes || [],
      length = result.length;

  for (var key in object) {
    if (baseHas(object, key) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length))) &&
        !(isProto && key == 'constructor')) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keys;

},{"./_baseHas":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseHas.js","./_baseKeys":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseKeys.js","./_indexKeys":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_indexKeys.js","./_isIndex":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isIndex.js","./_isPrototype":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isPrototype.js","./isArrayLike":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isArrayLike.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\memoize.js":[function(require,module,exports){
var MapCache = require('./_MapCache');

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

module.exports = memoize;

},{"./_MapCache":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_MapCache.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\property.js":[function(require,module,exports){
var baseProperty = require('./_baseProperty'),
    basePropertyDeep = require('./_basePropertyDeep'),
    isKey = require('./_isKey'),
    toKey = require('./_toKey');

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

},{"./_baseProperty":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseProperty.js","./_basePropertyDeep":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_basePropertyDeep.js","./_isKey":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_isKey.js","./_toKey":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_toKey.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\rest.js":[function(require,module,exports){
var apply = require('./_apply'),
    toInteger = require('./toInteger');

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as
 * an array.
 *
 * **Note:** This method is based on the
 * [rest parameter](https://mdn.io/rest_parameters).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.rest(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function rest(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = nativeMax(start === undefined ? (func.length - 1) : toInteger(start), 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    switch (start) {
      case 0: return func.call(this, array);
      case 1: return func.call(this, args[0], array);
      case 2: return func.call(this, args[0], args[1], array);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

module.exports = rest;

},{"./_apply":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_apply.js","./toInteger":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\toInteger.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\toFinite.js":[function(require,module,exports){
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\toNumber.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\toInteger.js":[function(require,module,exports){
var toFinite = require('./toFinite');

/**
 * Converts `value` to an integer.
 *
 * **Note:** This function is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;

},{"./toFinite":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\toFinite.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\toNumber.js":[function(require,module,exports){
var isFunction = require('./isFunction'),
    isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = isFunction(value.valueOf) ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isFunction":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isFunction.js","./isObject":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isObject.js","./isSymbol":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\isSymbol.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\toPairs.js":[function(require,module,exports){
var createToPairs = require('./_createToPairs'),
    keys = require('./keys');

/**
 * Creates an array of own enumerable string keyed-value pairs for `object`
 * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
 * entries are returned.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias entries
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the key-value pairs.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.toPairs(new Foo);
 * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
 */
var toPairs = createToPairs(keys);

module.exports = toPairs;

},{"./_createToPairs":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_createToPairs.js","./keys":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\keys.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\toString.js":[function(require,module,exports){
var baseToString = require('./_baseToString');

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

},{"./_baseToString":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\node_modules\\xml2js\\node_modules\\xmlbuilder\\node_modules\\lodash\\_baseToString.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\index.js":[function(require,module,exports){
module.exports = {
	PanelManager : require('./src/PanelManager'),
	Panel: require('./src/Panel'),
	BaseTransition: require('./src/transition/BaseTransition'),
	ShowTransitionMovement: require('./src/transition/show/ShowTransitionMovement'),
	ShowTransitionAlphaAndMovement: require('./src/transition/show/ShowTransitionAlphaAndMovement'),
	ShowTransitionAlpha: require('./src/transition/show/ShowTransitionAlpha'),
	HideTransitionMovement: require('./src/transition/hide/HideTransitionMovement')

};

},{"./src/Panel":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\src\\Panel.js","./src/PanelManager":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\src\\PanelManager.js","./src/transition/BaseTransition":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\src\\transition\\BaseTransition.js","./src/transition/hide/HideTransitionMovement":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\src\\transition\\hide\\HideTransitionMovement.js","./src/transition/show/ShowTransitionAlpha":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\src\\transition\\show\\ShowTransitionAlpha.js","./src/transition/show/ShowTransitionAlphaAndMovement":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\src\\transition\\show\\ShowTransitionAlphaAndMovement.js","./src/transition/show/ShowTransitionMovement":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\src\\transition\\show\\ShowTransitionMovement.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\src\\Panel.js":[function(require,module,exports){
/**
 * Created by JIocb on 2/3/2016.
 */

var ShowTransition = require('./transition/show/ShowTransitionMovement');
var HideTransition = require('./transition/hide/HideTransitionMovement');

var Panel = function (game,guiBuilder)
{
    'use strict';
    Phaser.Group.call(this, game, null);
    this._game = game;
    this._guiBuilder = guiBuilder;
    this.signal = new Phaser.Signal();

};

// ========== Prototype =========
Panel.prototype = Object.create(Phaser.Group.prototype);
Panel.prototype.constructor = Panel;
module.exports = Panel;


Panel.prototype.build = function() {
    'use strict';
};

Panel.prototype.onClosed = function() {
    'use strict';

    this.signal.dispatch(this,'pressClose');
};

Panel.prototype.reset = function() {
    'use strict';

    this._data = null;

    if (this._showTransition)
    {
        this._showTransition.destroy();
        this._showTransition = null;
    }

    if(this._hideTransition)
    {
        this._hideTransition.destroy();
        this._hideTransition = null;
    }
};

Panel.prototype.initialize = function(aspectRatio,data) {
    'use strict';
    this._data = data;
    this._aspectRatio = aspectRatio || 'landscape';
    this.build();
};

Panel.prototype.resize = function(aspectRatio) {
    'use strict';

    if(this._aspectRatio !== aspectRatio)
    {
        this._aspectRatio = aspectRatio;
        this.changeAspectRatio();
    }
};

Panel.prototype.changeAspectRatio = function() {
    'use strict';
    this.reset();
    this.build();
};

Panel.prototype.createShowTransition = function() {
    'use strict';
    return new ShowTransition(this._game, this, 0, -3000, 0, 0, 250, Phaser.Easing.Linear.None);
};

Panel.prototype.createHideTransition = function() {
    'use strict';
    return new HideTransition(this._game, this, this.x, this.y - 3000, 250, Phaser.Easing.Linear.None);
};

Panel.prototype.open = function() {
    'use strict';
    this.visible = true;
    this._showTransition = this.createShowTransition();
    this._showTransition.start(this.onShowed,this);
};

Panel.prototype.onShowed = function() {
    'use strict';

    this._showTransition.destroy();
    this._showTransition = null;
};


Panel.prototype.close = function() {
    'use strict';
    this._hideTransition = this.createHideTransition();
    this._hideTransition.start(this.onHided,this);
};

Panel.prototype.onHided = function() {
    'use strict';
    this.visible = false;
    this._hideTransition.destroy();
    this._hideTransition = null;
    this.signal.dispatch(this,'hided');
};


Panel.prototype.destroy = function() {
    'use strict';

    this.reset();
    this._guiBuilder = null;
    this._game = null;
    this.signal.removeAll();
    this.signal = null;
    this._name = null;
};

},{"./transition/hide/HideTransitionMovement":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\src\\transition\\hide\\HideTransitionMovement.js","./transition/show/ShowTransitionMovement":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\src\\transition\\show\\ShowTransitionMovement.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\src\\PanelManager.js":[function(require,module,exports){
/**
 * Created by JIocb on 2/3/2016.
 */

var PanelManager = function (game,guiBuilder,aspectRatio)
{
    'use strict';

    this._game = game;
    this._guiBuilder = guiBuilder;
    this._classByKey = {};
    this._currentPanels = {};
    this._aspectRatio = aspectRatio;

};

// ========== Prototype =========
PanelManager.prototype = Object.create(Object.prototype);
PanelManager.prototype.constructor = PanelManager;
module.exports = PanelManager;

PanelManager.prototype.setRoot = function(container) {
    'use strict';
    this._boardContainer = container;

};

PanelManager.prototype.registerPanel = function(panelName, panelClass) {
    'use strict';
    this._classByKey[panelName] = panelClass;

};

PanelManager.prototype.open = function(panelName,data) {
    'use strict';

    var panel = this._currentPanels[panelName];
    if(panel)
    {
        panel.reset();
        this._boardContainer.addChild(panel);
        panel.initialize(this._aspectRatio,data);
        panel.open();
        this._currentPanels[panelName]  = panel;
        return panel;
    }

    var cl = this._classByKey[panelName];
    panel = new cl(this._game,this._guiBuilder);
    this._boardContainer.addChild(panel);
    panel.initialize(this._aspectRatio,data);
    panel.open();
    this._currentPanels[panelName]  = panel;
    return panel;
};

PanelManager.prototype.close = function(panelName) {
    'use strict';

    var panel = this._currentPanels[panelName];

    if(panel)
    {
        panel.close();
    }

    return panel;
};

PanelManager.prototype.resize = function(aspectRatio) {
    'use strict';

    this._aspectRatio = aspectRatio;

    for(var key in this._currentPanels)
    {
        if(this._currentPanels.hasOwnProperty(key)) {
            var panel = this._currentPanels[key];

            if (panel != null && panel.parent) {
                panel.resize(this._aspectRatio);
            }
        }
    }

};

/*
PanelManager.prototype.onPanelEvent = function(panel,eventname) {
    'use strict';
    console.log('onClosePanelEvent',eventname,panel);
    if(eventname == 'pressClose')
    {
        panel.close();
    }
    else if(eventname === 'hided')
    {
        console.log("REMOVED PANEL")
        this._boardContainer.removeChild(panel);
        delete(this._currentPanels[panel.name]);
        panel.reset();
    }
};
*/

PanelManager.prototype.destroy = function() {
    'use strict';

    console.log("Destroy")

    for(var key in this._currentPanels)
    {
        if(this._currentPanels.hasOwnProperty(key)) {
            var panel = this._currentPanels[key];

            if (panel != null && panel.parent) {
                panel.destroy();
                this._boardContainer.removeChild(panel)
            }
        }
    }

    this._aspectRatio = null;
    this._classByKey = null;
    this._currentPanels = null;

    this._boardContainer = null;
    this._game = null;
    this._guiBuilder = null;

};
},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\src\\transition\\BaseTransition.js":[function(require,module,exports){
/**
 * Created by JIocb on 2/4/2016.
 */
var BaseTransition = function (game,panel)
{
    "use strict";
    this._game = game;
    this._panel = panel;

};

// ========== Prototype =========
BaseTransition.prototype = Object.create(Object.prototype);
BaseTransition.prototype.constructor = BaseTransition;
module.exports = BaseTransition;

BaseTransition.prototype.start = function(callBack,callBackContext)
{
    this._callBack = callBack;
    this._callBackContext = callBackContext;

    if(this._callBack && this._callBackContext)
    {
        this._callBack.call(this._callBackContext);
    }
};


BaseTransition.prototype.destroy = function()
{
    this._callBack = null;
    this._callBackContext = null;

};
},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\src\\transition\\hide\\HideTransitionMovement.js":[function(require,module,exports){
/**
 * Created by JIocb on 2/4/2016.
 */
var BaseTransition = require('./../BaseTransition');

var HideTransitionMovement = function (game, panel, toX, toY, timeInMsc, easing)
{
    'use strict';
    BaseTransition.call(this, game,panel);
    this._toX = toX;
    this._toY = toY;
    this._timeInMsc = timeInMsc || 100;
    this._easing = easing || Phaser.Easing.Linear.None;
};

// ========== Prototype =========
HideTransitionMovement.prototype = Object.create(BaseTransition);
HideTransitionMovement.prototype.constructor = HideTransitionMovement;
module.exports = HideTransitionMovement;


HideTransitionMovement.prototype.start = function(callBack,callBackContext)
{
    'use strict';
    this._callBack = callBack;
    this._callBackContext = callBackContext;

    this._tween = this._game.add.tween(this._panel);
    this._tween.onComplete.add(this._callBack,this._callBackContext);
    this._tween.to({ x : this._toX, y : this._toY}, this._timeInMsc, this._easing);
    this._tween.start();
};


HideTransitionMovement.prototype.destroy = function()
{
    'use strict';
    this._callBack = null;
    this._callBackContext = null;
    if(this._tween)
    {
        this._tween.pause();
    }
    this._game.tweens.remove(this._tween);
};


},{"./../BaseTransition":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\src\\transition\\BaseTransition.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\src\\transition\\show\\ShowTransitionAlpha.js":[function(require,module,exports){
/**
 * Created by jedi on 24-Feb-16.
 */

var BaseTransition = require('./../BaseTransition');
var ShowTransitionAlpha = function (game, panel, fromAlpha, toAlpha, timeInMsc, easing)
{
    'use strict';
    BaseTransition.call(this, game,panel);
    this._fromAlpha = fromAlpha;
    this._toAlpha = toAlpha;
    this._timeInMsc = timeInMsc || 100;
    this._easing = easing || Phaser.Easing.Linear.None;
};

// ========== Prototype =========
ShowTransitionAlpha.prototype = Object.create(BaseTransition);
ShowTransitionAlpha.prototype.constructor = ShowTransitionAlpha;
module.exports = ShowTransitionAlpha;


ShowTransitionAlpha.prototype.start = function(callBack, callBackContext) {
    'use strict';
    this._callBack = callBack;
    this._callBackContext = callBackContext;

    this._tween = this._game.add.tween(this._panel);
    this._tween.onComplete.add(this._callBack, this._callBackContext);
    this._panel.alpha = this._fromAlpha;
    this._tween.to({ alpha : this._toAlpha}, this._timeInMsc, this._easing);
    this._tween.start();
};


ShowTransitionAlpha.prototype.destroy = function()
{
    'use strict';
    this._callBack = null;
    this._callBackContext = null;
    if(this._tween)
    {
        this._tween.pause();
    }
    this._game.tweens.remove(this._tween);
};


},{"./../BaseTransition":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\src\\transition\\BaseTransition.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\src\\transition\\show\\ShowTransitionAlphaAndMovement.js":[function(require,module,exports){
/**
 * Created by jedi on 28-Feb-16.
 */

var BaseTransition = require('./../BaseTransition');
var ShowTransitionAlphaAndMovement = function (game, panel, fromX, fromY, toX, toY, fromAlpha, toAlpha, timeInMsc, easing)
{
    'use strict';
    BaseTransition.call(this, game,panel);
    this._fromX = fromX;
    this._fromY = fromY;
    this._toX = toX;
    this._toY = toY;
    this._fromAlpha = fromAlpha;
    this._toAlpha = toAlpha;
    this._timeInMsc = timeInMsc || 100;
    this._easing = easing || Phaser.Easing.Linear.None;
};

// ========== Prototype =========
ShowTransitionAlphaAndMovement.prototype = Object.create(BaseTransition);
ShowTransitionAlphaAndMovement.prototype.constructor = ShowTransitionAlphaAndMovement;
module.exports = ShowTransitionAlphaAndMovement;


ShowTransitionAlphaAndMovement.prototype.start = function(callBack, callBackContext) {
    'use strict';
    this._callBack = callBack;
    this._callBackContext = callBackContext;

    this._tween = this._game.add.tween(this._panel);
    this._tween.onComplete.add(this._callBack, this._callBackContext);
    this._panel.x = this._fromX;
    this._panel.y = this._fromY;
    this._panel.alpha = this._fromAlpha;
    this._tween.to({ x : this._toX, y : this._toY, alpha : this._toAlpha}, this._timeInMsc, this._easing);
    this._tween.start();

};


ShowTransitionAlphaAndMovement.prototype.destroy = function()
{
    'use strict';
    this._callBack = null;
    this._callBackContext = null;
    if(this._tween)
    {
        this._tween.pause();
    }
    this._game.tweens.remove(this._tween);
};


},{"./../BaseTransition":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\src\\transition\\BaseTransition.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\src\\transition\\show\\ShowTransitionMovement.js":[function(require,module,exports){
/**
 * Created by JIocb on 2/4/2016.
 */
var BaseTransition = require('./../BaseTransition');
var ShowTransitionMovement = function (game, panel, fromX, fromY, toX, toY, timeInMsc, easing)
{
    'use strict';
    BaseTransition.call(this, game,panel);
    this._fromX = fromX;
    this._fromY = fromY;
    this._toX = toX;
    this._toY = toY;
    this._timeInMsc = timeInMsc || 100;
    this._easing = easing || Phaser.Easing.Linear.None;
};

// ========== Prototype =========
ShowTransitionMovement.prototype = Object.create(BaseTransition);
ShowTransitionMovement.prototype.constructor = ShowTransitionMovement;
module.exports = ShowTransitionMovement;


ShowTransitionMovement.prototype.start = function(callBack, callBackContext) {
    'use strict';
    this._callBack = callBack;
    this._callBackContext = callBackContext;
    this._panel.y = this._fromY;
    this._panel.x = this._fromX;

    this._tween = this._game.add.tween(this._panel);
    this._tween.onComplete.add(this._callBack, this._callBackContext);
    this._panel.x = this._fromX;
    this._panel.y = this._fromY;
    this._tween.to({ x : this._toX, y : this._toY}, this._timeInMsc, this._easing);
    this._tween.start();

};


ShowTransitionMovement.prototype.destroy = function()
{
    'use strict';
    this._callBack = null;
    this._callBackContext = null;
    if(this._tween)
    {
        this._tween.pause();
    }
    this._game.tweens.remove(this._tween);
};

},{"./../BaseTransition":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\src\\transition\\BaseTransition.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js":[function(require,module,exports){

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\buffer\\index.js":[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; i++) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  that.write(string, encoding)
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

function arrayIndexOf (arr, val, byteOffset, encoding) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var foundIndex = -1
  for (var i = 0; byteOffset + i < arrLength; i++) {
    if (read(arr, byteOffset + i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
      if (foundIndex === -1) foundIndex = i
      if (i - foundIndex + 1 === valLength) return (byteOffset + foundIndex) * indexSize
    } else {
      if (foundIndex !== -1) i -= i - foundIndex
      foundIndex = -1
    }
  }
  return -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  if (Buffer.isBuffer(val)) {
    // special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(this, val, byteOffset, encoding)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset, encoding)
  }

  throw new TypeError('val must be string, number or Buffer')
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; i++) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; i++) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\buffer\\node_modules\\base64-js\\lib\\b64.js","ieee754":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\buffer\\node_modules\\ieee754\\index.js","isarray":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\buffer\\node_modules\\isarray\\index.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\buffer\\node_modules\\base64-js\\lib\\b64.js":[function(require,module,exports){
'use strict'

exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

function init () {
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i]
    revLookup[code.charCodeAt(i)] = i
  }

  revLookup['-'.charCodeAt(0)] = 62
  revLookup['_'.charCodeAt(0)] = 63
}

init()

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\buffer\\node_modules\\ieee754\\index.js":[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\buffer\\node_modules\\isarray\\index.js":[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\events\\events.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\inherits\\inherits_browser.js":[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\insert-module-globals\\node_modules\\is-buffer\\index.js":[function(require,module,exports){
/**
 * Determine if an object is Buffer
 *
 * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * License:  MIT
 *
 * `npm install is-buffer`
 */

module.exports = function (obj) {
  return !!(obj != null &&
    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
      (obj.constructor &&
      typeof obj.constructor.isBuffer === 'function' &&
      obj.constructor.isBuffer(obj))
    ))
}

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\process\\browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\duplex.js":[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\lib\\_stream_duplex.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\lib\\_stream_duplex.js":[function(require,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\lib\\_stream_readable.js","./_stream_writable":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\lib\\_stream_writable.js","core-util-is":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\node_modules\\core-util-is\\lib\\util.js","inherits":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\inherits\\inherits_browser.js","process-nextick-args":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\node_modules\\process-nextick-args\\index.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\lib\\_stream_passthrough.js":[function(require,module,exports){
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\lib\\_stream_transform.js","core-util-is":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\node_modules\\core-util-is\\lib\\util.js","inherits":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\inherits\\inherits_browser.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\lib\\_stream_readable.js":[function(require,module,exports){
(function (process){
'use strict';

module.exports = Readable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

var hasPrependListener = typeof EE.prototype.prependListener === 'function';

function prependListener(emitter, event, fn) {
  if (hasPrependListener) return emitter.prependListener(event, fn);

  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS. This is here
  // only because this code needs to continue to work with older versions
  // of Node.js that do not include the prependListener() method. The goal
  // is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

var Duplex;
function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

var Duplex;
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function') this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = bufferShim.from(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error('stream.unshift() after end event');
      stream.emit('error', _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }

      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

          if (state.needReadable) emitReadable(stream);
        }
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended) return 0;

  if (state.objectMode) return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;
  }

  if (n <= 0) return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else {
      return state.length;
    }
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended) state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var _i = 0; _i < len; _i++) {
      dests[_i].emit('unpipe', this);
    }return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1) return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && !this._readableState.endEmitted) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0) return null;

  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode) ret = list.join('');else if (list.length === 1) ret = list[0];else ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode) ret = '';else ret = bufferShim.allocUnsafe(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var _buf = list[0];
        var cpy = Math.min(n - c, _buf.length);

        if (stringMode) ret += _buf.slice(0, cpy);else _buf.copy(ret, c, 0, cpy);

        if (cpy < _buf.length) list[0] = _buf.slice(cpy);else list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'))

},{"./_stream_duplex":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\lib\\_stream_duplex.js","_process":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\process\\browser.js","buffer":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\buffer\\index.js","buffer-shims":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\node_modules\\buffer-shims\\index.js","core-util-is":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\node_modules\\core-util-is\\lib\\util.js","events":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\events\\events.js","inherits":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\inherits\\inherits_browser.js","isarray":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\node_modules\\isarray\\index.js","process-nextick-args":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\node_modules\\process-nextick-args\\index.js","string_decoder/":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\string_decoder\\index.js","util":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\lib\\_stream_transform.js":[function(require,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er) {
      done(stream, er);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('Not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

function done(stream, er) {
  if (er) return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\lib\\_stream_duplex.js","core-util-is":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\node_modules\\core-util-is\\lib\\util.js","inherits":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\inherits\\inherits_browser.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\lib\\_stream_writable.js":[function(require,module,exports){
(function (process){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream;
(function () {
  try {
    Stream = require('st' + 'ream');
  } catch (_) {} finally {
    if (!Stream) Stream = require('events').EventEmitter;
  }
})();
/*</replacement>*/

var Buffer = require('buffer').Buffer;
/*<replacement>*/
var bufferShim = require('buffer-shims');
/*</replacement>*/

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

var Duplex;
function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~ ~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
  } catch (_) {}
})();

var Duplex;
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  // Always throw error if a null is written
  // if we are not in object mode then throw
  // if it is not a buffer, string, or undefined.
  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = bufferShim.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);

  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) processNextTick(cb, er);else cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
        afterWrite(stream, state, finished, cb);
      }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
}).call(this,require('_process'))

},{"./_stream_duplex":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\lib\\_stream_duplex.js","_process":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\process\\browser.js","buffer":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\buffer\\index.js","buffer-shims":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\node_modules\\buffer-shims\\index.js","core-util-is":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\node_modules\\core-util-is\\lib\\util.js","events":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\events\\events.js","inherits":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\inherits\\inherits_browser.js","process-nextick-args":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\node_modules\\process-nextick-args\\index.js","util-deprecate":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\node_modules\\util-deprecate\\browser.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\node_modules\\buffer-shims\\index.js":[function(require,module,exports){
(function (global){
'use strict';

var buffer = require('buffer');
var Buffer = buffer.Buffer;
var SlowBuffer = buffer.SlowBuffer;
var MAX_LEN = buffer.kMaxLength || 2147483647;
exports.alloc = function alloc(size, fill, encoding) {
  if (typeof Buffer.alloc === 'function') {
    return Buffer.alloc(size, fill, encoding);
  }
  if (typeof encoding === 'number') {
    throw new TypeError('encoding must not be number');
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  var enc = encoding;
  var _fill = fill;
  if (_fill === undefined) {
    enc = undefined;
    _fill = 0;
  }
  var buf = new Buffer(size);
  if (typeof _fill === 'string') {
    var fillBuf = new Buffer(_fill, enc);
    var flen = fillBuf.length;
    var i = -1;
    while (++i < size) {
      buf[i] = fillBuf[i % flen];
    }
  } else {
    buf.fill(_fill);
  }
  return buf;
}
exports.allocUnsafe = function allocUnsafe(size) {
  if (typeof Buffer.allocUnsafe === 'function') {
    return Buffer.allocUnsafe(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size > MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new Buffer(size);
}
exports.from = function from(value, encodingOrOffset, length) {
  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
    return Buffer.from(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof value === 'string') {
    return new Buffer(value, encodingOrOffset);
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    var offset = encodingOrOffset;
    if (arguments.length === 1) {
      return new Buffer(value);
    }
    if (typeof offset === 'undefined') {
      offset = 0;
    }
    var len = length;
    if (typeof len === 'undefined') {
      len = value.byteLength - offset;
    }
    if (offset >= value.byteLength) {
      throw new RangeError('\'offset\' is out of bounds');
    }
    if (len > value.byteLength - offset) {
      throw new RangeError('\'length\' is out of bounds');
    }
    return new Buffer(value.slice(offset, offset + len));
  }
  if (Buffer.isBuffer(value)) {
    var out = new Buffer(value.length);
    value.copy(out, 0, 0, value.length);
    return out;
  }
  if (value) {
    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
      return new Buffer(value);
    }
    if (value.type === 'Buffer' && Array.isArray(value.data)) {
      return new Buffer(value.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
}
exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
  if (typeof Buffer.allocUnsafeSlow === 'function') {
    return Buffer.allocUnsafeSlow(size);
  }
  if (typeof size !== 'number') {
    throw new TypeError('size must be a number');
  }
  if (size >= MAX_LEN) {
    throw new RangeError('size is too large');
  }
  return new SlowBuffer(size);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"buffer":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\buffer\\index.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\node_modules\\core-util-is\\lib\\util.js":[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../../../insert-module-globals/node_modules/is-buffer/index.js")})

},{"../../../../insert-module-globals/node_modules/is-buffer/index.js":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\insert-module-globals\\node_modules\\is-buffer\\index.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\node_modules\\isarray\\index.js":[function(require,module,exports){
arguments[4]["e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\buffer\\node_modules\\isarray\\index.js"][0].apply(exports,arguments)
},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\node_modules\\process-nextick-args\\index.js":[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,require('_process'))

},{"_process":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\process\\browser.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\node_modules\\util-deprecate\\browser.js":[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\passthrough.js":[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\lib\\_stream_passthrough.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\readable.js":[function(require,module,exports){
(function (process){
var Stream = (function (){
  try {
    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify
  } catch(_){}
}());
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = Stream || exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
}

}).call(this,require('_process'))

},{"./lib/_stream_duplex.js":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\lib\\_stream_duplex.js","./lib/_stream_passthrough.js":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\lib\\_stream_passthrough.js","./lib/_stream_readable.js":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\lib\\_stream_readable.js","./lib/_stream_transform.js":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\lib\\_stream_transform.js","./lib/_stream_writable.js":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\lib\\_stream_writable.js","_process":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\process\\browser.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\transform.js":[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\lib\\_stream_transform.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\writable.js":[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\lib\\_stream_writable.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\stream-browserify\\index.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\events\\events.js","inherits":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\inherits\\inherits_browser.js","readable-stream/duplex.js":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\duplex.js","readable-stream/passthrough.js":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\passthrough.js","readable-stream/readable.js":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\readable.js","readable-stream/transform.js":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\transform.js","readable-stream/writable.js":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\readable-stream\\writable.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\string_decoder\\index.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\buffer\\index.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\timers-browserify\\main.js":[function(require,module,exports){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
},{"process/browser.js":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\browserify\\node_modules\\process\\browser.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\xmlserializer\\lib\\serializer.js":[function(require,module,exports){
var removeInvalidCharacters = function (content) {
    // See http://www.w3.org/TR/xml/#NT-Char for valid XML 1.0 characters
    return content.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F]/g, '');
};

var serializeAttributeValue = function (value) {
    return value
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;');
};

var serializeTextContent = function (content) {
    return content
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
};

var serializeAttribute = function (attr) {
    var value = attr.value;

    return ' ' + attr.name + '="' + serializeAttributeValue(value) + '"';
};

var getTagName = function (node) {
    var tagName = node.tagName;

    // Aid in serializing of original HTML documents
    if (node.namespaceURI === 'http://www.w3.org/1999/xhtml') {
        tagName = tagName.toLowerCase();
    }
    return tagName;
};

var serializeNamespace = function (node) {
    var nodeHasXmlnsAttr = Array.prototype.map.call(node.attributes || node.attrs, function (attr) {
            return attr.name;
        })
        .indexOf('xmlns') >= 0;
    // Serialize the namespace as an xmlns attribute whenever the element
    // doesn't already have one and the inherited namespace does not match
    // the element's namespace.
    // As a special case, always include an xmlns for html elements, in case
    // of broken namespaceURI handling by browsers.
    if (!nodeHasXmlnsAttr &&
            (!node.parentNode ||
             node.namespaceURI !== node.parentNode.namespaceURI ||
             getTagName(node) === 'html')) {
         return ' xmlns="' + node.namespaceURI + '"';
    } else {
        return '';
    }
};

var serializeChildren = function (node) {
    return Array.prototype.map.call(node.childNodes, function (childNode) {
        return nodeTreeToXHTML(childNode);
    }).join('');
};

var serializeTag = function (node) {
    var output = '<' + getTagName(node);
    output += serializeNamespace(node);

    Array.prototype.forEach.call(node.attributes || node.attrs, function (attr) {
        output += serializeAttribute(attr);
    });

    if (node.childNodes.length > 0) {
        output += '>';
        output += serializeChildren(node);
        output += '</' + getTagName(node) + '>';
    } else {
        output += '/>';
    }
    return output;
};

var serializeText = function (node) {
    var text = node.nodeValue || node.value || '';
    return serializeTextContent(text);
};

var serializeComment = function (node) {
    return '<!--' +
        node.data
            .replace(/-/g, '&#45;') +
        '-->';
};

var serializeCDATA = function (node) {
    return '<![CDATA[' + node.nodeValue + ']]>';
};

var nodeTreeToXHTML = function (node) {
    if (node.nodeName === '#document' ||
        node.nodeName === '#document-fragment') {
        return serializeChildren(node);
    } else {
        if (node.tagName) {
            return serializeTag(node);
        } else if (node.nodeName === '#text') {
            return serializeText(node);
        } else if (node.nodeName === '#comment') {
            return serializeComment(node);
        } else if (node.nodeName === '#cdata-section') {
            return serializeCDATA(node);
        }
    }
};

exports.serializeToString = function (document) {
    return removeInvalidCharacters(nodeTreeToXHTML(document));
};

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\GameSettings.js":[function(require,module,exports){
/**
 * Created by Stas on 1/16/2015.
 */


// ========================= Construction =========================
/**
 * Contains game option, meant to be used as singleton
 * @type {{alphabet: string}}
 */
var GameSettings = {
    // Fonts
    lightFont: "Gotham-Light",
    mediumFont: "Gotham-Medium",

    // Atlases
    gameAtlas: "gameAtlas",
    uiAtlas: "uiAtlas",
    assetScale: 1,

    // Device variables (settings that are affected by specific devices)
    currentDevice: 0,
    animatePopups: true, // play popup tweens if running in WebGL, but not in canvas
    cullListItems: false, // manually cull list items if the device doesn't support masking

    // Game variables
    wereOptionsChanged: false,

    // App variables
    version: "0.01",
    DEBUG: true
};
module.exports = GameSettings;

// ========================= Sizes =========================
GameSettings.Sizes = {
    small: "small",
    medium: "medium",
    large: "large"
};
Object.freeze(GameSettings.Sizes);

GameSettings.AssetScales = {
    small: 0.6,
    medium: 0.8,
    large: 1
};
Object.freeze(GameSettings.AssetScales);

GameSettings.setAssetSizeMultiplier = function (game) {
    "use strict";
    game.scale.setMaximum();
    game.scale.refresh();
    game.scale.boot();
    GameSettings.assetScale = GameSettings.AssetScales.large;

    var minSideLength = Math.min(game.scale.width, game.scale.height);
    if(minSideLength > 900){
        GameSettings.assetScale = GameSettings.AssetScales.large;
    }
    else if(minSideLength>600){
        GameSettings.assetScale = GameSettings.AssetScales.medium;
    }
    else {
        GameSettings.assetScale = GameSettings.AssetScales.small;
    }
    console.log("GameSettings.setAssetSizeMultiplier()", game.width, game.height, GameSettings.assetScale);
};

// ========================= Options =========================
GameSettings.Options = {
    showTimer: true
};

GameSettings.loadOptions = function () {
    "use strict";
    if (typeof(Storage) !== "undefined") {
        var loadedOptions = localStorage.getItem("GameSettings.Options");
        if (loadedOptions != null) {
            GameSettings.Options = JSON.parse(loadedOptions);
        }
    }
};

GameSettings.saveOptions = function () {
    "use strict";
    if (typeof(Storage) !== "undefined") {
        try {
            localStorage.setItem("GameSettings.Options", JSON.stringify(GameSettings.Options));
        }
        catch(error) {
            console.log("GameSettings.saveOptions()", error.message);
        }
    }
};


// ========================= Enums =========================
GameSettings.PopupStates = {
    hidden: 0, // Popup is not shown
    appearing: 1, // Popup is playing a tween-in animation
    visible: 2, // Popup is shown onscreen
    disappearing: 3 // Popup is playing a tween-out animation, returns to Hidden state afterwards
};
Object.freeze(GameSettings.PopupStates);

GameSettings.OptionsItems = {
    Help: 3,
    ExitPuzzle: 5
};
Object.freeze(GameSettings.OptionsItems);

GameSettings.EndGameReason = {
    Completed: "Game Completed",
    Quit: "Quit"
};
Object.freeze(GameSettings.EndGameReason);

GameSettings.InputPriorities = {
    Default: 0,
    Scrim: 1,
    Popups: 2,
    PopupItems: 3,
    Buttons: 4
};
Object.freeze(GameSettings.InputPriorities);

GameSettings.Devices = {
    Desktop: 0,
    Tablet: 1,
    Phone: 2
};
Object.freeze(GameSettings.Devices);

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\Plugins\\FPSMeter.js":[function(require,module,exports){
/**
 * A FPS meter Plugin that integrates statjs into phaser js behavior
 * you need https://github.com/mrdoob/stats.js/ in order to make this plugin work properly
 */
var Stats = require("./Stats");
Phaser.Plugin.FPSMeter = function (game, parent) {
    Phaser.Plugin.call(this, game, parent);
    this.enableStats();
};
// Extends the Phaser.Plugin template, setting up values we need
Phaser.Plugin.FPSMeter.prototype = Object.create(Phaser.Plugin.prototype);
Phaser.Plugin.FPSMeter.prototype.constructor = Phaser.Plugin.FPSMeter;
/**
 * This is run when the plugins update during the core game loop.
 */
Phaser.Plugin.FPSMeter.prototype.preUpdate = function () {
    this.Stats.begin();
};
Phaser.Plugin.FPSMeter.prototype.postUpdate = function () {
    this.Stats.end();
};
Phaser.Plugin.FPSMeter.prototype.enableStats = function(){
    this.Stats = new Stats();
    this.Stats.setMode(0); // 0: fps, 1: ms

    // align top-left
    this.Stats.domElement.style.position = 'absolute';
    this.Stats.domElement.style.left = '0px';
    this.Stats.domElement.style.top = '0px';
    document.body.appendChild( this.Stats.domElement );
};
module.exports = Phaser.Plugin.FPSMeter;
/**
 * Created by Stas on 12/1/2014.
 */

},{"./Stats":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\Plugins\\Stats.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\Plugins\\SaveCPU.js":[function(require,module,exports){
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Ivanix Mobile LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */

/*
 * Plugin: SaveCPU
 * Author: Ivanix @ Ivanix Mobile LLC
 * Purpose:  Reduce CPU usage caused from redudant rendering
 *           on idle or static display scenes
 *           reduce fps for casual/puzzle games
 *
 *
 * Configurable Properties:
 *                
 * [renderOnFPS]   
 * Constrains maximum FPS to value set. 
 * Reasonable values from 0 to 60 
 * Default value 30
 * Set value to 0 disable rendering based on FPS
 * and use methods described below.
 *
 * [renderOnPointerChange]   
 * Render when pointer movement detected.
 * Possible values  "true" or "false"
 * Default: false
 * Note that renderOnFPS must be set to 0
 *
 *
 * Callable Methods:
 * 
 * [forceRender()]
 * Forces rendering during core game loop
 * Can be called independently or in tandem with above properties.
 * Should be called inside update function.
 *
 */

/*global
    Phaser: true,
    window: true
 */
/*jslint nomen: true */

Phaser.Plugin.SaveCPU = function (game, parent) {
    'use strict';

    Phaser.Plugin.call(this, game, parent);

};
Phaser.Plugin.SaveCPU.prototype = Object.create(Phaser.Plugin.prototype);
Phaser.Plugin.SaveCPU.constructor = Phaser.Plugin.SaveCPU;

Phaser.Plugin.SaveCPU.prototype.init = function () {
    'use strict';
    this.now = window.performance.now();
    this.renderType = this.game.renderType;

    // fps default
    this.renderOnFPS = 30;
    this.renderOnPointerChange = false;
    this.renderDirty = true;
};
Phaser.Plugin.SaveCPU.prototype.setRender = function () {
    'use strict';
    if (this.renderDirty) {
        this.game.renderType = this.renderType;
    } else {
        this.game.renderType = Phaser.HEADLESS;
    }
    this.renderDirty = false;
};
Phaser.Plugin.SaveCPU.prototype.forceRender = function () {
    'use strict';
    this.renderDirty = true;
};
Phaser.Plugin.SaveCPU.prototype.forceRenderOnPointerChange = function () {
    'use strict';
    
    var input = this.game.input;

    if (input.oldx !== input.x || input.oldy !== input.y) {
        this.forceRender();
        input.oldx = input.x;
        input.oldy = input.y;
    }
    if (input.oldDown !== input.activePointer.isDown) {
        this.forceRender();
        input.oldDown = input.activePointer.isDown;
    }
};
Phaser.Plugin.SaveCPU.prototype.forceRenderOnFPS = function () {
    'use strict';
    
    var ts, diff;

    ts = window.performance.now();
    diff = ts - this.now;
    if (diff < (1000 / this.renderOnFPS)) {
        return false;
    }
    this.now = ts;
    this.forceRender();
    return true;

};
Phaser.Plugin.SaveCPU.prototype.postUpdate = function () {
    'use strict';
    if (this.renderOnFPS && this.forceRenderOnFPS()) {
        this.setRender();
        return;
    }
    if (this.renderOnPointerChange && this.forceRenderOnPointerChange()) {
        this.setRender();
        return;
    }
    this.setRender();
};
Phaser.Plugin.SaveCPU.prototype.postRender = function () {
    'use strict';
    if (this.game._paused) {
        this.game.renderType = Phaser.HEADLESS;
    }
};
module.exports = Phaser.Plugin.SaveCPU;

},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\Plugins\\Stats.js":[function(require,module,exports){
/**
 * @author mrdoob / http://mrdoob.com/
 */

var Stats = function () {

	var startTime = Date.now(), prevTime = startTime;
	var ms = 0, msMin = Infinity, msMax = 0;
	var fps = 0, fpsMin = Infinity, fpsMax = 0;
	var frames = 0, mode = 0;

	var container = document.createElement( 'div' );
	container.id = 'stats';
	container.addEventListener( 'mousedown', function ( event ) { event.preventDefault(); setMode( ++ mode % 2 ) }, false );
	container.style.cssText = 'width:80px;opacity:0.9;cursor:pointer';

	var fpsDiv = document.createElement( 'div' );
	fpsDiv.id = 'fps';
	fpsDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#002';
	container.appendChild( fpsDiv );

	var fpsText = document.createElement( 'div' );
	fpsText.id = 'fpsText';
	fpsText.style.cssText = 'color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
	fpsText.innerHTML = 'FPS';
	fpsDiv.appendChild( fpsText );

	var fpsGraph = document.createElement( 'div' );
	fpsGraph.id = 'fpsGraph';
	fpsGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0ff';
	fpsDiv.appendChild( fpsGraph );

	while ( fpsGraph.children.length < 74 ) {

		var bar = document.createElement( 'span' );
		bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#113';
		fpsGraph.appendChild( bar );

	}

	var msDiv = document.createElement( 'div' );
	msDiv.id = 'ms';
	msDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#020;display:none';
	container.appendChild( msDiv );

	var msText = document.createElement( 'div' );
	msText.id = 'msText';
	msText.style.cssText = 'color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
	msText.innerHTML = 'MS';
	msDiv.appendChild( msText );

	var msGraph = document.createElement( 'div' );
	msGraph.id = 'msGraph';
	msGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0f0';
	msDiv.appendChild( msGraph );

	while ( msGraph.children.length < 74 ) {

		var bar = document.createElement( 'span' );
		bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#131';
		msGraph.appendChild( bar );

	}

	var setMode = function ( value ) {

		mode = value;

		switch ( mode ) {

			case 0:
				fpsDiv.style.display = 'block';
				msDiv.style.display = 'none';
				break;
			case 1:
				fpsDiv.style.display = 'none';
				msDiv.style.display = 'block';
				break;
		}

	};

	var updateGraph = function ( dom, value ) {

		var child = dom.appendChild( dom.firstChild );
		child.style.height = value + 'px';

	};

	return {

		REVISION: 12,

		domElement: container,

		setMode: setMode,

		begin: function () {

			startTime = Date.now();

		},

		end: function () {

			var time = Date.now();

			ms = time - startTime;
			msMin = Math.min( msMin, ms );
			msMax = Math.max( msMax, ms );

			msText.textContent = ms + ' MS (' + msMin + '-' + msMax + ')';
			updateGraph( msGraph, Math.min( 30, 30 - ( ms / 200 ) * 30 ) );

			frames ++;

			if ( time > prevTime + 1000 ) {

				fps = Math.round( ( frames * 1000 ) / ( time - prevTime ) );
				fpsMin = Math.min( fpsMin, fps );
				fpsMax = Math.max( fpsMax, fps );

				fpsText.textContent = fps + ' FPS (' + fpsMin + '-' + fpsMax + ')';
				updateGraph( fpsGraph, Math.min( 30, 30 - ( fps / 100 ) * 30 ) );

				prevTime = time;
				frames = 0;

			}

			return time;

		},

		update: function () {

			startTime = this.end();

		}

	}

};

if ( typeof module === 'object' ) {

	module.exports = Stats;

}
},{}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\main.js":[function(require,module,exports){
'use strict';

var game = new Phaser.Game(1600, 1200, Phaser.AUTO, 'game-template'); // jshint ignore:line


window.Utils = require('./utils/utils');
window.playerState = {
    currentLevel: 'Game'
};

game.state.add('Boot', require('./states/boot'));
game.state.add('Preloader', require('./states/preloader'));
game.state.add('Menu', require('./states/menu'));
//game.state.add('Game', require('./states/game'));

game.state.start('Boot');
},{"./states/boot":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\states\\boot.js","./states/menu":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\states\\menu.js","./states/preloader":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\states\\preloader.js","./utils/utils":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\utils\\utils.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\panel\\SamplePanel.js":[function(require,module,exports){
/**
 * Created by klimashevsky
 */
var PanelManagerModule = require("arkadium-panelmanager-test");
var GameSettings = require("../GameSettings");
function SamplePanel(game, guiBuilder) {
    'use strict';
    PanelManagerModule.Panel.call(this, game, guiBuilder);
    
}
SamplePanel.NAME = 'SamplePanel';

SamplePanel.prototype = Object.create(PanelManagerModule.Panel.prototype);
SamplePanel.prototype.constructor = SamplePanel;
module.exports = SamplePanel;

SamplePanel.prototype.build = function() {
    'use strict';
    PanelManagerModule.Panel.prototype.build.call(this);
    this.img = new Phaser.Image(this._game,0,0,'gameBackground');
    this.addChild(this.img);

    this.label = new Phaser.BitmapText(this._game, 0, 0, GameSettings.mediumFont, "100", 56);
    this.label.text = "Sample Panel "+ this._data.customData;

    this.label.y = 100;

    this.addChild(this.label);

    console.log("I was Created",this._data.customData);

};

SamplePanel.prototype.destroy= function()
{

    "use strict";
    this.removeChild(this.img,true)
    this.removeChild(this.label,true)
    PanelManagerModule.Panel.prototype.destroy.call(this);
};

SamplePanel.prototype.createShowTransition = function() {
    'use strict';
    return new PanelManagerModule.ShowTransitionMovement(this._game, this, 0, -1000, 0, 0, 500, Phaser.Easing.Linear.None);
};

SamplePanel.prototype.createHideTransition = function() {
    'use strict';
    return new PanelManagerModule.HideTransitionMovement(this._game, this, this.x, this.y - 1000, 500, Phaser.Easing.Linear.None);
};


},{"../GameSettings":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\GameSettings.js","arkadium-panelmanager-test":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\index.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\states\\boot.js":[function(require,module,exports){
var SaveCPU = require("../Plugins/SaveCPU");
var FPSMeter = require("../Plugins/FPSMeter");
var Boot = function () {
};

Boot.prototype = {

    preload: function () {
        "use strict";
        console.log("boot started");
        //JSGameAdapt.Initialize('6d702868-43ea-436b-a461-f288576cd364', 'a880bf88-9f00-4d03-8c23-096130df9bb5', 'http://adapt.as.arkadiumhosted.com/', true);
        this.game.stage.setBackgroundColor("0xffffff");
    },

    create: function () {
        "use strict";
        this.game.scale.scaleMode = Phaser.ScaleManager.RESIZE;
        this.game.scale.pageAlignHorizontally = true;
        this.game.scale.pageAlignVertically = true;
        console.log(this.game.scale.height);
        console.log(this.game.scale.width);
        this.game.plugins.add(SaveCPU);
        //this.game.plugins.add(FPSMeter);
        this.game.state.start('Preloader');
    }
};

module.exports = Boot;

},{"../Plugins/FPSMeter":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\Plugins\\FPSMeter.js","../Plugins/SaveCPU":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\Plugins\\SaveCPU.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\states\\menu.js":[function(require,module,exports){
var PanelManagerModule = require("arkadium-panelmanager-test");
var SamplePanel = require("../panel/SamplePanel");
var GameSettings = require("../GameSettings");
// ========================= Construction =========================
var Menu = function () {
  "use strict";
  this.puzzleInfoList = []; // List of info for all the puzzles that we attempted to load
};


// ========================= Prototype =========================
Menu.prototype = {
  preload: function() {
    "use strict";


  },

  create: function () {
    "use strict";
    document.getElementById('game_preloader').style.visibility = "hidden";

    // ========================= Container =========================

    this.container = new Phaser.Group(this.game,null);
    this.game.add.existing(this.container);

    //in case if you have guibuilder module you can pass it here and use in your panels
    var guiBuilder = null;
    this._panelManager = new PanelManagerModule.PanelManager(this.game,guiBuilder,"landscape");
    this._panelManager.setRoot(this.container)
    this._panelManager.registerPanel("sample_panel",SamplePanel)

    this.label = new Phaser.BitmapText(this.game, 0, 0, GameSettings.mediumFont, "100", 56);
    this.label.text = "CLICK TO OPEN PANEL";
    this.label.tint = 0xb36d43;
    this.game.add.existing(this.label);
    this.opened = false;
    this.game.input.mouse.mouseDownCallback = this.onInputDownHandler.bind(this);


    //this._panelManager.open("sample_panel",{customData:"Bla bla bla"});
    // Add event listeners
    this.onResize();
  },

  onInputDownHandler:function (sprite, pointer) {
  "use strict";
    if(this.opened == true)
    {
      this.label.text = "CLICK TO OPEN PANEL";
      this.opened = false;
      this._panelManager.close("sample_panel");
    }
    else
    {
      this.label.text = "CLICK TO CLOSE PANEL";
      this.opened = true;
      this._panelManager.open("sample_panel", {customData: "Bla bla bla"});
    }

  },

  // ========================= Update =========================
  update: function() {
    "use strict";
  },

  onResize: function() {
    "use strict";
    // We need to call this twice...
  },

  // ========================= Button Event =========================

  startGameScene: function() {
    "use strict";
    // Clear this state and switch to new one
    this.destroy();
    this.game.state.clearCurrentState();
    this.game.state.start('Game');
  },

  // ========================= Destruction =========================
  destroy: function() {
    "use strict";
    this.game.scale.onSizeChange.remove(this.onResize, this);
    this.playButton.destroy();
  }
};

// ========================= Exports =========================
module.exports = Menu;
},{"../GameSettings":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\GameSettings.js","../panel/SamplePanel":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\panel\\SamplePanel.js","arkadium-panelmanager-test":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\arkadium-panelmanager-test\\index.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\states\\preloader.js":[function(require,module,exports){

// ========================= Requirements =========================
var xml = require('XML');
var GameSettings = require("../GameSettings");
var xmlserializer = require('xmlserializer');

// ========================= Construction =========================
var Preloader = function (game) {
    "use strict";
    this.asset = null;
    this.ready = false;
    this.preloadBar = null;
    this.preloadanimationComplete = false;
    this.allPreloadingComplete = false;
};
module.exports = Preloader;


// ========================= Prototype =========================
Preloader.prototype = {

    // region ========================= Preloading =========================
    preload: function () {
        "use strict";
        // Initialize variables
        var currentState = this;
        this.preloadanimationComplete = false;
        this.allPreloadingComplete = false;

        document.getElementById('game_preloader').style.visibility = "visible";
        GameSettings.setAssetSizeMultiplier(this.game);

        // Load the assets used in the game
        this.load.image('gameScrim', 'assets/images/gameScrim.png');
        this.load.image('gameBackground', 'assets/images/gameBackground.jpg');
        this.load.atlas(GameSettings.gameAtlas, 'assets/images/'+GameSettings.assetScale+'x/'+GameSettings.gameAtlas+'.png', 'assets/images/'+GameSettings.assetScale+'x/'+GameSettings.gameAtlas+'.json');
        this.load.atlas(GameSettings.uiAtlas, 'assets/images/'+GameSettings.assetScale+'x/'+GameSettings.uiAtlas+'.png', 'assets/images/'+GameSettings.assetScale+'x/'+GameSettings.uiAtlas+'.json');
        this.load.xml(GameSettings.lightFont + ".fnt", 'assets/fonts/'+GameSettings.lightFont+'.fnt');
        this.load.xml(GameSettings.mediumFont + ".fnt", 'assets/fonts/'+GameSettings.mediumFont+'.fnt');

        // Analytics
        JSGameAdapt.Track.BeginSession();
        JSGameAdapt.Track.PageView(JSGameAdapt.PAGEVIEW_BEGIN_LOADING);

        // DEBUG: These next 3 lines are for debugging, turn this on if you want to remove the animated logo
        if (GameSettings.DEBUG) {
            ARK_gameJQ('#swiffycontainer').removeClass('visible');
            currentState.preloadanimationComplete = true;
            return;
        }

        // Create Swiffy animation
        var swiffyobject = this.getSwiffyData();
        this.stage = new swiffy.Stage(document.getElementById('swiffycontainer'), swiffyobject);
        this.stage.start();
        setTimeout(function (){
            currentState.preloadanimationComplete = true;
            ARK_gameJQ('#swiffycontainer').removeClass('visible');
            document.getElementById('game_preloader').style.visibility="visible";
            currentState.stage.destroy();
            if(currentState.allPreloadingComplete === true){
               currentState.finishedPreloadingAndPreloaderAnimation();
            }},5000 );
        document.getElementById('game_preloader').style.visibility = "hidden";
    },
    // endregion

    // region ========================= Creation =========================
    create: function () {
        "use strict";
        ARK_game_arena_connector.init(); // Initialize arena connection
        this.determineDevice(); // Determine the device that the player is playing on
        this.determineCapability(); // Determine if the device can run certain processes
        this.loadBitmapFonts(); // Load bitmap fonts
        GameSettings.loadOptions(); // Load saved game options
    },

    determineDevice: function() {
        "use strict";
        // First, check if the game is running on desktop
        // "device.desktop" reports inaccurately on Internet Explorer, so we'll assume anyone using IE and not Windows Phone is on a desktop
        if (this.game.device.desktop || (this.game.device.ie && !this.game.device.windowsPhone)) {
            GameSettings.currentDevice = GameSettings.Devices.Desktop;
            GameSettings.maxGridScale = 0.94;
        }
        // The only tablet we can detect accurately is the iPad
        // Otherwise, look at the window size and if it's greater than 800, then consider it a tablet
        else if (this.game.device.iPad || Math.min(window.innerWidth, window.innerHeight) > 800) {
            GameSettings.currentDevice = GameSettings.Devices.Tablet;
            GameSettings.allowClueListToggling = true; // Allow players to manually switch between tablet/phone layouts
            GameSettings.Options.showClueLists = true; // But show clue lists by default
        }
        // We will assume everything else is a phone
        else {
            GameSettings.currentDevice = GameSettings.Devices.Phone;
            GameSettings.allowClueListToggling = true; // Allow players to manually switch between tablet/phone layouts
            GameSettings.Options.showClueLists = false; // But o not show clue lists by default
        }
    },

    determineCapability: function() {
        "use strict";
        if (!this.game.device.webGL || (this.game.renderer instanceof PIXI.CanvasRenderer)) {
            //TODO: add features here that we would like to turn off in low quality environments
        }
        // #fix: We need to manually cull list items if the device does not support masks
        // This specifically fixes Samsung Galaxy stock browsers, which report as Safari
        if (this.game.device.safari) {
            GameSettings.cullListItems = true;
        }
    },

    // endregion

    // region ========================= Fonts =========================
    loadBitmapFonts: function () {
        "use strict";
        this.numFontsToLoad = 2;
        this.loadBitmapFontFromSharedAtlas(GameSettings.gameAtlas, GameSettings.mediumFont+".png", GameSettings.mediumFont);
        this.loadBitmapFontFromSharedAtlas(GameSettings.gameAtlas, GameSettings.lightFont+".png", GameSettings.lightFont);
    },

    loadBitmapFontFromSharedAtlas: function(atlasName, textureFrameName, fontName) {
        "use strict";
        // Get the .fnt file
        var textureData = this.game.cache.getFrameByName(atlasName, textureFrameName);
        var fontXML = this.game.cache.getXML(fontName + ".fnt");

        // Get the first child node.
        // Unfortunately, we need to do this several different ways to support different browser APIs
        var firstChild;
        if (fontXML.children) { firstChild = fontXML.children[0]; }
        else if (fontXML.childNodes) { firstChild = fontXML.childNodes[0]; }
        else if (fontXML.firstElementChild) { firstChild = fontXML.firstElementChild; }

        // Add the texture offset to all characters
        var chars = firstChild.getElementsByTagName("chars");
        var currentNode = chars[0].firstElementChild;
        var info = firstChild.getElementsByTagName("info")[0];
        var padding = info.attributes.padding.value.split(",")[0];

        while (currentNode.nextElementSibling !== null) {
            currentNode.attributes.x.value = textureData.x + Math.ceil((parseInt(currentNode.attributes.x.value) - padding) * GameSettings.assetScale);
            currentNode.attributes.y.value = textureData.y + Math.ceil((parseInt(currentNode.attributes.y.value) - padding) * GameSettings.assetScale);
            currentNode.attributes.width.value = Math.ceil(parseInt(currentNode.attributes.width.value) * GameSettings.assetScale);
            currentNode.attributes.height.value = Math.ceil(parseInt(currentNode.attributes.height.value) * GameSettings.assetScale);
            currentNode.attributes.xoffset.value = Math.ceil(parseInt(currentNode.attributes.xoffset.value) * GameSettings.assetScale);
            currentNode.attributes.yoffset.value = Math.round(parseInt(currentNode.attributes.yoffset.value) * GameSettings.assetScale);
            currentNode.attributes.xadvance.value = Math.ceil(parseInt(currentNode.attributes.xadvance.value) * GameSettings.assetScale);
            currentNode = currentNode.nextElementSibling;
        }

        // Update the common elements as well
        var common = firstChild.getElementsByTagName("common")[0];
        common.attributes.base.value = Math.ceil(parseInt(common.attributes.base.value) * GameSettings.assetScale);
        common.attributes.lineHeight.value = Math.ceil(parseInt(common.attributes.lineHeight.value) * GameSettings.assetScale);
        common.attributes.scaleW.value = Math.ceil(parseInt(common.attributes.scaleW.value) * GameSettings.assetScale);
        common.attributes.scaleH.value = Math.ceil(parseInt(common.attributes.scaleH.value) * GameSettings.assetScale);

        // Convert the XML to a string to be passed into Phaser's loading function
        var fontXMLString = xmlserializer.serializeToString(fontXML);

        // Load the bitmap font with the updated .fnt file
        // We don't actually need to load the entire giant atlas, as we've already loaded it before. Plus we're going to override it anyways.
        // Instead, load a dummy atlas to speed up loading time. Must be the same size, but it's just a single color so it's compressed
        var loader = new Phaser.Loader(this.game);
        loader.bitmapFont(fontName, 'assets/images/'+GameSettings.assetScale+'x/dummyAtlas.jpg', null, fontXMLString);
        loader.onLoadComplete.addOnce(this.onCompleteLoadFont, {currentState:this, atlasName:GameSettings.gameAtlas, fontName:fontName});
        loader.start();
    },

    onCompleteLoadFont: function() {
        "use strict";
        // Override the cached font image with our giant atlas that includes the fonts
        var data = PIXI.BitmapText.fonts[this.fontName];
        var texture = PIXI.TextureCache[this.atlasName];
        var baseTexture = texture.baseTexture;
        for (var prop in data.chars) {
            if (data.chars.hasOwnProperty(prop)) {
                data.chars[prop].texture.baseTexture = baseTexture;
            }
        }

        // Clear the dummy atlas and XMLs from memory
        this.currentState.game.cache.removeImage(this.fontName);
        this.currentState.game.cache.removeXML(this.fontName+".fnt");

        // Check if all fonts have been loaded
        this.currentState.numFontsToLoad--;
        if (this.currentState.numFontsToLoad <= 0) {
            this.currentState.allPreloadingComplete = true;
        }

        // If all loading is done, then move onto the game
        if (this.currentState.preloadanimationComplete === true){
            this.currentState.finishedPreloadingAndPreloaderAnimation();
        }
    },
    // endregion
    finishedPreloadingAndPreloaderAnimation: function(){
        "use strict";
        this.game.state.start('Menu');
    },
    update: function () {
        "use strict";
    },

    // region ========================= Swiffy Animation =========================
    getSwiffyData: function () {
        "use strict";
        var data = "";
        /*
        // Removed sounds from the animation
        if (!WebUtils.isIOS() && !WebUtils.isAndroid()) {
            var browserName = WebUtils.getBrowserName();
            if ((navigator.userAgent.indexOf('Gecko') > -1 && navigator.userAgent.indexOf('KHTML') === -1 && browserName !== "msie")
                || (Object.prototype.toString.call(window.opera) === '[object Opera]')) {
                data = "data:audio/ogg;base64,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";
            }
            else {
                data = "data:audio/mpeg;base64,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\u003d\u003d";
            }
        }
        */

        return {
            "tags": [{"frames": [], "scenes": [{"name": "Scene 1", "offset": 0}], "type": 23}, {
                "id": 1,
                "data": data,
                "type": 11
            }, {"id": 1, "type": 12}, {"type": 2}, {"type": 2}, {
                "bounds": [{
                    "ymin": 0,
                    "ymax": 2000,
                    "xmin": 0,
                    "xmax": 2000
                }],
                "id": 2,
                "fillstyles": [{"color": [-2555900], "type": 1}],
                "paths": [{
                    "fill": 0,
                    "data": [":00j:b14D:07G93bb93B93b93B07gb:15d93b07gb93b93b07g93bb15d:08g93Bb92b92B92b07Gb:14D92B07Gb93B93B08G93Bc"]
                }],
                "flat": true,
                "type": 1
            }, {
                "tags": [{"id": 2, "matrix": 0, "type": 3, "depth": 1}, {"type": 2}],
                "id": 3,
                "frameCount": 1,
                "type": 7
            }, {
                "id": 3,
                "ratio": 2,
                "matrix": "1012E301y300Y1011E29L168f",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "3409E499z498Z3409E28L077e",
                "colortransform": "KiK:K:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "5650E7424b7424B5650E31J066d",
                "colortransform": "VqV:V:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "7733E8099b8097B7733E37G160c",
                "colortransform": "1Cy1C:1C:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "9814E8604b8604B9814E13D62w",
                "colortransform": "0D2c0D:0D:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "1598F8913b8912B1599F3H50p",
                "colortransform": "8D8c8D:8D:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "3354F9107b9105B3354F03c55j",
                "colortransform": "5E4d5E:5E:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "4882F9189b9189B4882F86g28f",
                "colortransform": "2F9d2F:2F:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "6176F9192b9191B6175F00m64c",
                "colortransform": "8F4e8F:8F:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "7327F9142b9142B7327F87q0w",
                "colortransform": "3G8e3G:3G:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "8341F9070b9070B8341F12v9r",
                "colortransform": "7G1f7G:7G:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "8093F9079b9079B8093F83z2w",
                "colortransform": "1H4f1H:1H:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "7843F9096b9096B7843F145c60d",
                "colortransform": "5H8f5H:5H:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "7588F9110b9110B7589F540c58h",
                "colortransform": "0I1g0I:0I:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "7330F9122b9122B7330F863c68m",
                "colortransform": "5I5g5I:5I:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "7068F9132b9132B7068F136d52s",
                "colortransform": "0J9g0J:0J:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "6704F9142b9143B6704F381d98y",
                "colortransform": "5J4h5J:5J:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "6432F9146b9147B6432F615d293c",
                "colortransform": "1K8h1K:1K:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "6059F9149b9150B6059F755d054d",
                "colortransform": "7K3i7K:7K:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "5682F9147b9148B5682F818d877d",
                "colortransform": "4L9i4L:4L:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "5396F9138b9139B5396F888d717e",
                "colortransform": "1M4j1M:1M:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "4959F9125b9126B4959F915d610f",
                "colortransform": "8M0k8M:8M:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "5752F060s1388D6008F138e179g",
                "colortransform": "6O5l6O:6O:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "8133H373r373R8135H236e140g",
                "colortransform": "2Q7m2Q:2Q:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "8562H745q746Q8562H441e415f",
                "colortransform": "5Q9m5Q:5Q:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "8941H232q231Q8942H631e776e",
                "colortransform": "7Q1n7Q:7Q:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "9246H799p799P9247H875e223e",
                "colortransform": "9Q3n9Q:9Q:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "9589H296p296P9590H233f818d",
                "colortransform": "1R5n1R:1R:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "9810H958o958O9810H604f514d",
                "colortransform": "3R7n3R:3R:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "0015I631o633O0017I958f301d",
                "colortransform": "5R8n5R:5R:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "0212I315o317O0212I291g188d",
                "colortransform": "6R9n6R:6R:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "0384I111o112O0385I582g157d",
                "colortransform": "7R0o7R:7R:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "1108I918m891M1059I961g268d",
                "colortransform": "8R1o8R:8R:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "1928I496l444L1819I334h546d",
                "colortransform": "9R2o9R:9R:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "2731I899j826J2550I669h940d",
                "colortransform": "0S2o0S:0S:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "3491I116i031I3230I996h388e",
                "colortransform": "2S3o2S:2S:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "4204I052g965F3850I229i958e",
                "colortransform": "3S5o3S:3S:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "4797I794d719D4343I335i662f",
                "colortransform": "5S6o5S:5S:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "5240I61w15W4678I472i394g",
                "colortransform": "7S7o7S:7S:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "6182J12f93B5090H626i743g",
                "colortransform": "7S8o7S:7S:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "6763I32o38O6891I634i413g",
                "colortransform": "0T9o0T:0T:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "6231I365c376C6336I741i877f",
                "colortransform": "1T0p1T:1T:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "5667I934d946D5750I857i384f",
                "colortransform": "2T1p2T:2T:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "5064I420f433F5128I013j952e",
                "colortransform": "3T2p3T:3T:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "4482I640g652G4529I233j607e",
                "colortransform": "4T3p4T:4T:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "3923I700h710H3955I507j372e",
                "colortransform": "5T4p5T:5T:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "3401I611i618I3421I790j243e",
                "colortransform": "6T5p6T:6T:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "2964I294j296J2972I043k184e",
                "colortransform": "7T6p7T:7T:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "2583I953j951J2584I256k158e",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "3008I758i755I3009I543k229e",
                "colortransform": "0U9p0U:0U:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "3450I430h424H3452I829k434e",
                "colortransform": "4U1q4U:4U:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "3862I952f941F3864I079l747e",
                "colortransform": "9U5q9U:9U:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "4221I320e211E4241I283l144f",
                "colortransform": "4V8q4V:4V:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "4516I441c327C4530I449l606f",
                "colortransform": "9V2r9V:9V:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "4696I11n92L4702I577l124g",
                "colortransform": "5W6r5W:5W:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "4729I55G77h4726I656l688g",
                "colortransform": "1X1s1X:1X:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "6635I03C80b5964H638l679g",
                "colortransform": "8X8s8X:8X:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {
                "replace": true,
                "matrix": "8537I:n7193G613l670g",
                "colortransform": "6Y4t6Y:6Y:::",
                "type": 3,
                "depth": 1
            }, {"type": 2}, {"type": 4, "depth": 1}, {
                "bounds": [{"ymin": 0, "ymax": 1861, "xmin": 0, "xmax": 5308}],
                "id": 4,
                "fillstyles": [{"color": [-2555900], "type": 1}],
                "paths": [{
                    "fill": 0,
                    "data": [":51t7ub24d:35i0ib97g1n72m97cb02f7z62e93dbT4k2U3sb3R6g90D8jb9Uw52Dwb62D:79I1Ib69G6M84L96Cb14E0Z74D93Db1d3W14f01Cb3sW08dWc:91E7Ub06C:80E3cb86C6d13F5ob4W2k3Z75bb9B3p3o48cb6q0r23e56cb35g72c33r65eb29g9l35m9lb06c:80e3Cb86c6D13f5Ob4w2K3z75Bb9b3P3O49Cb6Q9Q23E55Cb35G71C33R65Eb29G9L35M9Lc"]
                }],
                "flat": true,
                "type": 1
            }, {
                "tags": [{"id": 4, "matrix": 0, "type": 3, "depth": 1}, {"type": 2}],
                "id": 5,
                "frameCount": 1,
                "type": 7
            }, {"id": 5, "ratio": 60, "matrix": "4422E73O73o4422E605k476g", "type": 3, "depth": 7}, {
                "bounds": [{
                    "ymin": 0,
                    "ymax": 849,
                    "xmin": 0,
                    "xmax": 2043
                }],
                "id": 6,
                "fillstyles": [{"color": [-2555900], "type": 1}],
                "paths": [{
                    "fill": 0,
                    "data": [":78e:b5I:4Rjb23C7c83C8rb0F2o0t24cb1z3q92f4zb04c3f59e3fb2k:4uLb35c9C64c5Rb9b4N2X15Cb71B0Q80F7Zb91B0G40E0Gc"]
                }],
                "flat": true,
                "type": 1
            }, {
                "tags": [{"id": 6, "matrix": 0, "type": 3, "depth": 1}, {"type": 2}],
                "id": 7,
                "frameCount": 1,
                "type": 7
            }, {
                "id": 7,
                "ratio": 60,
                "matrix": "3407C630D630d3407C569k439g",
                "type": 3,
                "depth": 9
            }, {"type": 2}, {
                "replace": true,
                "matrix": "2465E41R41r2465E508k462g",
                "type": 3,
                "depth": 7
            }, {
                "replace": true,
                "matrix": "3476C958D174c394Y573k875f",
                "type": 3,
                "depth": 9
            }, {"type": 2}, {
                "replace": true,
                "matrix": "9382D78V78v9382D356k441g",
                "type": 3,
                "depth": 7
            }, {
                "replace": true,
                "matrix": "3545C361E41j173R583k366f",
                "type": 3,
                "depth": 9
            }, {"type": 2}, {
                "replace": true,
                "matrix": "5179D873B873b5179D147k412g",
                "type": 3,
                "depth": 7
            }, {
                "replace": true,
                "matrix": "3599C649E47N790K595k907e",
                "type": 3,
                "depth": 9
            }, {"type": 2}, {
                "replace": true,
                "matrix": "9854C629C629c9854C885j376g",
                "type": 3,
                "depth": 7
            }, {
                "replace": true,
                "matrix": "3654C928E420D264F611k502e",
                "type": 3,
                "depth": 9
            }, {"type": 2}, {
                "bounds": [{"ymin": 0, "ymax": 2924, "xmin": 0, "xmax": 7549}],
                "id": 8,
                "fillstyles": [{"color": [-2555900], "type": 1}],
                "paths": [{
                    "fill": 0,
                    "data": [":956b40cb05f:26m0nb32k9u43s21fb96c7s98e92cb4u6t0r84cb5C9q14C04cb5Z0l07G2qb94B4c27F4cb3P:36CHb44EZ80J0Mb94J2U16R21Fb42C4S11E91Cb6Q5T1N85Cb5c0R74b04Cb1w0L20f1Qb80b7C91e7Cc:27H40Cb45D:45H3eb55E3g85H5xb41C7q91C34db0E7y0t49eb2x82b30g57eb88d76b45k03eb81f5w47n83cb29j0t91r0tb44d:44h3Eb55e4G85h5Xb41c7Q91c34Db0e7Y1T49Eb2X82B29G57Eb88D76B45K03Eb80F5W47N84Cb29J9S90R9Sc"]
                }],
                "flat": true,
                "type": 1
            }, {
                "tags": [{"id": 8, "matrix": 0, "type": 3, "depth": 1}, {"type": 2}],
                "id": 9,
                "frameCount": 1,
                "type": 7
            }, {"id": 9, "ratio": 65, "matrix": "9359E74H74h9359E691k508g", "type": 3, "depth": 5}, {
                "replace": true,
                "matrix": "3407C630D630d3407C566j336g",
                "type": 3,
                "depth": 7
            }, {
                "replace": true,
                "matrix": "3708C198F322G55O627k147e",
                "type": 3,
                "depth": 9
            }, {"type": 2}, {
                "replace": true,
                "matrix": "9166D10W10w9166D952j391g",
                "type": 3,
                "depth": 5
            }, {"replace": true, "matrix": "3626C807E807e3626C550j555f", "type": 3, "depth": 7}, {
                "replace": true,
                "matrix": "3742C355F175J54w642k842d",
                "type": 3,
                "depth": 9
            }, {"type": 2}, {
                "replace": true,
                "matrix": "3407C630D630d3407C810i217g",
                "type": 3,
                "depth": 5
            }, {"replace": true, "matrix": "3856C907F907f3856C537j900e", "type": 3, "depth": 7}, {
                "replace": true,
                "matrix": "3774C503F612L542e656k589d",
                "type": 3,
                "depth": 9
            }, {"type": 2}, {
                "replace": true,
                "matrix": "3667C207E929d5378C815i506f",
                "type": 3,
                "depth": 5
            }, {"replace": true, "matrix": "4058C744G744g4058C529j361e", "type": 3, "depth": 7}, {
                "replace": true,
                "matrix": "3804C640F977N974g669k388d",
                "type": 3,
                "depth": 9
            }, {"type": 2}, {
                "bounds": [{"ymin": -5044, "ymax": 6340, "xmin": -3899, "xmax": 12304}],
                "id": 10,
                "fillstyles": [{"color": [-16711936], "type": 1}],
                "paths": [{
                    "fill": 0,
                    "data": [":823C044Ea6G652ja54t32ga30q109Db19c82c88m25fb24j2w87v4xb2fa3lab52l:14v4Wb33k74B36o06Ha72n79ta399c484Ha127P00Gc"]
                }],
                "flat": true,
                "type": 1
            }, {"clip": 4, "id": 10, "matrix": "3075C::3075C000j601f", "type": 3, "depth": 1}, {
                "bounds": [{
                    "ymin": 0,
                    "ymax": 3841,
                    "xmin": 0,
                    "xmax": 7495
                }],
                "id": 11,
                "fillstyles": [{"color": [-2555900], "type": 1}],
                "paths": [{
                    "fill": 0,
                    "data": [":::a:13wb1j0q1y39cbi2Nt3Xb6e37E8s08Hb0i4Q2r4Qb1e:3j5eb3n3o4t41fb1f88de25jaG8eb3z8n73e5zbh2U5d26Db3i34E04c20Hb6n8S89b8Sb5f:9l1db6t9l87b98eb0h69dM02jaN6gb49d7g21i7ibj6Hv6Ob2i40E48c31Ib7y90C28e03Dbi:r:b7y:79c61cb7l72c5c12ia2C0pb19c3D89e9Ja6d8Ob5p22E93c99Hb8v78C85c89Cbd:i:b1n:3n21cbb30c3N21hb29c1R63d98Ca35h65Ta::b74D69d35P79eb39C2c08G2cb56G:38P5Mb49L2S29V68Eb23J93C85L16Hc"]
                }],
                "flat": true,
                "type": 1
            }, {
                "tags": [{"id": 11, "matrix": 0, "type": 3, "depth": 1}, {"type": 2}],
                "id": 12,
                "frameCount": 1,
                "type": 7
            }, {"id": 12, "ratio": 69, "matrix": "3407C630D630d3407C943i706g", "type": 3, "depth": 2}, {
                "replace": true,
                "matrix": "3892C736E166e7040C820i907e",
                "type": 3,
                "depth": 5
            }, {"replace": true, "matrix": "4240C425H425h4240C523j943d", "type": 3, "depth": 7}, {
                "replace": true,
                "matrix": "3833C771F717P772i680k238d",
                "type": 3,
                "depth": 9
            }, {"type": 2}, {
                "replace": true,
                "matrix": "3493C091E091e3493C943i378g",
                "type": 3,
                "depth": 2
            }, {"replace": true, "matrix": "4075C137F295e8394C827i416e", "type": 3, "depth": 5}, {
                "replace": true,
                "matrix": "4390C954H954h4390C518j648d",
                "type": 3,
                "depth": 7
            }, {
                "replace": true,
                "matrix": "3843C919F924Q007k686k140d",
                "type": 3,
                "depth": 9
            }, {"type": 2}, {
                "replace": true,
                "matrix": "3568C530E530e3568C943i049g",
                "type": 3,
                "depth": 2
            }, {"replace": true, "matrix": "4236C515F428e9457C832i038e", "type": 3, "depth": 5}, {
                "replace": true,
                "matrix": "4474C228I228i4474C516j469d",
                "type": 3,
                "depth": 7
            }, {
                "replace": true,
                "matrix": "3861C912F801J520d639k287d",
                "type": 3,
                "depth": 9
            }, {"type": 2}, {
                "replace": true,
                "matrix": "3668C072F072f3668C942i725f",
                "type": 3,
                "depth": 2
            }, {"replace": true, "matrix": "4328C666F413e0197D836i759d", "type": 3, "depth": 5}, {
                "replace": true,
                "matrix": "4488C372I372i4488C514j410d",
                "type": 3,
                "depth": 7
            }, {
                "replace": true,
                "matrix": "3886C037G728D01Y601k441d",
                "type": 3,
                "depth": 9
            }, {"type": 2}, {
                "replace": true,
                "matrix": "3776C612F612f3776C941i403f",
                "type": 3,
                "depth": 2
            }, {"replace": true, "matrix": "4392C797F431e0647D840i596d", "type": 3, "depth": 5}, {
                "replace": true,
                "matrix": "4511C377I377i4511C514j591d",
                "type": 3,
                "depth": 7
            }, {"replace": true, "matrix": "3886C058GB998I570k595d", "type": 3, "depth": 9}, {"type": 2}, {
                "replace": true,
                "matrix": "3872C048G048g3872C941i073f",
                "type": 3,
                "depth": 2
            }, {"replace": true, "matrix": "4412C928F508e0794D839i547d", "type": 3, "depth": 5}, {
                "replace": true,
                "matrix": "4543C504I504i4543C514j777d",
                "type": 3,
                "depth": 7
            }, {
                "replace": true,
                "matrix": "3909C182G573c837Q545k753d",
                "type": 3,
                "depth": 9
            }, {"type": 2}, {
                "replace": true,
                "matrix": "3997C584G584g3997C941i751e",
                "type": 3,
                "depth": 2
            }, {"replace": true, "matrix": "4438C931F473e0983D840i724d", "type": 3, "depth": 5}, {
                "replace": true,
                "matrix": "4575C630I630i4575C513j962d",
                "type": 3,
                "depth": 7
            }, {
                "replace": true,
                "matrix": "3935C305G114f872Y528k914d",
                "type": 3,
                "depth": 9
            }, {"type": 2}, {
                "replace": true,
                "matrix": "4100C093H093h4100C941i426e",
                "type": 3,
                "depth": 2
            }, {"replace": true, "matrix": "4461C115G579e1169D839i913d", "type": 3, "depth": 5}, {
                "replace": true,
                "matrix": "4568C733I733i4568C511j147e",
                "type": 3,
                "depth": 7
            }, {"replace": true, "matrix": "3928C394G394g3928C519k074e", "type": 3, "depth": 9}, {"type": 2}, {
                "type": 4,
                "depth": 1
            }, {"type": 4, "depth": 2}, {"type": 4, "depth": 5}, {"type": 4, "depth": 7}, {
                "type": 4,
                "depth": 9
            }, {
                "bounds": [{"ymin": 641, "ymax": 6096, "xmin": 343, "xmax": 7878}],
                "id": 13,
                "fillstyles": [{"color": [-2547930], "type": 1}],
                "paths": [{
                    "fill": 0,
                    "data": [":420c63ib76e:57l1la8r5cb52j4t71q62eb70g84c18g23gb1C2t93B35cbL81B67F82Eb25G34C10R95Db70F1J35L1Jb52C:63F9cb86E4g81G5yb7L3P3J23Cb7e80C94h15Eb39c4E24g4Ec:96d10hb15d:07i1gb08h6k48m51cb42e7w02e55db0D8u40F91ba48D9ba0KEb6r2E0u6Ob8b8M9X08Cb86B6Q04G1Zb0Y1E68D1Eb6N:78Bwb22C4e51C3tb8B0o4x11ca7g2db78C3I76F2Vb40E7W02E55Db0d8U39f89Bb4w9B99d9Bc:49L32Kb64E:57J0hb62K0s47L11gb1D2y1r11eb6w76b72g60eb40j50e94y06hb93h7n55p7nb66e:61j1Hb58k7R44l11Gb7h21E53I71Jb52H51D53T04Gb2Z5E41E1Jb93H7N56P7Nc:25W47qa9f95vb9j9p0z30cal2Xb8c28E3q08Hb7h8Q0r8Qb9d:0j0eb4n7n2v30fb4g86d6c19jaE7eb3z8m76e7xbe6U1c25Db8g40E79b24Hb1n5T84b5Tb3f:6l9cb9t9k03c83eb3i50dq95iaL6gb57d6f17i9fbj9Js7Ob6g42E18c36Ib4x93C11e14DboA0cAb8x:75c47cb8m62c2f05ibG6fZ1pb08c2E80e6Lbq3H3d9Ob5n23E63c05Ib5u81C69c00Dbd:h:b0n:3o15cbl37c8K20hb20c5R50d08Da65g77Ta::b59D80d06P23fb53D8e67I8eb37F:67M9Hb67L7O29V93Db26J58C01M72Gc"]
                }],
                "flat": true,
                "type": 1
            }, {
                "tags": [{"id": 13, "matrix": 0, "type": 3, "depth": 2}, {"type": 2}],
                "id": 14,
                "frameCount": 1,
                "type": 7
            }, {
                "id": 14,
                "ratio": 77,
                "matrix": "3652C090F352e7521C667i407d",
                "type": 3,
                "depth": 15
            }, {"type": 2}, {
                "replace": true,
                "matrix": "3459C827D217d7512C710i251d",
                "type": 3,
                "depth": 15
            }, {"type": 2}, {
                "replace": true,
                "matrix": "3364C123D590c7526C734i161d",
                "type": 3,
                "depth": 15
            }, {"type": 2}, {
                "replace": true,
                "matrix": "3333C971C453c7530C738i137d",
                "type": 3,
                "depth": 15
            }, {"type": 2}, {
                "replace": true,
                "matrix": "3078C442C937b7832C744i235d",
                "type": 3,
                "depth": 15
            }, {"type": 2}, {
                "replace": true,
                "matrix": "2342C61T61p8772C750i545d",
                "type": 3,
                "depth": 15
            }, {"type": 2}, {
                "replace": true,
                "matrix": "1250C9q9L0461D750i070e",
                "type": 3,
                "depth": 15
            }, {"type": 2}, {
                "replace": true,
                "matrix": "0031C891c65X3038D762i781e",
                "type": 3,
                "depth": 15
            }, {"type": 2}, {
                "replace": true,
                "matrix": "2277C80h93G5546C834i274e",
                "type": 3,
                "depth": 15
            }, {"type": 2}, {
                "replace": true,
                "matrix": "3075C::3075C849i100e",
                "type": 3,
                "depth": 15
            }, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {
                "bounds": [{
                    "ymin": 0,
                    "ymax": 9122,
                    "xmin": -280,
                    "xmax": 22006
                }],
                "id": 15,
                "fillstyles": [{"color": [1381515842], "type": 1}],
                "paths": [{"fill": 0, "data": [":041c:a321C122ia286v:a:122Ic"]}],
                "flat": true,
                "type": 1
            }, {
                "tags": [{"id": 15, "matrix": 0, "type": 3, "depth": 1}, {"type": 2}],
                "id": 16,
                "frameCount": 1,
                "type": 7
            }, {
                "clip": 13,
                "id": 16,
                "ratio": 94,
                "matrix": "136S::136S626l432c",
                "type": 3,
                "depth": 1
            }, {
                "bounds": [{"ymin": 332, "ymax": 3081, "xmin": 264, "xmax": 15268}],
                "id": 17,
                "fillstyles": [{"color": [-16777216], "type": 1}],
                "paths": [{
                    "fill": 0,
                    "data": [":099j68cb4L:6V7ib6I3j6I4vb:3m6i9vb2i2i6v2ib0n:6v2Ib3i6H3i9Vb:1M3I4Vb3I7I6V7Ic:517H09ia9z95fa45E:a76b95Fc:044e62db7o:2z9jageb0k5j2k9ya:vbB5n2K4yaGcb5J2k2Z2kb7J:0S0Eb4CQ9G2Fa:Cb6K9J6K8Zb:5O6k72Bb4c3C9g9Eb3h0E0s0Ec:07t:b7o:6z9jaceb4j2j1k9ya:vbG0o1K4yaCcb9J2k6Z2kb0P:9Z2Ka:Cb2K7J2K8Zb:5O2k72Bb4k9J9z9Jc:301G93Ma68J728ba11f:a2u31Ea90i:a0u31ea11f:a71J728Bc:58u00hb14D:53F1lb1R2J28D4Ka:26sa69e:a:17Kb:2J8g9Ob1o6H02d6Hbs:8c:aq:a:71EaI:bG:N:c:1p12Ha:745ba71e:a:14Fa76d14fa26g:a54G69Ia35g47IacCa24G:a62D98ea:12La71E2Uc:861b26ha:1hb8R8G81C8Gb0J:0Ssb88B7e86D4za0I8iaV3cb1Q5x1Q43eb:7ix4tb8c6r7n45cb0f6g2k6la:cb7o7o64c1wa5fpa7eoa0jla1ggas:a6hGa9o7Bb9l1C8x2Jb4v7k64d1ma:14Sc:06t28Ha76E0ua:99fb8Q8G80C8Gb96C:76F83bb81B74b81B74fb:02d81b75fabcb4p2p64c1wa2fpa7o7ba2ggas:a0iGa7o7Bb3n5C0x2Jb1r2j69d6ma:747Bc:6v26ha:21sa72e:a:21Sb9L1h88B1hb0O:84B1Hc:64g:a:83jb:47c6x93eb9o9o57c1ua5m7ba1hga3d:a4gGa0n7Bb9k2D1r6Gb2t0j14d0ka:21Sa71E:a:90jb:5j4G9qaDbb7G8g4R8gb2K:0S8Ga:Bb9G4G9G6Ra:83Jc:285c:b17C:55E9tb3W4T50E4Tb0W:16D9jb2P8G21D7Ja:16sa71e:a:90Jbe5J8g9QacBb8g8G5r8Gb5j:8r8gb9g2g9g1ra:90ja71e:a:00Kb:9I9g8Qa:eb1g9G8r9Gb2k:5r4gaeeb4g1g4g3ra:88ja71e:a:88Jb:45C3X88EaD:a:Bb6W3X88E3Xc"]
                }],
                "flat": true,
                "type": 1
            }, {
                "tags": [{"id": 17, "matrix": 0, "type": 3, "depth": 9}, {"type": 2}],
                "id": 18,
                "frameCount": 1,
                "type": 7
            }, {
                "id": 18,
                "ratio": 94,
                "matrix": "3075C::3075C119e143f",
                "type": 3,
                "depth": 3
            }, {"type": 2}, {"replace": true, "matrix": "136S::136S780k432c", "type": 3, "depth": 1}, {
                "replace": true,
                "matrix": "3075C::3075C132f143f",
                "type": 3,
                "depth": 3
            }, {"replace": true, "matrix": "3075C::3075C991h100e", "type": 3, "depth": 15}, {"type": 2}, {
                "replace": true,
                "matrix": "136S::136S916j432c",
                "type": 3,
                "depth": 1
            }, {"replace": true, "matrix": "3075C::3075C166g143f", "type": 3, "depth": 3}, {
                "replace": true,
                "matrix": "3075C::3075C114h100e",
                "type": 3,
                "depth": 15
            }, {"type": 2}, {"replace": true, "matrix": "136S::136S369j432c", "type": 3, "depth": 1}, {
                "replace": true,
                "matrix": "3075C::3075C821g143f",
                "type": 3,
                "depth": 3
            }, {"replace": true, "matrix": "3075C::3075C559g100e", "type": 3, "depth": 15}, {"type": 2}, {
                "replace": true,
                "matrix": "136S::136S978i432c",
                "type": 3,
                "depth": 1
            }, {"replace": true, "matrix": "3075C::3075C289h143f", "type": 3, "depth": 3}, {
                "replace": true,
                "matrix": "3075C::3075C163g100e",
                "type": 3,
                "depth": 15
            }, {"type": 2}, {"replace": true, "matrix": "136S::136S682i432c", "type": 3, "depth": 1}, {
                "replace": true,
                "matrix": "3075C::3075C643h143f",
                "type": 3,
                "depth": 3
            }, {"replace": true, "matrix": "3075C::3075C863f100e", "type": 3, "depth": 15}, {"type": 2}, {
                "replace": true,
                "matrix": "136S::136S452i432c",
                "type": 3,
                "depth": 1
            }, {"replace": true, "matrix": "3075C::3075C919h143f", "type": 3, "depth": 3}, {
                "replace": true,
                "matrix": "3075C::3075C629f100e",
                "type": 3,
                "depth": 15
            }, {"type": 2}, {"replace": true, "matrix": "136S::136S269i432c", "type": 3, "depth": 1}, {
                "replace": true,
                "matrix": "3075C::3075C138i143f",
                "type": 3,
                "depth": 3
            }, {"replace": true, "matrix": "3075C::3075C444f100e", "type": 3, "depth": 15}, {"type": 2}, {
                "replace": true,
                "matrix": "136S::136S124i432c",
                "type": 3,
                "depth": 1
            }, {"replace": true, "matrix": "3075C::3075C311i143f", "type": 3, "depth": 3}, {
                "replace": true,
                "matrix": "3075C::3075C297f100e",
                "type": 3,
                "depth": 15
            }, {"type": 2}, {"replace": true, "matrix": "136S::136S010i432c", "type": 3, "depth": 1}, {
                "replace": true,
                "matrix": "3075C::3075C448i143f",
                "type": 3,
                "depth": 3
            }, {"replace": true, "matrix": "3075C::3075C181f100e", "type": 3, "depth": 15}, {"type": 2}, {
                "replace": true,
                "matrix": "136S::136S921h432c",
                "type": 3,
                "depth": 1
            }, {"replace": true, "matrix": "3075C::3075C555i143f", "type": 3, "depth": 3}, {
                "replace": true,
                "matrix": "3075C::3075C090f100e",
                "type": 3,
                "depth": 15
            }, {"type": 2}, {"replace": true, "matrix": "136S::136S853h432c", "type": 3, "depth": 1}, {
                "replace": true,
                "matrix": "3075C::3075C636i143f",
                "type": 3,
                "depth": 3
            }, {"replace": true, "matrix": "3075C::3075C022f100e", "type": 3, "depth": 15}, {"type": 2}, {
                "replace": true,
                "matrix": "136S::136S804h432c",
                "type": 3,
                "depth": 1
            }, {"replace": true, "matrix": "3075C::3075C695i143f", "type": 3, "depth": 3}, {
                "replace": true,
                "matrix": "3075C::3075C972e100e",
                "type": 3,
                "depth": 15
            }, {"type": 2}, {"replace": true, "matrix": "136S::136S771h432c", "type": 3, "depth": 1}, {
                "replace": true,
                "matrix": "3075C::3075C734i143f",
                "type": 3,
                "depth": 3
            }, {"replace": true, "matrix": "3075C::3075C938e100e", "type": 3, "depth": 15}, {"type": 2}, {
                "replace": true,
                "matrix": "136S::136S752h432c",
                "type": 3,
                "depth": 1
            }, {"replace": true, "matrix": "3075C::3075C757i143f", "type": 3, "depth": 3}, {
                "replace": true,
                "matrix": "3075C::3075C919e100e",
                "type": 3,
                "depth": 15
            }, {"type": 2}, {"replace": true, "matrix": "136S::136S746h432c", "type": 3, "depth": 1}, {
                "replace": true,
                "matrix": "3075C::3075C764i143f",
                "type": 3,
                "depth": 3
            }, {
                "replace": true,
                "matrix": "3075C::3075C912e100e",
                "type": 3,
                "depth": 15
            }, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {"type": 2}, {
                "id": 1,
                "type": 12
            }, {"type": 2}],
            "fileSize": 16915,
            "v": "5.0.0",
            "frameSize": {"ymin": 0, "ymax": 14000, "xmin": 0, "xmax": 24000},
            "frameCount": 262,
            "frameRate": 30,
            "code": "",
            "version": 11
        };
    }
    // endregion
};
},{"../GameSettings":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\GameSettings.js","XML":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\XML\\lib\\xml.js","xmlserializer":"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\node_modules\\xmlserializer\\lib\\serializer.js"}],"e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\utils\\utils.js":[function(require,module,exports){
var Utils = {
    containsObject: function(obj, list) {
        "use strict";
        var i;
        for (i = 0; i < list.length; i++) {
            if (list[i] === obj) {
                return true;
            }
        }
        return false;
    },

    constrain: function(min, value, max) {
        "use strict";
        return Math.max(min, Math.min(value, max));
    },

    cloneObject: function(obj) {
        "use strict";
        if (obj === null || typeof(obj) !== "object") {
            return obj;
        }

        var temp = obj.constructor(); // changed
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                temp[key] = this.cloneObject(obj[key]);
            }
        }
        return temp;
    },

    convertMStoTime: function(ms) {
        "use strict";
        var mins = Math.floor(ms / 60000);
        var secs = Math.floor(ms / 1000) % 60;
        var secString = (secs > 9) ? ("" + secs) : ("0" + secs);
        return mins + ":" + secString;
    },

    countNumDigits: function(n) {
        "use strict";
        var numDigits = 0;
        while (n>=1) {
            n /= 10;
            ++numDigits;
        }
        return numDigits;
    },

    doesFileExist: function(urlToFile)
    {
        "use strict";
        var xhr = new XMLHttpRequest();
        xhr.open('HEAD', urlToFile, false);
        xhr.send();
        if (xhr.status == "404") {//this needs to be a ==
            return false;
        } else {
            return true;
        }
    }
};

module.exports = Utils;
},{}]},{},["e:\\work\\JS\\modules\\html5-module-panelmanager\\sample\\src\\js\\main.js"])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvWE1ML2xpYi94bWwuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbGliL2JvbS5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9saWIvcHJvY2Vzc29ycy5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9saWIveG1sMmpzLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy9zYXgvbGliL3NheC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MQXR0cmlidXRlLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxCdWlsZGVyLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxDRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MQ29tbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MRFREQXR0TGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MRFRERWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MRFRERW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxEVEROb3RhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MRGVjbGFyYXRpb24uanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTERvY1R5cGUuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTEVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTE5vZGUuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbGliL1hNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MUmF3LmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL2xpYi9YTUxTdHJpbmdpZmllci5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvWE1MVGV4dC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fRGF0YVZpZXcuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19MaXN0Q2FjaGUuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0LmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldENhY2hlLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19VaW50OEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1dlYWtNYXAuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlFdmVyeS5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVNvbWUuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduVmFsdWUuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ24uanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRXZlcnkuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZvci5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRm9yT3duLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXQuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSGFzSW4uanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWwuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hdGNoLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJdGVyYXRlZS5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlcy5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHlEZWVwLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9QYWlycy5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFBhdGguanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2hlY2tHbG9iYWwuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVBc3NpZ25lci5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZVRvUGFpcnMuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxBcnJheXMuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxCeVRhZy5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbE9iamVjdHMuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWF0Y2hEYXRhLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc1BhdGguanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hTZXQuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5kZXhLZXlzLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSG9zdE9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5LmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVHZXQuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUFkZC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvUGFpcnMuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tDbGVhci5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0dldC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0hhcy5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb1BhdGguanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9jb25zdGFudC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL2VxLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXZlcnkuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9nZXQuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNFbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL21lbW9pemUuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL3Jlc3QuanMiLCJub2RlX21vZHVsZXMvWE1ML25vZGVfbW9kdWxlcy94bWwyanMvbm9kZV9tb2R1bGVzL3htbGJ1aWxkZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC90b0Zpbml0ZS5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL3RvSW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL3RvTnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL1hNTC9ub2RlX21vZHVsZXMveG1sMmpzL25vZGVfbW9kdWxlcy94bWxidWlsZGVyL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9QYWlycy5qcyIsIm5vZGVfbW9kdWxlcy9YTUwvbm9kZV9tb2R1bGVzL3htbDJqcy9ub2RlX21vZHVsZXMveG1sYnVpbGRlci9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2Fya2FkaXVtLXBhbmVsbWFuYWdlci10ZXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Fya2FkaXVtLXBhbmVsbWFuYWdlci10ZXN0L3NyYy9QYW5lbC5qcyIsIm5vZGVfbW9kdWxlcy9hcmthZGl1bS1wYW5lbG1hbmFnZXItdGVzdC9zcmMvUGFuZWxNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2Fya2FkaXVtLXBhbmVsbWFuYWdlci10ZXN0L3NyYy90cmFuc2l0aW9uL0Jhc2VUcmFuc2l0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2Fya2FkaXVtLXBhbmVsbWFuYWdlci10ZXN0L3NyYy90cmFuc2l0aW9uL2hpZGUvSGlkZVRyYW5zaXRpb25Nb3ZlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9hcmthZGl1bS1wYW5lbG1hbmFnZXItdGVzdC9zcmMvdHJhbnNpdGlvbi9zaG93L1Nob3dUcmFuc2l0aW9uQWxwaGEuanMiLCJub2RlX21vZHVsZXMvYXJrYWRpdW0tcGFuZWxtYW5hZ2VyLXRlc3Qvc3JjL3RyYW5zaXRpb24vc2hvdy9TaG93VHJhbnNpdGlvbkFscGhhQW5kTW92ZW1lbnQuanMiLCJub2RlX21vZHVsZXMvYXJrYWRpdW0tcGFuZWxtYW5hZ2VyLXRlc3Qvc3JjL3RyYW5zaXRpb24vc2hvdy9TaG93VHJhbnNpdGlvbk1vdmVtZW50LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9idWZmZXItc2hpbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwibm9kZV9tb2R1bGVzL3htbHNlcmlhbGl6ZXIvbGliL3NlcmlhbGl6ZXIuanMiLCJzcmMvanMvR2FtZVNldHRpbmdzLmpzIiwic3JjL2pzL1BsdWdpbnMvRlBTTWV0ZXIuanMiLCJzcmMvanMvUGx1Z2lucy9TYXZlQ1BVLmpzIiwic3JjL2pzL1BsdWdpbnMvU3RhdHMuanMiLCJzcmMvanMvbWFpbi5qcyIsInNyYy9qcy9wYW5lbC9TYW1wbGVQYW5lbC5qcyIsInNyYy9qcy9zdGF0ZXMvYm9vdC5qcyIsInNyYy9qcy9zdGF0ZXMvbWVudS5qcyIsInNyYy9qcy9zdGF0ZXMvcHJlbG9hZGVyLmpzIiwic3JjL2pzL3V0aWxzL3V0aWxzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hpREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvcURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzUzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuRUE7QUFDQTs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hCQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgeG1sMmpzID0gcmVxdWlyZSgneG1sMmpzJylcclxuXHJcbmZ1bmN0aW9uIHhtbCgpIHtcclxuXHJcbiAgICB0aGlzLnBhcnNlID0gZnVuY3Rpb24odmFsdWUsIHN0cmlwUm9vdHMpIHtcclxuICAgICAgICBzdHJpcFJvb3RzID0gc3RyaXBSb290cyB8fCBmYWxzZVxyXG4gICAgICAgIHZhciBwYXJzZXIgPSBuZXcgeG1sMmpzLlBhcnNlcih7ZXhwbGljaXRSb290OiAhc3RyaXBSb290cywgZXhwbGljaXRBcnJheTogZmFsc2V9KTtcclxuICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xyXG4gICAgICAgIHBhcnNlci5wYXJzZVN0cmluZyh2YWx1ZSxmdW5jdGlvbihlcnIscil7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSByO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIChzdHJpcFJvb3RzKSA/IF9zdHJpcFhtbEJsb2F0KHJlc3VsdHMpIDogcmVzdWx0cztcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5zdHJpbmdpZnkgPSBmdW5jdGlvbih2YWx1ZSwgcm9vdCwgY2hpbGQpIHtcclxuICAgICAgICB2YXIgd3JpdGVyID0gbmV3IHhtbDJqcy5CdWlsZGVyKHtleHBsaWNpdFJvb3Q6IGZhbHNlfSk7XHJcbiAgICAgICAgdmFsdWUgPSByb290ICYmIF9hZGR4bWxCbG9hdCh2YWx1ZSwgcm9vdCwgY2hpbGQpIHx8IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiB3cml0ZXIuYnVpbGRPYmplY3QodmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmNoaWxkID0gZnVuY3Rpb24ocm9vdCkge1xyXG4gICAgICAgIHJldHVybiBfc2luZ3VsYXIocm9vdCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfc3RyaXBYbWxCbG9hdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblxyXG4gICAgICAgIHZhciBjbnQgPSAwO1xyXG4gICAgICAgIHZhciByb290ID0gbnVsbDtcclxuICAgICAgICB2YXIgaXNWYWwgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiB2YWx1ZSkge1xyXG4gICAgICAgICAgICByb290ID0gcDtcclxuICAgICAgICAgICAgaXNWYWwgPSAhKHR5cGVvZiB2YWx1ZVtwXSA9PSBcIm9iamVjdFwiKSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZVtwXSk7XHJcbiAgICAgICAgICAgIGNudCsrXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocm9vdCAmJiBjbnQgPT0xICYmICFpc1ZhbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkodmFsdWVbcF0pKSA/IHZhbHVlW3Jvb3RdIDogW3ZhbHVlW3Jvb3RdXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgX2FkZHhtbEJsb2F0ID0gZnVuY3Rpb24odmFsdWUsIHJvb3QsIGNoaWxkKSB7XHJcbiAgICAgICAgaWYgKHJvb3QpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG5cclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVjb3JkcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZCB8fCBfc2luZ3VsYXIocm9vdCk7XHJcbiAgICAgICAgICAgICAgICByZWNvcmRzW2NoaWxkXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jvb3RdID0gcmVjb3JkcztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtyb290XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgX3Npbmd1bGFyID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUgIT0gXCJcIikge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUuc2xpY2UoLTEpID09IFwic1wiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMCwtMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSArIFwiUmVjb3JkXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuXHJcbn1cclxuXHJcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IG5ldyB4bWwoKTtcclxuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEwLjBcbihmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciB4bWwyanM7XG5cbiAgeG1sMmpzID0gcmVxdWlyZSgnLi4vbGliL3htbDJqcycpO1xuXG4gIGV4cG9ydHMuc3RyaXBCT00gPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoc3RyWzBdID09PSAnXFx1RkVGRicpIHtcbiAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMC4wXG4oZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgcHJlZml4TWF0Y2g7XG5cbiAgcHJlZml4TWF0Y2ggPSBuZXcgUmVnRXhwKC8oPyF4bWxucyleLio6Lyk7XG5cbiAgZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG4gIH07XG5cbiAgZXhwb3J0cy5maXJzdENoYXJMb3dlckNhc2UgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuICB9O1xuXG4gIGV4cG9ydHMuc3RyaXBQcmVmaXggPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UocHJlZml4TWF0Y2gsICcnKTtcbiAgfTtcblxuICBleHBvcnRzLnBhcnNlTnVtYmVycyA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghaXNOYU4oc3RyKSkge1xuICAgICAgc3RyID0gc3RyICUgMSA9PT0gMCA/IHBhcnNlSW50KHN0ciwgMTApIDogcGFyc2VGbG9hdChzdHIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIGV4cG9ydHMucGFyc2VCb29sZWFucyA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICgvXig/OnRydWV8ZmFsc2UpJC9pLnRlc3Qoc3RyKSkge1xuICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS4xMC4wXG4oZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgYm9tLCBidWlsZGVyLCBlc2NhcGVDREFUQSwgZXZlbnRzLCBpc0VtcHR5LCBwcm9jZXNzTmFtZSwgcHJvY2Vzc29ycywgcmVxdWlyZXNDREFUQSwgc2F4LCBzZXRJbW1lZGlhdGUsIHdyYXBDREFUQSxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIGJpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9O1xuXG4gIHNheCA9IHJlcXVpcmUoJ3NheCcpO1xuXG4gIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuXG4gIGJ1aWxkZXIgPSByZXF1aXJlKCd4bWxidWlsZGVyJyk7XG5cbiAgYm9tID0gcmVxdWlyZSgnLi9ib20nKTtcblxuICBwcm9jZXNzb3JzID0gcmVxdWlyZSgnLi9wcm9jZXNzb3JzJyk7XG5cbiAgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgndGltZXJzJykuc2V0SW1tZWRpYXRlO1xuXG4gIGlzRW1wdHkgPSBmdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09IFwib2JqZWN0XCIgJiYgKHRoaW5nICE9IG51bGwpICYmIE9iamVjdC5rZXlzKHRoaW5nKS5sZW5ndGggPT09IDA7XG4gIH07XG5cbiAgcHJvY2Vzc05hbWUgPSBmdW5jdGlvbihwcm9jZXNzb3JzLCBwcm9jZXNzZWROYW1lKSB7XG4gICAgdmFyIGksIGxlbiwgcHJvY2VzcztcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBwcm9jZXNzb3JzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBwcm9jZXNzID0gcHJvY2Vzc29yc1tpXTtcbiAgICAgIHByb2Nlc3NlZE5hbWUgPSBwcm9jZXNzKHByb2Nlc3NlZE5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzc2VkTmFtZTtcbiAgfTtcblxuICByZXF1aXJlc0NEQVRBID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuaW5kZXhPZignJicpID49IDAgfHwgZW50cnkuaW5kZXhPZignPicpID49IDAgfHwgZW50cnkuaW5kZXhPZignPCcpID49IDA7XG4gIH07XG5cbiAgd3JhcENEQVRBID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgICByZXR1cm4gXCI8IVtDREFUQVtcIiArIChlc2NhcGVDREFUQShlbnRyeSkpICsgXCJdXT5cIjtcbiAgfTtcblxuICBlc2NhcGVDREFUQSA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LnJlcGxhY2UoJ11dPicsICddXV1dPjwhW0NEQVRBWz4nKTtcbiAgfTtcblxuICBleHBvcnRzLnByb2Nlc3NvcnMgPSBwcm9jZXNzb3JzO1xuXG4gIGV4cG9ydHMuZGVmYXVsdHMgPSB7XG4gICAgXCIwLjFcIjoge1xuICAgICAgZXhwbGljaXRDaGFya2V5OiBmYWxzZSxcbiAgICAgIHRyaW06IHRydWUsXG4gICAgICBub3JtYWxpemU6IHRydWUsXG4gICAgICBub3JtYWxpemVUYWdzOiBmYWxzZSxcbiAgICAgIGF0dHJrZXk6IFwiQFwiLFxuICAgICAgY2hhcmtleTogXCIjXCIsXG4gICAgICBleHBsaWNpdEFycmF5OiBmYWxzZSxcbiAgICAgIGlnbm9yZUF0dHJzOiBmYWxzZSxcbiAgICAgIG1lcmdlQXR0cnM6IGZhbHNlLFxuICAgICAgZXhwbGljaXRSb290OiBmYWxzZSxcbiAgICAgIHZhbGlkYXRvcjogbnVsbCxcbiAgICAgIHhtbG5zOiBmYWxzZSxcbiAgICAgIGV4cGxpY2l0Q2hpbGRyZW46IGZhbHNlLFxuICAgICAgY2hpbGRrZXk6ICdAQCcsXG4gICAgICBjaGFyc0FzQ2hpbGRyZW46IGZhbHNlLFxuICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgYXR0ck5hbWVQcm9jZXNzb3JzOiBudWxsLFxuICAgICAgYXR0clZhbHVlUHJvY2Vzc29yczogbnVsbCxcbiAgICAgIHRhZ05hbWVQcm9jZXNzb3JzOiBudWxsLFxuICAgICAgdmFsdWVQcm9jZXNzb3JzOiBudWxsLFxuICAgICAgZW1wdHlUYWc6ICcnXG4gICAgfSxcbiAgICBcIjAuMlwiOiB7XG4gICAgICBleHBsaWNpdENoYXJrZXk6IGZhbHNlLFxuICAgICAgdHJpbTogZmFsc2UsXG4gICAgICBub3JtYWxpemU6IGZhbHNlLFxuICAgICAgbm9ybWFsaXplVGFnczogZmFsc2UsXG4gICAgICBhdHRya2V5OiBcIiRcIixcbiAgICAgIGNoYXJrZXk6IFwiX1wiLFxuICAgICAgZXhwbGljaXRBcnJheTogdHJ1ZSxcbiAgICAgIGlnbm9yZUF0dHJzOiBmYWxzZSxcbiAgICAgIG1lcmdlQXR0cnM6IGZhbHNlLFxuICAgICAgZXhwbGljaXRSb290OiB0cnVlLFxuICAgICAgdmFsaWRhdG9yOiBudWxsLFxuICAgICAgeG1sbnM6IGZhbHNlLFxuICAgICAgZXhwbGljaXRDaGlsZHJlbjogZmFsc2UsXG4gICAgICBwcmVzZXJ2ZUNoaWxkcmVuT3JkZXI6IGZhbHNlLFxuICAgICAgY2hpbGRrZXk6ICckJCcsXG4gICAgICBjaGFyc0FzQ2hpbGRyZW46IGZhbHNlLFxuICAgICAgYXN5bmM6IGZhbHNlLFxuICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgYXR0ck5hbWVQcm9jZXNzb3JzOiBudWxsLFxuICAgICAgYXR0clZhbHVlUHJvY2Vzc29yczogbnVsbCxcbiAgICAgIHRhZ05hbWVQcm9jZXNzb3JzOiBudWxsLFxuICAgICAgdmFsdWVQcm9jZXNzb3JzOiBudWxsLFxuICAgICAgcm9vdE5hbWU6ICdyb290JyxcbiAgICAgIHhtbGRlYzoge1xuICAgICAgICAndmVyc2lvbic6ICcxLjAnLFxuICAgICAgICAnZW5jb2RpbmcnOiAnVVRGLTgnLFxuICAgICAgICAnc3RhbmRhbG9uZSc6IHRydWVcbiAgICAgIH0sXG4gICAgICBkb2N0eXBlOiBudWxsLFxuICAgICAgcmVuZGVyT3B0czoge1xuICAgICAgICAncHJldHR5JzogdHJ1ZSxcbiAgICAgICAgJ2luZGVudCc6ICcgICcsXG4gICAgICAgICduZXdsaW5lJzogJ1xcbidcbiAgICAgIH0sXG4gICAgICBoZWFkbGVzczogZmFsc2UsXG4gICAgICBjaHVua1NpemU6IDEwMDAwLFxuICAgICAgZW1wdHlUYWc6ICcnLFxuICAgICAgY2RhdGE6IGZhbHNlXG4gICAgfVxuICB9O1xuXG4gIGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoVmFsaWRhdGlvbkVycm9yLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFZhbGlkYXRpb25FcnJvcihtZXNzYWdlKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cblxuICAgIHJldHVybiBWYWxpZGF0aW9uRXJyb3I7XG5cbiAgfSkoRXJyb3IpO1xuXG4gIGV4cG9ydHMuQnVpbGRlciA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBCdWlsZGVyKG9wdHMpIHtcbiAgICAgIHZhciBrZXksIHJlZiwgdmFsdWU7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIHJlZiA9IGV4cG9ydHMuZGVmYXVsdHNbXCIwLjJcIl07XG4gICAgICBmb3IgKGtleSBpbiByZWYpIHtcbiAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwocmVmLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgdmFsdWUgPSByZWZba2V5XTtcbiAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoa2V5IGluIG9wdHMpIHtcbiAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwob3B0cywga2V5KSkgY29udGludWU7XG4gICAgICAgIHZhbHVlID0gb3B0c1trZXldO1xuICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIEJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkT2JqZWN0ID0gZnVuY3Rpb24ocm9vdE9iaikge1xuICAgICAgdmFyIGF0dHJrZXksIGNoYXJrZXksIHJlbmRlciwgcm9vdEVsZW1lbnQsIHJvb3ROYW1lO1xuICAgICAgYXR0cmtleSA9IHRoaXMub3B0aW9ucy5hdHRya2V5O1xuICAgICAgY2hhcmtleSA9IHRoaXMub3B0aW9ucy5jaGFya2V5O1xuICAgICAgaWYgKChPYmplY3Qua2V5cyhyb290T2JqKS5sZW5ndGggPT09IDEpICYmICh0aGlzLm9wdGlvbnMucm9vdE5hbWUgPT09IGV4cG9ydHMuZGVmYXVsdHNbJzAuMiddLnJvb3ROYW1lKSkge1xuICAgICAgICByb290TmFtZSA9IE9iamVjdC5rZXlzKHJvb3RPYmopWzBdO1xuICAgICAgICByb290T2JqID0gcm9vdE9ialtyb290TmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290TmFtZSA9IHRoaXMub3B0aW9ucy5yb290TmFtZTtcbiAgICAgIH1cbiAgICAgIHJlbmRlciA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCwgb2JqKSB7XG4gICAgICAgICAgdmFyIGF0dHIsIGNoaWxkLCBlbnRyeSwgaW5kZXgsIGtleSwgdmFsdWU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5jZGF0YSAmJiByZXF1aXJlc0NEQVRBKG9iaikpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5yYXcod3JhcENEQVRBKG9iaikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxlbWVudC50eHQob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKG9iaiwga2V5KSkgY29udGludWU7XG4gICAgICAgICAgICAgIGNoaWxkID0gb2JqW2tleV07XG4gICAgICAgICAgICAgIGlmIChrZXkgPT09IGF0dHJrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGF0dHIgaW4gY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjaGlsZFthdHRyXTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQuYXR0KGF0dHIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBjaGFya2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuY2RhdGEgJiYgcmVxdWlyZXNDREFUQShjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnJhdyh3cmFwQ0RBVEEoY2hpbGQpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQudHh0KGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGluZGV4IGluIGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChjaGlsZCwgaW5kZXgpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIGVudHJ5ID0gY2hpbGRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuY2RhdGEgJiYgcmVxdWlyZXNDREFUQShlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5lbGUoa2V5KS5yYXcod3JhcENEQVRBKGVudHJ5KSkudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5lbGUoa2V5LCBlbnRyeSkudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IHJlbmRlcihlbGVtZW50LmVsZShrZXkpLCBlbnRyeSkudXAoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNoaWxkID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHJlbmRlcihlbGVtZW50LmVsZShrZXkpLCBjaGlsZCkudXAoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyAmJiBfdGhpcy5vcHRpb25zLmNkYXRhICYmIHJlcXVpcmVzQ0RBVEEoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5lbGUoa2V5KS5yYXcod3JhcENEQVRBKGNoaWxkKSkudXAoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSAnJztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LmVsZShrZXksIGNoaWxkLnRvU3RyaW5nKCkpLnVwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICByb290RWxlbWVudCA9IGJ1aWxkZXIuY3JlYXRlKHJvb3ROYW1lLCB0aGlzLm9wdGlvbnMueG1sZGVjLCB0aGlzLm9wdGlvbnMuZG9jdHlwZSwge1xuICAgICAgICBoZWFkbGVzczogdGhpcy5vcHRpb25zLmhlYWRsZXNzLFxuICAgICAgICBhbGxvd1N1cnJvZ2F0ZUNoYXJzOiB0aGlzLm9wdGlvbnMuYWxsb3dTdXJyb2dhdGVDaGFyc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVuZGVyKHJvb3RFbGVtZW50LCByb290T2JqKS5lbmQodGhpcy5vcHRpb25zLnJlbmRlck9wdHMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQnVpbGRlcjtcblxuICB9KSgpO1xuXG4gIGV4cG9ydHMuUGFyc2VyID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUGFyc2VyLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFBhcnNlcihvcHRzKSB7XG4gICAgICB0aGlzLnBhcnNlU3RyaW5nID0gYmluZCh0aGlzLnBhcnNlU3RyaW5nLCB0aGlzKTtcbiAgICAgIHRoaXMucmVzZXQgPSBiaW5kKHRoaXMucmVzZXQsIHRoaXMpO1xuICAgICAgdGhpcy5hc3NpZ25PclB1c2ggPSBiaW5kKHRoaXMuYXNzaWduT3JQdXNoLCB0aGlzKTtcbiAgICAgIHRoaXMucHJvY2Vzc0FzeW5jID0gYmluZCh0aGlzLnByb2Nlc3NBc3luYywgdGhpcyk7XG4gICAgICB2YXIga2V5LCByZWYsIHZhbHVlO1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGV4cG9ydHMuUGFyc2VyKSkge1xuICAgICAgICByZXR1cm4gbmV3IGV4cG9ydHMuUGFyc2VyKG9wdHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICByZWYgPSBleHBvcnRzLmRlZmF1bHRzW1wiMC4yXCJdO1xuICAgICAgZm9yIChrZXkgaW4gcmVmKSB7XG4gICAgICAgIGlmICghaGFzUHJvcC5jYWxsKHJlZiwga2V5KSkgY29udGludWU7XG4gICAgICAgIHZhbHVlID0gcmVmW2tleV07XG4gICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBmb3IgKGtleSBpbiBvcHRzKSB7XG4gICAgICAgIGlmICghaGFzUHJvcC5jYWxsKG9wdHMsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICB2YWx1ZSA9IG9wdHNba2V5XTtcbiAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMueG1sbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnhtbG5za2V5ID0gdGhpcy5vcHRpb25zLmF0dHJrZXkgKyBcIm5zXCI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm5vcm1hbGl6ZVRhZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMudGFnTmFtZVByb2Nlc3NvcnMpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMudGFnTmFtZVByb2Nlc3NvcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMudGFnTmFtZVByb2Nlc3NvcnMudW5zaGlmdChwcm9jZXNzb3JzLm5vcm1hbGl6ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wcm9jZXNzQXN5bmMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaHVuaywgZXJyLCBlcnJvcjE7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5yZW1haW5pbmcubGVuZ3RoIDw9IHRoaXMub3B0aW9ucy5jaHVua1NpemUpIHtcbiAgICAgICAgICBjaHVuayA9IHRoaXMucmVtYWluaW5nO1xuICAgICAgICAgIHRoaXMucmVtYWluaW5nID0gJyc7XG4gICAgICAgICAgdGhpcy5zYXhQYXJzZXIgPSB0aGlzLnNheFBhcnNlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2F4UGFyc2VyLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2h1bmsgPSB0aGlzLnJlbWFpbmluZy5zdWJzdHIoMCwgdGhpcy5vcHRpb25zLmNodW5rU2l6ZSk7XG4gICAgICAgICAgdGhpcy5yZW1haW5pbmcgPSB0aGlzLnJlbWFpbmluZy5zdWJzdHIodGhpcy5vcHRpb25zLmNodW5rU2l6ZSwgdGhpcy5yZW1haW5pbmcubGVuZ3RoKTtcbiAgICAgICAgICB0aGlzLnNheFBhcnNlciA9IHRoaXMuc2F4UGFyc2VyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKHRoaXMucHJvY2Vzc0FzeW5jKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgICAgIGVyciA9IGVycm9yMTtcbiAgICAgICAgaWYgKCF0aGlzLnNheFBhcnNlci5lcnJUaHJvd24pIHtcbiAgICAgICAgICB0aGlzLnNheFBhcnNlci5lcnJUaHJvd24gPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLmFzc2lnbk9yUHVzaCA9IGZ1bmN0aW9uKG9iaiwga2V5LCBuZXdWYWx1ZSkge1xuICAgICAgaWYgKCEoa2V5IGluIG9iaikpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZXhwbGljaXRBcnJheSkge1xuICAgICAgICAgIHJldHVybiBvYmpba2V5XSA9IG5ld1ZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBvYmpba2V5XSA9IFtuZXdWYWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKG9ialtrZXldIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgb2JqW2tleV0gPSBbb2JqW2tleV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmpba2V5XS5wdXNoKG5ld1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGF0dHJrZXksIGNoYXJrZXksIG9udGV4dCwgc3RhY2s7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgdGhpcy5zYXhQYXJzZXIgPSBzYXgucGFyc2VyKHRoaXMub3B0aW9ucy5zdHJpY3QsIHtcbiAgICAgICAgdHJpbTogZmFsc2UsXG4gICAgICAgIG5vcm1hbGl6ZTogZmFsc2UsXG4gICAgICAgIHhtbG5zOiB0aGlzLm9wdGlvbnMueG1sbnNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zYXhQYXJzZXIuZXJyVGhyb3duID0gZmFsc2U7XG4gICAgICB0aGlzLnNheFBhcnNlci5vbmVycm9yID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIF90aGlzLnNheFBhcnNlci5yZXN1bWUoKTtcbiAgICAgICAgICBpZiAoIV90aGlzLnNheFBhcnNlci5lcnJUaHJvd24pIHtcbiAgICAgICAgICAgIF90aGlzLnNheFBhcnNlci5lcnJUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICB0aGlzLnNheFBhcnNlci5vbmVuZCA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCFfdGhpcy5zYXhQYXJzZXIuZW5kZWQpIHtcbiAgICAgICAgICAgIF90aGlzLnNheFBhcnNlci5lbmRlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdChcImVuZFwiLCBfdGhpcy5yZXN1bHRPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgICAgdGhpcy5zYXhQYXJzZXIuZW5kZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuRVhQTElDSVRfQ0hBUktFWSA9IHRoaXMub3B0aW9ucy5leHBsaWNpdENoYXJrZXk7XG4gICAgICB0aGlzLnJlc3VsdE9iamVjdCA9IG51bGw7XG4gICAgICBzdGFjayA9IFtdO1xuICAgICAgYXR0cmtleSA9IHRoaXMub3B0aW9ucy5hdHRya2V5O1xuICAgICAgY2hhcmtleSA9IHRoaXMub3B0aW9ucy5jaGFya2V5O1xuICAgICAgdGhpcy5zYXhQYXJzZXIub25vcGVudGFnID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgdmFyIGtleSwgbmV3VmFsdWUsIG9iaiwgcHJvY2Vzc2VkS2V5LCByZWY7XG4gICAgICAgICAgb2JqID0ge307XG4gICAgICAgICAgb2JqW2NoYXJrZXldID0gXCJcIjtcbiAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMuaWdub3JlQXR0cnMpIHtcbiAgICAgICAgICAgIHJlZiA9IG5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgICAgIGZvciAoa2V5IGluIHJlZikge1xuICAgICAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWYsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBpZiAoIShhdHRya2V5IGluIG9iaikgJiYgIV90aGlzLm9wdGlvbnMubWVyZ2VBdHRycykge1xuICAgICAgICAgICAgICAgIG9ialthdHRya2V5XSA9IHt9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5ld1ZhbHVlID0gX3RoaXMub3B0aW9ucy5hdHRyVmFsdWVQcm9jZXNzb3JzID8gcHJvY2Vzc05hbWUoX3RoaXMub3B0aW9ucy5hdHRyVmFsdWVQcm9jZXNzb3JzLCBub2RlLmF0dHJpYnV0ZXNba2V5XSkgOiBub2RlLmF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgICAgcHJvY2Vzc2VkS2V5ID0gX3RoaXMub3B0aW9ucy5hdHRyTmFtZVByb2Nlc3NvcnMgPyBwcm9jZXNzTmFtZShfdGhpcy5vcHRpb25zLmF0dHJOYW1lUHJvY2Vzc29ycywga2V5KSA6IGtleTtcbiAgICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMubWVyZ2VBdHRycykge1xuICAgICAgICAgICAgICAgIF90aGlzLmFzc2lnbk9yUHVzaChvYmosIHByb2Nlc3NlZEtleSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ialthdHRya2V5XVtwcm9jZXNzZWRLZXldID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqW1wiI25hbWVcIl0gPSBfdGhpcy5vcHRpb25zLnRhZ05hbWVQcm9jZXNzb3JzID8gcHJvY2Vzc05hbWUoX3RoaXMub3B0aW9ucy50YWdOYW1lUHJvY2Vzc29ycywgbm9kZS5uYW1lKSA6IG5vZGUubmFtZTtcbiAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy54bWxucykge1xuICAgICAgICAgICAgb2JqW190aGlzLm9wdGlvbnMueG1sbnNrZXldID0ge1xuICAgICAgICAgICAgICB1cmk6IG5vZGUudXJpLFxuICAgICAgICAgICAgICBsb2NhbDogbm9kZS5sb2NhbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHN0YWNrLnB1c2gob2JqKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgICAgdGhpcy5zYXhQYXJzZXIub25jbG9zZXRhZyA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGNkYXRhLCBlbXB0eVN0ciwgZXJyLCBlcnJvcjEsIGtleSwgbm9kZSwgbm9kZU5hbWUsIG9iaiwgb2JqQ2xvbmUsIG9sZCwgcywgeHBhdGg7XG4gICAgICAgICAgb2JqID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgbm9kZU5hbWUgPSBvYmpbXCIjbmFtZVwiXTtcbiAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMuZXhwbGljaXRDaGlsZHJlbiB8fCAhX3RoaXMub3B0aW9ucy5wcmVzZXJ2ZUNoaWxkcmVuT3JkZXIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpbXCIjbmFtZVwiXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iai5jZGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY2RhdGEgPSBvYmouY2RhdGE7XG4gICAgICAgICAgICBkZWxldGUgb2JqLmNkYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKG9ialtjaGFya2V5XS5tYXRjaCgvXlxccyokLykgJiYgIWNkYXRhKSB7XG4gICAgICAgICAgICBlbXB0eVN0ciA9IG9ialtjaGFya2V5XTtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpbY2hhcmtleV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnRyaW0pIHtcbiAgICAgICAgICAgICAgb2JqW2NoYXJrZXldID0gb2JqW2NoYXJrZXldLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLm5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgICBvYmpbY2hhcmtleV0gPSBvYmpbY2hhcmtleV0ucmVwbGFjZSgvXFxzezIsfS9nLCBcIiBcIikudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqW2NoYXJrZXldID0gX3RoaXMub3B0aW9ucy52YWx1ZVByb2Nlc3NvcnMgPyBwcm9jZXNzTmFtZShfdGhpcy5vcHRpb25zLnZhbHVlUHJvY2Vzc29ycywgb2JqW2NoYXJrZXldKSA6IG9ialtjaGFya2V5XTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMSAmJiBjaGFya2V5IGluIG9iaiAmJiAhX3RoaXMuRVhQTElDSVRfQ0hBUktFWSkge1xuICAgICAgICAgICAgICBvYmogPSBvYmpbY2hhcmtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0VtcHR5KG9iaikpIHtcbiAgICAgICAgICAgIG9iaiA9IF90aGlzLm9wdGlvbnMuZW1wdHlUYWcgIT09ICcnID8gX3RoaXMub3B0aW9ucy5lbXB0eVRhZyA6IGVtcHR5U3RyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy52YWxpZGF0b3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgeHBhdGggPSBcIi9cIiArICgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBpLCBsZW4sIHJlc3VsdHM7XG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc3RhY2subGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBub2RlID0gc3RhY2tbaV07XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKG5vZGVbXCIjbmFtZVwiXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KSgpKS5jb25jYXQobm9kZU5hbWUpLmpvaW4oXCIvXCIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgb2JqID0gX3RoaXMub3B0aW9ucy52YWxpZGF0b3IoeHBhdGgsIHMgJiYgc1tub2RlTmFtZV0sIG9iaik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICAgICAgICAgICAgZXJyID0gZXJyb3IxO1xuICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuZXhwbGljaXRDaGlsZHJlbiAmJiAhX3RoaXMub3B0aW9ucy5tZXJnZUF0dHJzICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMucHJlc2VydmVDaGlsZHJlbk9yZGVyKSB7XG4gICAgICAgICAgICAgIG5vZGUgPSB7fTtcbiAgICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuYXR0cmtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBub2RlW190aGlzLm9wdGlvbnMuYXR0cmtleV0gPSBvYmpbX3RoaXMub3B0aW9ucy5hdHRya2V5XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgb2JqW190aGlzLm9wdGlvbnMuYXR0cmtleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLmNoYXJzQXNDaGlsZHJlbiAmJiBfdGhpcy5vcHRpb25zLmNoYXJrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgbm9kZVtfdGhpcy5vcHRpb25zLmNoYXJrZXldID0gb2JqW190aGlzLm9wdGlvbnMuY2hhcmtleV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9ialtfdGhpcy5vcHRpb25zLmNoYXJrZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBub2RlW190aGlzLm9wdGlvbnMuY2hpbGRrZXldID0gb2JqO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9iaiA9IG5vZGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHMpIHtcbiAgICAgICAgICAgICAgc1tfdGhpcy5vcHRpb25zLmNoaWxka2V5XSA9IHNbX3RoaXMub3B0aW9ucy5jaGlsZGtleV0gfHwgW107XG4gICAgICAgICAgICAgIG9iakNsb25lID0ge307XG4gICAgICAgICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKG9iaiwga2V5KSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgb2JqQ2xvbmVba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNbX3RoaXMub3B0aW9ucy5jaGlsZGtleV0ucHVzaChvYmpDbG9uZSk7XG4gICAgICAgICAgICAgIGRlbGV0ZSBvYmpbXCIjbmFtZVwiXTtcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAxICYmIGNoYXJrZXkgaW4gb2JqICYmICFfdGhpcy5FWFBMSUNJVF9DSEFSS0VZKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqW2NoYXJrZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYXNzaWduT3JQdXNoKHMsIG5vZGVOYW1lLCBvYmopO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5leHBsaWNpdFJvb3QpIHtcbiAgICAgICAgICAgICAgb2xkID0gb2JqO1xuICAgICAgICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgICAgICAgb2JqW25vZGVOYW1lXSA9IG9sZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnJlc3VsdE9iamVjdCA9IG9iajtcbiAgICAgICAgICAgIF90aGlzLnNheFBhcnNlci5lbmRlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdChcImVuZFwiLCBfdGhpcy5yZXN1bHRPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgICAgb250ZXh0ID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgdmFyIGNoYXJDaGlsZCwgcztcbiAgICAgICAgICBzID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgIHNbY2hhcmtleV0gKz0gdGV4dDtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmV4cGxpY2l0Q2hpbGRyZW4gJiYgX3RoaXMub3B0aW9ucy5wcmVzZXJ2ZUNoaWxkcmVuT3JkZXIgJiYgX3RoaXMub3B0aW9ucy5jaGFyc0FzQ2hpbGRyZW4gJiYgdGV4dC5yZXBsYWNlKC9cXFxcbi9nLCAnJykudHJpbSgpICE9PSAnJykge1xuICAgICAgICAgICAgICBzW190aGlzLm9wdGlvbnMuY2hpbGRrZXldID0gc1tfdGhpcy5vcHRpb25zLmNoaWxka2V5XSB8fCBbXTtcbiAgICAgICAgICAgICAgY2hhckNoaWxkID0ge1xuICAgICAgICAgICAgICAgICcjbmFtZSc6ICdfX3RleHRfXydcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY2hhckNoaWxkW2NoYXJrZXldID0gdGV4dDtcbiAgICAgICAgICAgICAgc1tfdGhpcy5vcHRpb25zLmNoaWxka2V5XS5wdXNoKGNoYXJDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIHRoaXMuc2F4UGFyc2VyLm9udGV4dCA9IG9udGV4dDtcbiAgICAgIHJldHVybiB0aGlzLnNheFBhcnNlci5vbmNkYXRhID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgdmFyIHM7XG4gICAgICAgICAgcyA9IG9udGV4dCh0ZXh0KTtcbiAgICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgcmV0dXJuIHMuY2RhdGEgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3RyaW5nID0gZnVuY3Rpb24oc3RyLCBjYikge1xuICAgICAgdmFyIGVyciwgZXJyb3IxO1xuICAgICAgaWYgKChjYiAhPSBudWxsKSAmJiB0eXBlb2YgY2IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uKFwiZW5kXCIsIGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oXCJlcnJvclwiLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgc3RyID0gc3RyLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChzdHIudHJpbSgpID09PSAnJykge1xuICAgICAgICAgIHRoaXMuZW1pdChcImVuZFwiLCBudWxsKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBib20uc3RyaXBCT00oc3RyKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hc3luYykge1xuICAgICAgICAgIHRoaXMucmVtYWluaW5nID0gc3RyO1xuICAgICAgICAgIHNldEltbWVkaWF0ZSh0aGlzLnByb2Nlc3NBc3luYyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2F4UGFyc2VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNheFBhcnNlci53cml0ZShzdHIpLmNsb3NlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICAgICAgZXJyID0gZXJyb3IxO1xuICAgICAgICBpZiAoISh0aGlzLnNheFBhcnNlci5lcnJUaHJvd24gfHwgdGhpcy5zYXhQYXJzZXIuZW5kZWQpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2F4UGFyc2VyLmVyclRocm93biA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zYXhQYXJzZXIuZW5kZWQpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFBhcnNlcjtcblxuICB9KShldmVudHMuRXZlbnRFbWl0dGVyKTtcblxuICBleHBvcnRzLnBhcnNlU3RyaW5nID0gZnVuY3Rpb24oc3RyLCBhLCBiKSB7XG4gICAgdmFyIGNiLCBvcHRpb25zLCBwYXJzZXI7XG4gICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNiID0gYjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0aW9ucyA9IGE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYiA9IGE7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHBhcnNlciA9IG5ldyBleHBvcnRzLlBhcnNlcihvcHRpb25zKTtcbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlU3RyaW5nKHN0ciwgY2IpO1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiOyhmdW5jdGlvbiAoc2F4KSB7IC8vIHdyYXBwZXIgZm9yIG5vbi1ub2RlIGVudnNcbiAgc2F4LnBhcnNlciA9IGZ1bmN0aW9uIChzdHJpY3QsIG9wdCkgeyByZXR1cm4gbmV3IFNBWFBhcnNlcihzdHJpY3QsIG9wdCkgfVxuICBzYXguU0FYUGFyc2VyID0gU0FYUGFyc2VyXG4gIHNheC5TQVhTdHJlYW0gPSBTQVhTdHJlYW1cbiAgc2F4LmNyZWF0ZVN0cmVhbSA9IGNyZWF0ZVN0cmVhbVxuXG4gIC8vIFdoZW4gd2UgcGFzcyB0aGUgTUFYX0JVRkZFUl9MRU5HVEggcG9zaXRpb24sIHN0YXJ0IGNoZWNraW5nIGZvciBidWZmZXIgb3ZlcnJ1bnMuXG4gIC8vIFdoZW4gd2UgY2hlY2ssIHNjaGVkdWxlIHRoZSBuZXh0IGNoZWNrIGZvciBNQVhfQlVGRkVSX0xFTkdUSCAtIChtYXgoYnVmZmVyIGxlbmd0aHMpKSxcbiAgLy8gc2luY2UgdGhhdCdzIHRoZSBlYXJsaWVzdCB0aGF0IGEgYnVmZmVyIG92ZXJydW4gY291bGQgb2NjdXIuICBUaGlzIHdheSwgY2hlY2tzIGFyZVxuICAvLyBhcyByYXJlIGFzIHJlcXVpcmVkLCBidXQgYXMgb2Z0ZW4gYXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSBuZXZlciBjcm9zc2luZyB0aGlzIGJvdW5kLlxuICAvLyBGdXJ0aGVybW9yZSwgYnVmZmVycyBhcmUgb25seSB0ZXN0ZWQgYXQgbW9zdCBvbmNlIHBlciB3cml0ZSgpLCBzbyBwYXNzaW5nIGEgdmVyeVxuICAvLyBsYXJnZSBzdHJpbmcgaW50byB3cml0ZSgpIG1pZ2h0IGhhdmUgdW5kZXNpcmFibGUgZWZmZWN0cywgYnV0IHRoaXMgaXMgbWFuYWdlYWJsZSBieVxuICAvLyB0aGUgY2FsbGVyLCBzbyBpdCBpcyBhc3N1bWVkIHRvIGJlIHNhZmUuICBUaHVzLCBhIGNhbGwgdG8gd3JpdGUoKSBtYXksIGluIHRoZSBleHRyZW1lXG4gIC8vIGVkZ2UgY2FzZSwgcmVzdWx0IGluIGNyZWF0aW5nIGF0IG1vc3Qgb25lIGNvbXBsZXRlIGNvcHkgb2YgdGhlIHN0cmluZyBwYXNzZWQgaW4uXG4gIC8vIFNldCB0byBJbmZpbml0eSB0byBoYXZlIHVubGltaXRlZCBidWZmZXJzLlxuICBzYXguTUFYX0JVRkZFUl9MRU5HVEggPSA2NCAqIDEwMjRcblxuICB2YXIgYnVmZmVycyA9IFtcbiAgICAnY29tbWVudCcsICdzZ21sRGVjbCcsICd0ZXh0Tm9kZScsICd0YWdOYW1lJywgJ2RvY3R5cGUnLFxuICAgICdwcm9jSW5zdE5hbWUnLCAncHJvY0luc3RCb2R5JywgJ2VudGl0eScsICdhdHRyaWJOYW1lJyxcbiAgICAnYXR0cmliVmFsdWUnLCAnY2RhdGEnLCAnc2NyaXB0J1xuICBdXG5cbiAgc2F4LkVWRU5UUyA9IFtcbiAgICAndGV4dCcsXG4gICAgJ3Byb2Nlc3NpbmdpbnN0cnVjdGlvbicsXG4gICAgJ3NnbWxkZWNsYXJhdGlvbicsXG4gICAgJ2RvY3R5cGUnLFxuICAgICdjb21tZW50JyxcbiAgICAnb3BlbnRhZ3N0YXJ0JyxcbiAgICAnYXR0cmlidXRlJyxcbiAgICAnb3BlbnRhZycsXG4gICAgJ2Nsb3NldGFnJyxcbiAgICAnb3BlbmNkYXRhJyxcbiAgICAnY2RhdGEnLFxuICAgICdjbG9zZWNkYXRhJyxcbiAgICAnZXJyb3InLFxuICAgICdlbmQnLFxuICAgICdyZWFkeScsXG4gICAgJ3NjcmlwdCcsXG4gICAgJ29wZW5uYW1lc3BhY2UnLFxuICAgICdjbG9zZW5hbWVzcGFjZSdcbiAgXVxuXG4gIGZ1bmN0aW9uIFNBWFBhcnNlciAoc3RyaWN0LCBvcHQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0FYUGFyc2VyKSkge1xuICAgICAgcmV0dXJuIG5ldyBTQVhQYXJzZXIoc3RyaWN0LCBvcHQpXG4gICAgfVxuXG4gICAgdmFyIHBhcnNlciA9IHRoaXNcbiAgICBjbGVhckJ1ZmZlcnMocGFyc2VyKVxuICAgIHBhcnNlci5xID0gcGFyc2VyLmMgPSAnJ1xuICAgIHBhcnNlci5idWZmZXJDaGVja1Bvc2l0aW9uID0gc2F4Lk1BWF9CVUZGRVJfTEVOR1RIXG4gICAgcGFyc2VyLm9wdCA9IG9wdCB8fCB7fVxuICAgIHBhcnNlci5vcHQubG93ZXJjYXNlID0gcGFyc2VyLm9wdC5sb3dlcmNhc2UgfHwgcGFyc2VyLm9wdC5sb3dlcmNhc2V0YWdzXG4gICAgcGFyc2VyLmxvb3NlQ2FzZSA9IHBhcnNlci5vcHQubG93ZXJjYXNlID8gJ3RvTG93ZXJDYXNlJyA6ICd0b1VwcGVyQ2FzZSdcbiAgICBwYXJzZXIudGFncyA9IFtdXG4gICAgcGFyc2VyLmNsb3NlZCA9IHBhcnNlci5jbG9zZWRSb290ID0gcGFyc2VyLnNhd1Jvb3QgPSBmYWxzZVxuICAgIHBhcnNlci50YWcgPSBwYXJzZXIuZXJyb3IgPSBudWxsXG4gICAgcGFyc2VyLnN0cmljdCA9ICEhc3RyaWN0XG4gICAgcGFyc2VyLm5vc2NyaXB0ID0gISEoc3RyaWN0IHx8IHBhcnNlci5vcHQubm9zY3JpcHQpXG4gICAgcGFyc2VyLnN0YXRlID0gUy5CRUdJTlxuICAgIHBhcnNlci5zdHJpY3RFbnRpdGllcyA9IHBhcnNlci5vcHQuc3RyaWN0RW50aXRpZXNcbiAgICBwYXJzZXIuRU5USVRJRVMgPSBwYXJzZXIuc3RyaWN0RW50aXRpZXMgPyBPYmplY3QuY3JlYXRlKHNheC5YTUxfRU5USVRJRVMpIDogT2JqZWN0LmNyZWF0ZShzYXguRU5USVRJRVMpXG4gICAgcGFyc2VyLmF0dHJpYkxpc3QgPSBbXVxuXG4gICAgLy8gbmFtZXNwYWNlcyBmb3JtIGEgcHJvdG90eXBlIGNoYWluLlxuICAgIC8vIGl0IGFsd2F5cyBwb2ludHMgYXQgdGhlIGN1cnJlbnQgdGFnLFxuICAgIC8vIHdoaWNoIHByb3RvcyB0byBpdHMgcGFyZW50IHRhZy5cbiAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgcGFyc2VyLm5zID0gT2JqZWN0LmNyZWF0ZShyb290TlMpXG4gICAgfVxuXG4gICAgLy8gbW9zdGx5IGp1c3QgZm9yIGVycm9yIHJlcG9ydGluZ1xuICAgIHBhcnNlci50cmFja1Bvc2l0aW9uID0gcGFyc2VyLm9wdC5wb3NpdGlvbiAhPT0gZmFsc2VcbiAgICBpZiAocGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgIHBhcnNlci5wb3NpdGlvbiA9IHBhcnNlci5saW5lID0gcGFyc2VyLmNvbHVtbiA9IDBcbiAgICB9XG4gICAgZW1pdChwYXJzZXIsICdvbnJlYWR5JylcbiAgfVxuXG4gIGlmICghT2JqZWN0LmNyZWF0ZSkge1xuICAgIE9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAobykge1xuICAgICAgZnVuY3Rpb24gRiAoKSB7fVxuICAgICAgRi5wcm90b3R5cGUgPSBvXG4gICAgICB2YXIgbmV3ZiA9IG5ldyBGKClcbiAgICAgIHJldHVybiBuZXdmXG4gICAgfVxuICB9XG5cbiAgaWYgKCFPYmplY3Qua2V5cykge1xuICAgIE9iamVjdC5rZXlzID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBhID0gW11cbiAgICAgIGZvciAodmFyIGkgaW4gbykgaWYgKG8uaGFzT3duUHJvcGVydHkoaSkpIGEucHVzaChpKVxuICAgICAgcmV0dXJuIGFcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0J1ZmZlckxlbmd0aCAocGFyc2VyKSB7XG4gICAgdmFyIG1heEFsbG93ZWQgPSBNYXRoLm1heChzYXguTUFYX0JVRkZFUl9MRU5HVEgsIDEwKVxuICAgIHZhciBtYXhBY3R1YWwgPSAwXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBidWZmZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGxlbiA9IHBhcnNlcltidWZmZXJzW2ldXS5sZW5ndGhcbiAgICAgIGlmIChsZW4gPiBtYXhBbGxvd2VkKSB7XG4gICAgICAgIC8vIFRleHQvY2RhdGEgbm9kZXMgY2FuIGdldCBiaWcsIGFuZCBzaW5jZSB0aGV5J3JlIGJ1ZmZlcmVkLFxuICAgICAgICAvLyB3ZSBjYW4gZ2V0IGhlcmUgdW5kZXIgbm9ybWFsIGNvbmRpdGlvbnMuXG4gICAgICAgIC8vIEF2b2lkIGlzc3VlcyBieSBlbWl0dGluZyB0aGUgdGV4dCBub2RlIG5vdyxcbiAgICAgICAgLy8gc28gYXQgbGVhc3QgaXQgd29uJ3QgZ2V0IGFueSBiaWdnZXIuXG4gICAgICAgIHN3aXRjaCAoYnVmZmVyc1tpXSkge1xuICAgICAgICAgIGNhc2UgJ3RleHROb2RlJzpcbiAgICAgICAgICAgIGNsb3NlVGV4dChwYXJzZXIpXG4gICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgY2FzZSAnY2RhdGEnOlxuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jZGF0YScsIHBhcnNlci5jZGF0YSlcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSA9ICcnXG4gICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgY2FzZSAnc2NyaXB0JzpcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uc2NyaXB0JywgcGFyc2VyLnNjcmlwdClcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgPSAnJ1xuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlcnJvcihwYXJzZXIsICdNYXggYnVmZmVyIGxlbmd0aCBleGNlZWRlZDogJyArIGJ1ZmZlcnNbaV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1heEFjdHVhbCA9IE1hdGgubWF4KG1heEFjdHVhbCwgbGVuKVxuICAgIH1cbiAgICAvLyBzY2hlZHVsZSB0aGUgbmV4dCBjaGVjayBmb3IgdGhlIGVhcmxpZXN0IHBvc3NpYmxlIGJ1ZmZlciBvdmVycnVuLlxuICAgIHZhciBtID0gc2F4Lk1BWF9CVUZGRVJfTEVOR1RIIC0gbWF4QWN0dWFsXG4gICAgcGFyc2VyLmJ1ZmZlckNoZWNrUG9zaXRpb24gPSBtICsgcGFyc2VyLnBvc2l0aW9uXG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckJ1ZmZlcnMgKHBhcnNlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYnVmZmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHBhcnNlcltidWZmZXJzW2ldXSA9ICcnXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2hCdWZmZXJzIChwYXJzZXIpIHtcbiAgICBjbG9zZVRleHQocGFyc2VyKVxuICAgIGlmIChwYXJzZXIuY2RhdGEgIT09ICcnKSB7XG4gICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNkYXRhJywgcGFyc2VyLmNkYXRhKVxuICAgICAgcGFyc2VyLmNkYXRhID0gJydcbiAgICB9XG4gICAgaWYgKHBhcnNlci5zY3JpcHQgIT09ICcnKSB7XG4gICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnNjcmlwdCcsIHBhcnNlci5zY3JpcHQpXG4gICAgICBwYXJzZXIuc2NyaXB0ID0gJydcbiAgICB9XG4gIH1cblxuICBTQVhQYXJzZXIucHJvdG90eXBlID0ge1xuICAgIGVuZDogZnVuY3Rpb24gKCkgeyBlbmQodGhpcykgfSxcbiAgICB3cml0ZTogd3JpdGUsXG4gICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7IHRoaXMuZXJyb3IgPSBudWxsOyByZXR1cm4gdGhpcyB9LFxuICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLndyaXRlKG51bGwpIH0sXG4gICAgZmx1c2g6IGZ1bmN0aW9uICgpIHsgZmx1c2hCdWZmZXJzKHRoaXMpIH1cbiAgfVxuXG4gIHZhciBTdHJlYW1cbiAgdHJ5IHtcbiAgICBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW1cbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBTdHJlYW0gPSBmdW5jdGlvbiAoKSB7fVxuICB9XG5cbiAgdmFyIHN0cmVhbVdyYXBzID0gc2F4LkVWRU5UUy5maWx0ZXIoZnVuY3Rpb24gKGV2KSB7XG4gICAgcmV0dXJuIGV2ICE9PSAnZXJyb3InICYmIGV2ICE9PSAnZW5kJ1xuICB9KVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmVhbSAoc3RyaWN0LCBvcHQpIHtcbiAgICByZXR1cm4gbmV3IFNBWFN0cmVhbShzdHJpY3QsIG9wdClcbiAgfVxuXG4gIGZ1bmN0aW9uIFNBWFN0cmVhbSAoc3RyaWN0LCBvcHQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0FYU3RyZWFtKSkge1xuICAgICAgcmV0dXJuIG5ldyBTQVhTdHJlYW0oc3RyaWN0LCBvcHQpXG4gICAgfVxuXG4gICAgU3RyZWFtLmFwcGx5KHRoaXMpXG5cbiAgICB0aGlzLl9wYXJzZXIgPSBuZXcgU0FYUGFyc2VyKHN0cmljdCwgb3B0KVxuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlXG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWVcblxuICAgIHZhciBtZSA9IHRoaXNcblxuICAgIHRoaXMuX3BhcnNlci5vbmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG1lLmVtaXQoJ2VuZCcpXG4gICAgfVxuXG4gICAgdGhpcy5fcGFyc2VyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICAgIG1lLmVtaXQoJ2Vycm9yJywgZXIpXG5cbiAgICAgIC8vIGlmIGRpZG4ndCB0aHJvdywgdGhlbiBtZWFucyBlcnJvciB3YXMgaGFuZGxlZC5cbiAgICAgIC8vIGdvIGFoZWFkIGFuZCBjbGVhciBlcnJvciwgc28gd2UgY2FuIHdyaXRlIGFnYWluLlxuICAgICAgbWUuX3BhcnNlci5lcnJvciA9IG51bGxcbiAgICB9XG5cbiAgICB0aGlzLl9kZWNvZGVyID0gbnVsbFxuXG4gICAgc3RyZWFtV3JhcHMuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZSwgJ29uJyArIGV2LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBtZS5fcGFyc2VyWydvbicgKyBldl1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoaCkge1xuICAgICAgICAgIGlmICghaCkge1xuICAgICAgICAgICAgbWUucmVtb3ZlQWxsTGlzdGVuZXJzKGV2KVxuICAgICAgICAgICAgbWUuX3BhcnNlclsnb24nICsgZXZdID0gaFxuICAgICAgICAgICAgcmV0dXJuIGhcbiAgICAgICAgICB9XG4gICAgICAgICAgbWUub24oZXYsIGgpXG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIFNBWFN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN0cmVhbS5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IFNBWFN0cmVhbVxuICAgIH1cbiAgfSlcblxuICBTQVhTdHJlYW0ucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIEJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICBpZiAoIXRoaXMuX2RlY29kZXIpIHtcbiAgICAgICAgdmFyIFNEID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyXG4gICAgICAgIHRoaXMuX2RlY29kZXIgPSBuZXcgU0QoJ3V0ZjgnKVxuICAgICAgfVxuICAgICAgZGF0YSA9IHRoaXMuX2RlY29kZXIud3JpdGUoZGF0YSlcbiAgICB9XG5cbiAgICB0aGlzLl9wYXJzZXIud3JpdGUoZGF0YS50b1N0cmluZygpKVxuICAgIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIFNBWFN0cmVhbS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgdGhpcy53cml0ZShjaHVuaylcbiAgICB9XG4gICAgdGhpcy5fcGFyc2VyLmVuZCgpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIFNBWFN0cmVhbS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGhhbmRsZXIpIHtcbiAgICB2YXIgbWUgPSB0aGlzXG4gICAgaWYgKCFtZS5fcGFyc2VyWydvbicgKyBldl0gJiYgc3RyZWFtV3JhcHMuaW5kZXhPZihldikgIT09IC0xKSB7XG4gICAgICBtZS5fcGFyc2VyWydvbicgKyBldl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IFthcmd1bWVudHNbMF1dIDogQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgICAgICBhcmdzLnNwbGljZSgwLCAwLCBldilcbiAgICAgICAgbWUuZW1pdC5hcHBseShtZSwgYXJncylcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKG1lLCBldiwgaGFuZGxlcilcbiAgfVxuXG4gIC8vIGNoYXJhY3RlciBjbGFzc2VzIGFuZCB0b2tlbnNcbiAgdmFyIHdoaXRlc3BhY2UgPSAnXFxyXFxuXFx0ICdcblxuICAvLyB0aGlzIHJlYWxseSBuZWVkcyB0byBiZSByZXBsYWNlZCB3aXRoIGNoYXJhY3RlciBjbGFzc2VzLlxuICAvLyBYTUwgYWxsb3dzIGFsbCBtYW5uZXIgb2YgcmlkaWN1bG91cyBudW1iZXJzIGFuZCBkaWdpdHMuXG4gIHZhciBudW1iZXIgPSAnMDEyNDM1Njc4OSdcbiAgdmFyIGxldHRlciA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJ1xuXG4gIC8vIChMZXR0ZXIgfCBcIl9cIiB8IFwiOlwiKVxuICB2YXIgcXVvdGUgPSAnXFwnXCInXG4gIHZhciBhdHRyaWJFbmQgPSB3aGl0ZXNwYWNlICsgJz4nXG4gIHZhciBDREFUQSA9ICdbQ0RBVEFbJ1xuICB2YXIgRE9DVFlQRSA9ICdET0NUWVBFJ1xuICB2YXIgWE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG4gIHZhciBYTUxOU19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nXG4gIHZhciByb290TlMgPSB7IHhtbDogWE1MX05BTUVTUEFDRSwgeG1sbnM6IFhNTE5TX05BTUVTUEFDRSB9XG5cbiAgLy8gdHVybiBhbGwgdGhlIHN0cmluZyBjaGFyYWN0ZXIgc2V0cyBpbnRvIGNoYXJhY3RlciBjbGFzcyBvYmplY3RzLlxuICB3aGl0ZXNwYWNlID0gY2hhckNsYXNzKHdoaXRlc3BhY2UpXG4gIG51bWJlciA9IGNoYXJDbGFzcyhudW1iZXIpXG4gIGxldHRlciA9IGNoYXJDbGFzcyhsZXR0ZXIpXG5cbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVN0YXJ0Q2hhclxuICAvLyBUaGlzIGltcGxlbWVudGF0aW9uIHdvcmtzIG9uIHN0cmluZ3MsIGEgc2luZ2xlIGNoYXJhY3RlciBhdCBhIHRpbWVcbiAgLy8gYXMgc3VjaCwgaXQgY2Fubm90IGV2ZXIgc3VwcG9ydCBhc3RyYWwtcGxhbmUgY2hhcmFjdGVycyAoMTAwMDAtRUZGRkYpXG4gIC8vIHdpdGhvdXQgYSBzaWduaWZpY2FudCBicmVha2luZyBjaGFuZ2UgdG8gZWl0aGVyIHRoaXMgIHBhcnNlciwgb3IgdGhlXG4gIC8vIEphdmFTY3JpcHQgbGFuZ3VhZ2UuICBJbXBsZW1lbnRhdGlvbiBvZiBhbiBlbW9qaS1jYXBhYmxlIHhtbCBwYXJzZXJcbiAgLy8gaXMgbGVmdCBhcyBhbiBleGVyY2lzZSBmb3IgdGhlIHJlYWRlci5cbiAgdmFyIG5hbWVTdGFydCA9IC9bOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdL1xuXG4gIHZhciBuYW1lQm9keSA9IC9bOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcXHUwMEI3XFx1MDMwMC1cXHUwMzZGXFx1MjAzRi1cXHUyMDQwXFwuXFxkLV0vXG5cbiAgdmFyIGVudGl0eVN0YXJ0ID0gL1sjOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdL1xuICB2YXIgZW50aXR5Qm9keSA9IC9bIzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXFx1MDBCN1xcdTAzMDAtXFx1MDM2RlxcdTIwM0YtXFx1MjA0MFxcLlxcZC1dL1xuXG4gIHF1b3RlID0gY2hhckNsYXNzKHF1b3RlKVxuICBhdHRyaWJFbmQgPSBjaGFyQ2xhc3MoYXR0cmliRW5kKVxuXG4gIGZ1bmN0aW9uIGNoYXJDbGFzcyAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnJykucmVkdWNlKGZ1bmN0aW9uIChzLCBjKSB7XG4gICAgICBzW2NdID0gdHJ1ZVxuICAgICAgcmV0dXJuIHNcbiAgICB9LCB7fSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUmVnRXhwIChjKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChjKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzIChjaGFyY2xhc3MsIGMpIHtcbiAgICByZXR1cm4gaXNSZWdFeHAoY2hhcmNsYXNzKSA/ICEhYy5tYXRjaChjaGFyY2xhc3MpIDogY2hhcmNsYXNzW2NdXG4gIH1cblxuICBmdW5jdGlvbiBub3QgKGNoYXJjbGFzcywgYykge1xuICAgIHJldHVybiAhaXMoY2hhcmNsYXNzLCBjKVxuICB9XG5cbiAgdmFyIFMgPSAwXG4gIHNheC5TVEFURSA9IHtcbiAgICBCRUdJTjogUysrLCAvLyBsZWFkaW5nIGJ5dGUgb3JkZXIgbWFyayBvciB3aGl0ZXNwYWNlXG4gICAgQkVHSU5fV0hJVEVTUEFDRTogUysrLCAvLyBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICBURVhUOiBTKyssIC8vIGdlbmVyYWwgc3R1ZmZcbiAgICBURVhUX0VOVElUWTogUysrLCAvLyAmYW1wIGFuZCBzdWNoLlxuICAgIE9QRU5fV0FLQTogUysrLCAvLyA8XG4gICAgU0dNTF9ERUNMOiBTKyssIC8vIDwhQkxBUkdcbiAgICBTR01MX0RFQ0xfUVVPVEVEOiBTKyssIC8vIDwhQkxBUkcgZm9vIFwiYmFyXG4gICAgRE9DVFlQRTogUysrLCAvLyA8IURPQ1RZUEVcbiAgICBET0NUWVBFX1FVT1RFRDogUysrLCAvLyA8IURPQ1RZUEUgXCIvL2JsYWhcbiAgICBET0NUWVBFX0RURDogUysrLCAvLyA8IURPQ1RZUEUgXCIvL2JsYWhcIiBbIC4uLlxuICAgIERPQ1RZUEVfRFREX1FVT1RFRDogUysrLCAvLyA8IURPQ1RZUEUgXCIvL2JsYWhcIiBbIFwiZm9vXG4gICAgQ09NTUVOVF9TVEFSVElORzogUysrLCAvLyA8IS1cbiAgICBDT01NRU5UOiBTKyssIC8vIDwhLS1cbiAgICBDT01NRU5UX0VORElORzogUysrLCAvLyA8IS0tIGJsYWggLVxuICAgIENPTU1FTlRfRU5ERUQ6IFMrKywgLy8gPCEtLSBibGFoIC0tXG4gICAgQ0RBVEE6IFMrKywgLy8gPCFbQ0RBVEFbIHNvbWV0aGluZ1xuICAgIENEQVRBX0VORElORzogUysrLCAvLyBdXG4gICAgQ0RBVEFfRU5ESU5HXzI6IFMrKywgLy8gXV1cbiAgICBQUk9DX0lOU1Q6IFMrKywgLy8gPD9oaVxuICAgIFBST0NfSU5TVF9CT0RZOiBTKyssIC8vIDw/aGkgdGhlcmVcbiAgICBQUk9DX0lOU1RfRU5ESU5HOiBTKyssIC8vIDw/aGkgXCJ0aGVyZVwiID9cbiAgICBPUEVOX1RBRzogUysrLCAvLyA8c3Ryb25nXG4gICAgT1BFTl9UQUdfU0xBU0g6IFMrKywgLy8gPHN0cm9uZyAvXG4gICAgQVRUUklCOiBTKyssIC8vIDxhXG4gICAgQVRUUklCX05BTUU6IFMrKywgLy8gPGEgZm9vXG4gICAgQVRUUklCX05BTUVfU0FXX1dISVRFOiBTKyssIC8vIDxhIGZvbyBfXG4gICAgQVRUUklCX1ZBTFVFOiBTKyssIC8vIDxhIGZvbz1cbiAgICBBVFRSSUJfVkFMVUVfUVVPVEVEOiBTKyssIC8vIDxhIGZvbz1cImJhclxuICAgIEFUVFJJQl9WQUxVRV9DTE9TRUQ6IFMrKywgLy8gPGEgZm9vPVwiYmFyXCJcbiAgICBBVFRSSUJfVkFMVUVfVU5RVU9URUQ6IFMrKywgLy8gPGEgZm9vPWJhclxuICAgIEFUVFJJQl9WQUxVRV9FTlRJVFlfUTogUysrLCAvLyA8Zm9vIGJhcj1cIiZxdW90O1wiXG4gICAgQVRUUklCX1ZBTFVFX0VOVElUWV9VOiBTKyssIC8vIDxmb28gYmFyPSZxdW90XG4gICAgQ0xPU0VfVEFHOiBTKyssIC8vIDwvYVxuICAgIENMT1NFX1RBR19TQVdfV0hJVEU6IFMrKywgLy8gPC9hICAgPlxuICAgIFNDUklQVDogUysrLCAvLyA8c2NyaXB0PiAuLi5cbiAgICBTQ1JJUFRfRU5ESU5HOiBTKysgLy8gPHNjcmlwdD4gLi4uIDxcbiAgfVxuXG4gIHNheC5YTUxfRU5USVRJRVMgPSB7XG4gICAgJ2FtcCc6ICcmJyxcbiAgICAnZ3QnOiAnPicsXG4gICAgJ2x0JzogJzwnLFxuICAgICdxdW90JzogJ1wiJyxcbiAgICAnYXBvcyc6IFwiJ1wiXG4gIH1cblxuICBzYXguRU5USVRJRVMgPSB7XG4gICAgJ2FtcCc6ICcmJyxcbiAgICAnZ3QnOiAnPicsXG4gICAgJ2x0JzogJzwnLFxuICAgICdxdW90JzogJ1wiJyxcbiAgICAnYXBvcyc6IFwiJ1wiLFxuICAgICdBRWxpZyc6IDE5OCxcbiAgICAnQWFjdXRlJzogMTkzLFxuICAgICdBY2lyYyc6IDE5NCxcbiAgICAnQWdyYXZlJzogMTkyLFxuICAgICdBcmluZyc6IDE5NyxcbiAgICAnQXRpbGRlJzogMTk1LFxuICAgICdBdW1sJzogMTk2LFxuICAgICdDY2VkaWwnOiAxOTksXG4gICAgJ0VUSCc6IDIwOCxcbiAgICAnRWFjdXRlJzogMjAxLFxuICAgICdFY2lyYyc6IDIwMixcbiAgICAnRWdyYXZlJzogMjAwLFxuICAgICdFdW1sJzogMjAzLFxuICAgICdJYWN1dGUnOiAyMDUsXG4gICAgJ0ljaXJjJzogMjA2LFxuICAgICdJZ3JhdmUnOiAyMDQsXG4gICAgJ0l1bWwnOiAyMDcsXG4gICAgJ050aWxkZSc6IDIwOSxcbiAgICAnT2FjdXRlJzogMjExLFxuICAgICdPY2lyYyc6IDIxMixcbiAgICAnT2dyYXZlJzogMjEwLFxuICAgICdPc2xhc2gnOiAyMTYsXG4gICAgJ090aWxkZSc6IDIxMyxcbiAgICAnT3VtbCc6IDIxNCxcbiAgICAnVEhPUk4nOiAyMjIsXG4gICAgJ1VhY3V0ZSc6IDIxOCxcbiAgICAnVWNpcmMnOiAyMTksXG4gICAgJ1VncmF2ZSc6IDIxNyxcbiAgICAnVXVtbCc6IDIyMCxcbiAgICAnWWFjdXRlJzogMjIxLFxuICAgICdhYWN1dGUnOiAyMjUsXG4gICAgJ2FjaXJjJzogMjI2LFxuICAgICdhZWxpZyc6IDIzMCxcbiAgICAnYWdyYXZlJzogMjI0LFxuICAgICdhcmluZyc6IDIyOSxcbiAgICAnYXRpbGRlJzogMjI3LFxuICAgICdhdW1sJzogMjI4LFxuICAgICdjY2VkaWwnOiAyMzEsXG4gICAgJ2VhY3V0ZSc6IDIzMyxcbiAgICAnZWNpcmMnOiAyMzQsXG4gICAgJ2VncmF2ZSc6IDIzMixcbiAgICAnZXRoJzogMjQwLFxuICAgICdldW1sJzogMjM1LFxuICAgICdpYWN1dGUnOiAyMzcsXG4gICAgJ2ljaXJjJzogMjM4LFxuICAgICdpZ3JhdmUnOiAyMzYsXG4gICAgJ2l1bWwnOiAyMzksXG4gICAgJ250aWxkZSc6IDI0MSxcbiAgICAnb2FjdXRlJzogMjQzLFxuICAgICdvY2lyYyc6IDI0NCxcbiAgICAnb2dyYXZlJzogMjQyLFxuICAgICdvc2xhc2gnOiAyNDgsXG4gICAgJ290aWxkZSc6IDI0NSxcbiAgICAnb3VtbCc6IDI0NixcbiAgICAnc3psaWcnOiAyMjMsXG4gICAgJ3Rob3JuJzogMjU0LFxuICAgICd1YWN1dGUnOiAyNTAsXG4gICAgJ3VjaXJjJzogMjUxLFxuICAgICd1Z3JhdmUnOiAyNDksXG4gICAgJ3V1bWwnOiAyNTIsXG4gICAgJ3lhY3V0ZSc6IDI1MyxcbiAgICAneXVtbCc6IDI1NSxcbiAgICAnY29weSc6IDE2OSxcbiAgICAncmVnJzogMTc0LFxuICAgICduYnNwJzogMTYwLFxuICAgICdpZXhjbCc6IDE2MSxcbiAgICAnY2VudCc6IDE2MixcbiAgICAncG91bmQnOiAxNjMsXG4gICAgJ2N1cnJlbic6IDE2NCxcbiAgICAneWVuJzogMTY1LFxuICAgICdicnZiYXInOiAxNjYsXG4gICAgJ3NlY3QnOiAxNjcsXG4gICAgJ3VtbCc6IDE2OCxcbiAgICAnb3JkZic6IDE3MCxcbiAgICAnbGFxdW8nOiAxNzEsXG4gICAgJ25vdCc6IDE3MixcbiAgICAnc2h5JzogMTczLFxuICAgICdtYWNyJzogMTc1LFxuICAgICdkZWcnOiAxNzYsXG4gICAgJ3BsdXNtbic6IDE3NyxcbiAgICAnc3VwMSc6IDE4NSxcbiAgICAnc3VwMic6IDE3OCxcbiAgICAnc3VwMyc6IDE3OSxcbiAgICAnYWN1dGUnOiAxODAsXG4gICAgJ21pY3JvJzogMTgxLFxuICAgICdwYXJhJzogMTgyLFxuICAgICdtaWRkb3QnOiAxODMsXG4gICAgJ2NlZGlsJzogMTg0LFxuICAgICdvcmRtJzogMTg2LFxuICAgICdyYXF1byc6IDE4NyxcbiAgICAnZnJhYzE0JzogMTg4LFxuICAgICdmcmFjMTInOiAxODksXG4gICAgJ2ZyYWMzNCc6IDE5MCxcbiAgICAnaXF1ZXN0JzogMTkxLFxuICAgICd0aW1lcyc6IDIxNSxcbiAgICAnZGl2aWRlJzogMjQ3LFxuICAgICdPRWxpZyc6IDMzOCxcbiAgICAnb2VsaWcnOiAzMzksXG4gICAgJ1NjYXJvbic6IDM1MixcbiAgICAnc2Nhcm9uJzogMzUzLFxuICAgICdZdW1sJzogMzc2LFxuICAgICdmbm9mJzogNDAyLFxuICAgICdjaXJjJzogNzEwLFxuICAgICd0aWxkZSc6IDczMixcbiAgICAnQWxwaGEnOiA5MTMsXG4gICAgJ0JldGEnOiA5MTQsXG4gICAgJ0dhbW1hJzogOTE1LFxuICAgICdEZWx0YSc6IDkxNixcbiAgICAnRXBzaWxvbic6IDkxNyxcbiAgICAnWmV0YSc6IDkxOCxcbiAgICAnRXRhJzogOTE5LFxuICAgICdUaGV0YSc6IDkyMCxcbiAgICAnSW90YSc6IDkyMSxcbiAgICAnS2FwcGEnOiA5MjIsXG4gICAgJ0xhbWJkYSc6IDkyMyxcbiAgICAnTXUnOiA5MjQsXG4gICAgJ051JzogOTI1LFxuICAgICdYaSc6IDkyNixcbiAgICAnT21pY3Jvbic6IDkyNyxcbiAgICAnUGknOiA5MjgsXG4gICAgJ1Jobyc6IDkyOSxcbiAgICAnU2lnbWEnOiA5MzEsXG4gICAgJ1RhdSc6IDkzMixcbiAgICAnVXBzaWxvbic6IDkzMyxcbiAgICAnUGhpJzogOTM0LFxuICAgICdDaGknOiA5MzUsXG4gICAgJ1BzaSc6IDkzNixcbiAgICAnT21lZ2EnOiA5MzcsXG4gICAgJ2FscGhhJzogOTQ1LFxuICAgICdiZXRhJzogOTQ2LFxuICAgICdnYW1tYSc6IDk0NyxcbiAgICAnZGVsdGEnOiA5NDgsXG4gICAgJ2Vwc2lsb24nOiA5NDksXG4gICAgJ3pldGEnOiA5NTAsXG4gICAgJ2V0YSc6IDk1MSxcbiAgICAndGhldGEnOiA5NTIsXG4gICAgJ2lvdGEnOiA5NTMsXG4gICAgJ2thcHBhJzogOTU0LFxuICAgICdsYW1iZGEnOiA5NTUsXG4gICAgJ211JzogOTU2LFxuICAgICdudSc6IDk1NyxcbiAgICAneGknOiA5NTgsXG4gICAgJ29taWNyb24nOiA5NTksXG4gICAgJ3BpJzogOTYwLFxuICAgICdyaG8nOiA5NjEsXG4gICAgJ3NpZ21hZic6IDk2MixcbiAgICAnc2lnbWEnOiA5NjMsXG4gICAgJ3RhdSc6IDk2NCxcbiAgICAndXBzaWxvbic6IDk2NSxcbiAgICAncGhpJzogOTY2LFxuICAgICdjaGknOiA5NjcsXG4gICAgJ3BzaSc6IDk2OCxcbiAgICAnb21lZ2EnOiA5NjksXG4gICAgJ3RoZXRhc3ltJzogOTc3LFxuICAgICd1cHNpaCc6IDk3OCxcbiAgICAncGl2JzogOTgyLFxuICAgICdlbnNwJzogODE5NCxcbiAgICAnZW1zcCc6IDgxOTUsXG4gICAgJ3RoaW5zcCc6IDgyMDEsXG4gICAgJ3p3bmonOiA4MjA0LFxuICAgICd6d2onOiA4MjA1LFxuICAgICdscm0nOiA4MjA2LFxuICAgICdybG0nOiA4MjA3LFxuICAgICduZGFzaCc6IDgyMTEsXG4gICAgJ21kYXNoJzogODIxMixcbiAgICAnbHNxdW8nOiA4MjE2LFxuICAgICdyc3F1byc6IDgyMTcsXG4gICAgJ3NicXVvJzogODIxOCxcbiAgICAnbGRxdW8nOiA4MjIwLFxuICAgICdyZHF1byc6IDgyMjEsXG4gICAgJ2JkcXVvJzogODIyMixcbiAgICAnZGFnZ2VyJzogODIyNCxcbiAgICAnRGFnZ2VyJzogODIyNSxcbiAgICAnYnVsbCc6IDgyMjYsXG4gICAgJ2hlbGxpcCc6IDgyMzAsXG4gICAgJ3Blcm1pbCc6IDgyNDAsXG4gICAgJ3ByaW1lJzogODI0MixcbiAgICAnUHJpbWUnOiA4MjQzLFxuICAgICdsc2FxdW8nOiA4MjQ5LFxuICAgICdyc2FxdW8nOiA4MjUwLFxuICAgICdvbGluZSc6IDgyNTQsXG4gICAgJ2ZyYXNsJzogODI2MCxcbiAgICAnZXVybyc6IDgzNjQsXG4gICAgJ2ltYWdlJzogODQ2NSxcbiAgICAnd2VpZXJwJzogODQ3MixcbiAgICAncmVhbCc6IDg0NzYsXG4gICAgJ3RyYWRlJzogODQ4MixcbiAgICAnYWxlZnN5bSc6IDg1MDEsXG4gICAgJ2xhcnInOiA4NTkyLFxuICAgICd1YXJyJzogODU5MyxcbiAgICAncmFycic6IDg1OTQsXG4gICAgJ2RhcnInOiA4NTk1LFxuICAgICdoYXJyJzogODU5NixcbiAgICAnY3JhcnInOiA4NjI5LFxuICAgICdsQXJyJzogODY1NixcbiAgICAndUFycic6IDg2NTcsXG4gICAgJ3JBcnInOiA4NjU4LFxuICAgICdkQXJyJzogODY1OSxcbiAgICAnaEFycic6IDg2NjAsXG4gICAgJ2ZvcmFsbCc6IDg3MDQsXG4gICAgJ3BhcnQnOiA4NzA2LFxuICAgICdleGlzdCc6IDg3MDcsXG4gICAgJ2VtcHR5JzogODcwOSxcbiAgICAnbmFibGEnOiA4NzExLFxuICAgICdpc2luJzogODcxMixcbiAgICAnbm90aW4nOiA4NzEzLFxuICAgICduaSc6IDg3MTUsXG4gICAgJ3Byb2QnOiA4NzE5LFxuICAgICdzdW0nOiA4NzIxLFxuICAgICdtaW51cyc6IDg3MjIsXG4gICAgJ2xvd2FzdCc6IDg3MjcsXG4gICAgJ3JhZGljJzogODczMCxcbiAgICAncHJvcCc6IDg3MzMsXG4gICAgJ2luZmluJzogODczNCxcbiAgICAnYW5nJzogODczNixcbiAgICAnYW5kJzogODc0MyxcbiAgICAnb3InOiA4NzQ0LFxuICAgICdjYXAnOiA4NzQ1LFxuICAgICdjdXAnOiA4NzQ2LFxuICAgICdpbnQnOiA4NzQ3LFxuICAgICd0aGVyZTQnOiA4NzU2LFxuICAgICdzaW0nOiA4NzY0LFxuICAgICdjb25nJzogODc3MyxcbiAgICAnYXN5bXAnOiA4Nzc2LFxuICAgICduZSc6IDg4MDAsXG4gICAgJ2VxdWl2JzogODgwMSxcbiAgICAnbGUnOiA4ODA0LFxuICAgICdnZSc6IDg4MDUsXG4gICAgJ3N1Yic6IDg4MzQsXG4gICAgJ3N1cCc6IDg4MzUsXG4gICAgJ25zdWInOiA4ODM2LFxuICAgICdzdWJlJzogODgzOCxcbiAgICAnc3VwZSc6IDg4MzksXG4gICAgJ29wbHVzJzogODg1MyxcbiAgICAnb3RpbWVzJzogODg1NSxcbiAgICAncGVycCc6IDg4NjksXG4gICAgJ3Nkb3QnOiA4OTAxLFxuICAgICdsY2VpbCc6IDg5NjgsXG4gICAgJ3JjZWlsJzogODk2OSxcbiAgICAnbGZsb29yJzogODk3MCxcbiAgICAncmZsb29yJzogODk3MSxcbiAgICAnbGFuZyc6IDkwMDEsXG4gICAgJ3JhbmcnOiA5MDAyLFxuICAgICdsb3onOiA5Njc0LFxuICAgICdzcGFkZXMnOiA5ODI0LFxuICAgICdjbHVicyc6IDk4MjcsXG4gICAgJ2hlYXJ0cyc6IDk4MjksXG4gICAgJ2RpYW1zJzogOTgzMFxuICB9XG5cbiAgT2JqZWN0LmtleXMoc2F4LkVOVElUSUVTKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgZSA9IHNheC5FTlRJVElFU1trZXldXG4gICAgdmFyIHMgPSB0eXBlb2YgZSA9PT0gJ251bWJlcicgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpIDogZVxuICAgIHNheC5FTlRJVElFU1trZXldID0gc1xuICB9KVxuXG4gIGZvciAodmFyIHMgaW4gc2F4LlNUQVRFKSB7XG4gICAgc2F4LlNUQVRFW3NheC5TVEFURVtzXV0gPSBzXG4gIH1cblxuICAvLyBzaG9ydGhhbmRcbiAgUyA9IHNheC5TVEFURVxuXG4gIGZ1bmN0aW9uIGVtaXQgKHBhcnNlciwgZXZlbnQsIGRhdGEpIHtcbiAgICBwYXJzZXJbZXZlbnRdICYmIHBhcnNlcltldmVudF0oZGF0YSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXROb2RlIChwYXJzZXIsIG5vZGVUeXBlLCBkYXRhKSB7XG4gICAgaWYgKHBhcnNlci50ZXh0Tm9kZSkgY2xvc2VUZXh0KHBhcnNlcilcbiAgICBlbWl0KHBhcnNlciwgbm9kZVR5cGUsIGRhdGEpXG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZVRleHQgKHBhcnNlcikge1xuICAgIHBhcnNlci50ZXh0Tm9kZSA9IHRleHRvcHRzKHBhcnNlci5vcHQsIHBhcnNlci50ZXh0Tm9kZSlcbiAgICBpZiAocGFyc2VyLnRleHROb2RlKSBlbWl0KHBhcnNlciwgJ29udGV4dCcsIHBhcnNlci50ZXh0Tm9kZSlcbiAgICBwYXJzZXIudGV4dE5vZGUgPSAnJ1xuICB9XG5cbiAgZnVuY3Rpb24gdGV4dG9wdHMgKG9wdCwgdGV4dCkge1xuICAgIGlmIChvcHQudHJpbSkgdGV4dCA9IHRleHQudHJpbSgpXG4gICAgaWYgKG9wdC5ub3JtYWxpemUpIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xccysvZywgJyAnKVxuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICBmdW5jdGlvbiBlcnJvciAocGFyc2VyLCBlcikge1xuICAgIGNsb3NlVGV4dChwYXJzZXIpXG4gICAgaWYgKHBhcnNlci50cmFja1Bvc2l0aW9uKSB7XG4gICAgICBlciArPSAnXFxuTGluZTogJyArIHBhcnNlci5saW5lICtcbiAgICAgICAgJ1xcbkNvbHVtbjogJyArIHBhcnNlci5jb2x1bW4gK1xuICAgICAgICAnXFxuQ2hhcjogJyArIHBhcnNlci5jXG4gICAgfVxuICAgIGVyID0gbmV3IEVycm9yKGVyKVxuICAgIHBhcnNlci5lcnJvciA9IGVyXG4gICAgZW1pdChwYXJzZXIsICdvbmVycm9yJywgZXIpXG4gICAgcmV0dXJuIHBhcnNlclxuICB9XG5cbiAgZnVuY3Rpb24gZW5kIChwYXJzZXIpIHtcbiAgICBpZiAocGFyc2VyLnNhd1Jvb3QgJiYgIXBhcnNlci5jbG9zZWRSb290KSBzdHJpY3RGYWlsKHBhcnNlciwgJ1VuY2xvc2VkIHJvb3QgdGFnJylcbiAgICBpZiAoKHBhcnNlci5zdGF0ZSAhPT0gUy5CRUdJTikgJiZcbiAgICAgIChwYXJzZXIuc3RhdGUgIT09IFMuQkVHSU5fV0hJVEVTUEFDRSkgJiZcbiAgICAgIChwYXJzZXIuc3RhdGUgIT09IFMuVEVYVCkpIHtcbiAgICAgIGVycm9yKHBhcnNlciwgJ1VuZXhwZWN0ZWQgZW5kJylcbiAgICB9XG4gICAgY2xvc2VUZXh0KHBhcnNlcilcbiAgICBwYXJzZXIuYyA9ICcnXG4gICAgcGFyc2VyLmNsb3NlZCA9IHRydWVcbiAgICBlbWl0KHBhcnNlciwgJ29uZW5kJylcbiAgICBTQVhQYXJzZXIuY2FsbChwYXJzZXIsIHBhcnNlci5zdHJpY3QsIHBhcnNlci5vcHQpXG4gICAgcmV0dXJuIHBhcnNlclxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaWN0RmFpbCAocGFyc2VyLCBtZXNzYWdlKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJzZXIgIT09ICdvYmplY3QnIHx8ICEocGFyc2VyIGluc3RhbmNlb2YgU0FYUGFyc2VyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgY2FsbCB0byBzdHJpY3RGYWlsJylcbiAgICB9XG4gICAgaWYgKHBhcnNlci5zdHJpY3QpIHtcbiAgICAgIGVycm9yKHBhcnNlciwgbWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBuZXdUYWcgKHBhcnNlcikge1xuICAgIGlmICghcGFyc2VyLnN0cmljdCkgcGFyc2VyLnRhZ05hbWUgPSBwYXJzZXIudGFnTmFtZVtwYXJzZXIubG9vc2VDYXNlXSgpXG4gICAgdmFyIHBhcmVudCA9IHBhcnNlci50YWdzW3BhcnNlci50YWdzLmxlbmd0aCAtIDFdIHx8IHBhcnNlclxuICAgIHZhciB0YWcgPSBwYXJzZXIudGFnID0geyBuYW1lOiBwYXJzZXIudGFnTmFtZSwgYXR0cmlidXRlczoge30gfVxuXG4gICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuIGlmIHRhZyBjb250YWlscyBhbiB4bWxucz1cImZvb1wiIG9yIHhtbG5zOmZvbz1cImJhclwiXG4gICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgIHRhZy5ucyA9IHBhcmVudC5uc1xuICAgIH1cbiAgICBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGggPSAwXG4gICAgZW1pdE5vZGUocGFyc2VyLCAnb25vcGVudGFnc3RhcnQnLCB0YWcpXG4gIH1cblxuICBmdW5jdGlvbiBxbmFtZSAobmFtZSwgYXR0cmlidXRlKSB7XG4gICAgdmFyIGkgPSBuYW1lLmluZGV4T2YoJzonKVxuICAgIHZhciBxdWFsTmFtZSA9IGkgPCAwID8gWyAnJywgbmFtZSBdIDogbmFtZS5zcGxpdCgnOicpXG4gICAgdmFyIHByZWZpeCA9IHF1YWxOYW1lWzBdXG4gICAgdmFyIGxvY2FsID0gcXVhbE5hbWVbMV1cblxuICAgIC8vIDx4IFwieG1sbnNcIj1cImh0dHA6Ly9mb29cIj5cbiAgICBpZiAoYXR0cmlidXRlICYmIG5hbWUgPT09ICd4bWxucycpIHtcbiAgICAgIHByZWZpeCA9ICd4bWxucydcbiAgICAgIGxvY2FsID0gJydcbiAgICB9XG5cbiAgICByZXR1cm4geyBwcmVmaXg6IHByZWZpeCwgbG9jYWw6IGxvY2FsIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dHJpYiAocGFyc2VyKSB7XG4gICAgaWYgKCFwYXJzZXIuc3RyaWN0KSB7XG4gICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IHBhcnNlci5hdHRyaWJOYW1lW3BhcnNlci5sb29zZUNhc2VdKClcbiAgICB9XG5cbiAgICBpZiAocGFyc2VyLmF0dHJpYkxpc3QuaW5kZXhPZihwYXJzZXIuYXR0cmliTmFtZSkgIT09IC0xIHx8XG4gICAgICBwYXJzZXIudGFnLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkocGFyc2VyLmF0dHJpYk5hbWUpKSB7XG4gICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgdmFyIHFuID0gcW5hbWUocGFyc2VyLmF0dHJpYk5hbWUsIHRydWUpXG4gICAgICB2YXIgcHJlZml4ID0gcW4ucHJlZml4XG4gICAgICB2YXIgbG9jYWwgPSBxbi5sb2NhbFxuXG4gICAgICBpZiAocHJlZml4ID09PSAneG1sbnMnKSB7XG4gICAgICAgIC8vIG5hbWVzcGFjZSBiaW5kaW5nIGF0dHJpYnV0ZS4gcHVzaCB0aGUgYmluZGluZyBpbnRvIHNjb3BlXG4gICAgICAgIGlmIChsb2NhbCA9PT0gJ3htbCcgJiYgcGFyc2VyLmF0dHJpYlZhbHVlICE9PSBYTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsXG4gICAgICAgICAgICAneG1sOiBwcmVmaXggbXVzdCBiZSBib3VuZCB0byAnICsgWE1MX05BTUVTUEFDRSArICdcXG4nICtcbiAgICAgICAgICAgICdBY3R1YWw6ICcgKyBwYXJzZXIuYXR0cmliVmFsdWUpXG4gICAgICAgIH0gZWxzZSBpZiAobG9jYWwgPT09ICd4bWxucycgJiYgcGFyc2VyLmF0dHJpYlZhbHVlICE9PSBYTUxOU19OQU1FU1BBQ0UpIHtcbiAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlcixcbiAgICAgICAgICAgICd4bWxuczogcHJlZml4IG11c3QgYmUgYm91bmQgdG8gJyArIFhNTE5TX05BTUVTUEFDRSArICdcXG4nICtcbiAgICAgICAgICAgICdBY3R1YWw6ICcgKyBwYXJzZXIuYXR0cmliVmFsdWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRhZyA9IHBhcnNlci50YWdcbiAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyc2VyLnRhZ3NbcGFyc2VyLnRhZ3MubGVuZ3RoIC0gMV0gfHwgcGFyc2VyXG4gICAgICAgICAgaWYgKHRhZy5ucyA9PT0gcGFyZW50Lm5zKSB7XG4gICAgICAgICAgICB0YWcubnMgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5ucylcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFnLm5zW2xvY2FsXSA9IHBhcnNlci5hdHRyaWJWYWx1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGRlZmVyIG9uYXR0cmlidXRlIGV2ZW50cyB1bnRpbCBhbGwgYXR0cmlidXRlcyBoYXZlIGJlZW4gc2VlblxuICAgICAgLy8gc28gYW55IG5ldyBiaW5kaW5ncyBjYW4gdGFrZSBlZmZlY3QuIHByZXNlcnZlIGF0dHJpYnV0ZSBvcmRlclxuICAgICAgLy8gc28gZGVmZXJyZWQgZXZlbnRzIGNhbiBiZSBlbWl0dGVkIGluIGRvY3VtZW50IG9yZGVyXG4gICAgICBwYXJzZXIuYXR0cmliTGlzdC5wdXNoKFtwYXJzZXIuYXR0cmliTmFtZSwgcGFyc2VyLmF0dHJpYlZhbHVlXSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW4gbm9uLXhtbG5zIG1vZGUsIHdlIGNhbiBlbWl0IHRoZSBldmVudCByaWdodCBhd2F5XG4gICAgICBwYXJzZXIudGFnLmF0dHJpYnV0ZXNbcGFyc2VyLmF0dHJpYk5hbWVdID0gcGFyc2VyLmF0dHJpYlZhbHVlXG4gICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmF0dHJpYnV0ZScsIHtcbiAgICAgICAgbmFtZTogcGFyc2VyLmF0dHJpYk5hbWUsXG4gICAgICAgIHZhbHVlOiBwYXJzZXIuYXR0cmliVmFsdWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICB9XG5cbiAgZnVuY3Rpb24gb3BlblRhZyAocGFyc2VyLCBzZWxmQ2xvc2luZykge1xuICAgIGlmIChwYXJzZXIub3B0LnhtbG5zKSB7XG4gICAgICAvLyBlbWl0IG5hbWVzcGFjZSBiaW5kaW5nIGV2ZW50c1xuICAgICAgdmFyIHRhZyA9IHBhcnNlci50YWdcblxuICAgICAgLy8gYWRkIG5hbWVzcGFjZSBpbmZvIHRvIHRhZ1xuICAgICAgdmFyIHFuID0gcW5hbWUocGFyc2VyLnRhZ05hbWUpXG4gICAgICB0YWcucHJlZml4ID0gcW4ucHJlZml4XG4gICAgICB0YWcubG9jYWwgPSBxbi5sb2NhbFxuICAgICAgdGFnLnVyaSA9IHRhZy5uc1txbi5wcmVmaXhdIHx8ICcnXG5cbiAgICAgIGlmICh0YWcucHJlZml4ICYmICF0YWcudXJpKSB7XG4gICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5ib3VuZCBuYW1lc3BhY2UgcHJlZml4OiAnICtcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShwYXJzZXIudGFnTmFtZSkpXG4gICAgICAgIHRhZy51cmkgPSBxbi5wcmVmaXhcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudCA9IHBhcnNlci50YWdzW3BhcnNlci50YWdzLmxlbmd0aCAtIDFdIHx8IHBhcnNlclxuICAgICAgaWYgKHRhZy5ucyAmJiBwYXJlbnQubnMgIT09IHRhZy5ucykge1xuICAgICAgICBPYmplY3Qua2V5cyh0YWcubnMpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbm9wZW5uYW1lc3BhY2UnLCB7XG4gICAgICAgICAgICBwcmVmaXg6IHAsXG4gICAgICAgICAgICB1cmk6IHRhZy5uc1twXVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSBkZWZlcnJlZCBvbmF0dHJpYnV0ZSBldmVudHNcbiAgICAgIC8vIE5vdGU6IGRvIG5vdCBhcHBseSBkZWZhdWx0IG5zIHRvIGF0dHJpYnV0ZXM6XG4gICAgICAvLyAgIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwtbmFtZXMvI2RlZmF1bHRpbmdcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBudiA9IHBhcnNlci5hdHRyaWJMaXN0W2ldXG4gICAgICAgIHZhciBuYW1lID0gbnZbMF1cbiAgICAgICAgdmFyIHZhbHVlID0gbnZbMV1cbiAgICAgICAgdmFyIHF1YWxOYW1lID0gcW5hbWUobmFtZSwgdHJ1ZSlcbiAgICAgICAgdmFyIHByZWZpeCA9IHF1YWxOYW1lLnByZWZpeFxuICAgICAgICB2YXIgbG9jYWwgPSBxdWFsTmFtZS5sb2NhbFxuICAgICAgICB2YXIgdXJpID0gcHJlZml4ID09PSAnJyA/ICcnIDogKHRhZy5uc1twcmVmaXhdIHx8ICcnKVxuICAgICAgICB2YXIgYSA9IHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgICAgICBsb2NhbDogbG9jYWwsXG4gICAgICAgICAgdXJpOiB1cmlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlJ3MgYW55IGF0dHJpYnV0ZXMgd2l0aCBhbiB1bmRlZmluZWQgbmFtZXNwYWNlLFxuICAgICAgICAvLyB0aGVuIGZhaWwgb24gdGhlbSBub3cuXG4gICAgICAgIGlmIChwcmVmaXggJiYgcHJlZml4ICE9PSAneG1sbnMnICYmICF1cmkpIHtcbiAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VuYm91bmQgbmFtZXNwYWNlIHByZWZpeDogJyArXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShwcmVmaXgpKVxuICAgICAgICAgIGEudXJpID0gcHJlZml4XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzW25hbWVdID0gYVxuICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmF0dHJpYnV0ZScsIGEpXG4gICAgICB9XG4gICAgICBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGggPSAwXG4gICAgfVxuXG4gICAgcGFyc2VyLnRhZy5pc1NlbGZDbG9zaW5nID0gISFzZWxmQ2xvc2luZ1xuXG4gICAgLy8gcHJvY2VzcyB0aGUgdGFnXG4gICAgcGFyc2VyLnNhd1Jvb3QgPSB0cnVlXG4gICAgcGFyc2VyLnRhZ3MucHVzaChwYXJzZXIudGFnKVxuICAgIGVtaXROb2RlKHBhcnNlciwgJ29ub3BlbnRhZycsIHBhcnNlci50YWcpXG4gICAgaWYgKCFzZWxmQ2xvc2luZykge1xuICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciA8c2NyaXB0PiBpbiBub24tc3RyaWN0IG1vZGUuXG4gICAgICBpZiAoIXBhcnNlci5ub3NjcmlwdCAmJiBwYXJzZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc2NyaXB0Jykge1xuICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICB9XG4gICAgICBwYXJzZXIudGFnID0gbnVsbFxuICAgICAgcGFyc2VyLnRhZ05hbWUgPSAnJ1xuICAgIH1cbiAgICBwYXJzZXIuYXR0cmliTmFtZSA9IHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gICAgcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoID0gMFxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VUYWcgKHBhcnNlcikge1xuICAgIGlmICghcGFyc2VyLnRhZ05hbWUpIHtcbiAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnV2VpcmQgZW1wdHkgY2xvc2UgdGFnLicpXG4gICAgICBwYXJzZXIudGV4dE5vZGUgKz0gJzwvPidcbiAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHBhcnNlci5zY3JpcHQpIHtcbiAgICAgIGlmIChwYXJzZXIudGFnTmFtZSAhPT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgcGFyc2VyLnNjcmlwdCArPSAnPC8nICsgcGFyc2VyLnRhZ05hbWUgKyAnPidcbiAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSAnJ1xuICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVFxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uc2NyaXB0JywgcGFyc2VyLnNjcmlwdClcbiAgICAgIHBhcnNlci5zY3JpcHQgPSAnJ1xuICAgIH1cblxuICAgIC8vIGZpcnN0IG1ha2Ugc3VyZSB0aGF0IHRoZSBjbG9zaW5nIHRhZyBhY3R1YWxseSBleGlzdHMuXG4gICAgLy8gPGE+PGI+PC9jPjwvYj48L2E+IHdpbGwgY2xvc2UgZXZlcnl0aGluZywgb3RoZXJ3aXNlLlxuICAgIHZhciB0ID0gcGFyc2VyLnRhZ3MubGVuZ3RoXG4gICAgdmFyIHRhZ05hbWUgPSBwYXJzZXIudGFnTmFtZVxuICAgIGlmICghcGFyc2VyLnN0cmljdCkge1xuICAgICAgdGFnTmFtZSA9IHRhZ05hbWVbcGFyc2VyLmxvb3NlQ2FzZV0oKVxuICAgIH1cbiAgICB2YXIgY2xvc2VUbyA9IHRhZ05hbWVcbiAgICB3aGlsZSAodC0tKSB7XG4gICAgICB2YXIgY2xvc2UgPSBwYXJzZXIudGFnc1t0XVxuICAgICAgaWYgKGNsb3NlLm5hbWUgIT09IGNsb3NlVG8pIHtcbiAgICAgICAgLy8gZmFpbCB0aGUgZmlyc3QgdGltZSBpbiBzdHJpY3QgbW9kZVxuICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VuZXhwZWN0ZWQgY2xvc2UgdGFnJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGlkbid0IGZpbmQgaXQuICB3ZSBhbHJlYWR5IGZhaWxlZCBmb3Igc3RyaWN0LCBzbyBqdXN0IGFib3J0LlxuICAgIGlmICh0IDwgMCkge1xuICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbm1hdGNoZWQgY2xvc2luZyB0YWc6ICcgKyBwYXJzZXIudGFnTmFtZSlcbiAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSAnPC8nICsgcGFyc2VyLnRhZ05hbWUgKyAnPidcbiAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHBhcnNlci50YWdOYW1lID0gdGFnTmFtZVxuICAgIHZhciBzID0gcGFyc2VyLnRhZ3MubGVuZ3RoXG4gICAgd2hpbGUgKHMtLSA+IHQpIHtcbiAgICAgIHZhciB0YWcgPSBwYXJzZXIudGFnID0gcGFyc2VyLnRhZ3MucG9wKClcbiAgICAgIHBhcnNlci50YWdOYW1lID0gcGFyc2VyLnRhZy5uYW1lXG4gICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNsb3NldGFnJywgcGFyc2VyLnRhZ05hbWUpXG5cbiAgICAgIHZhciB4ID0ge31cbiAgICAgIGZvciAodmFyIGkgaW4gdGFnLm5zKSB7XG4gICAgICAgIHhbaV0gPSB0YWcubnNbaV1cbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudCA9IHBhcnNlci50YWdzW3BhcnNlci50YWdzLmxlbmd0aCAtIDFdIHx8IHBhcnNlclxuICAgICAgaWYgKHBhcnNlci5vcHQueG1sbnMgJiYgdGFnLm5zICE9PSBwYXJlbnQubnMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIG5hbWVzcGFjZSBiaW5kaW5ncyBpbnRyb2R1Y2VkIGJ5IHRhZ1xuICAgICAgICBPYmplY3Qua2V5cyh0YWcubnMpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICB2YXIgbiA9IHRhZy5uc1twXVxuICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2xvc2VuYW1lc3BhY2UnLCB7IHByZWZpeDogcCwgdXJpOiBuIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ID09PSAwKSBwYXJzZXIuY2xvc2VkUm9vdCA9IHRydWVcbiAgICBwYXJzZXIudGFnTmFtZSA9IHBhcnNlci5hdHRyaWJWYWx1ZSA9IHBhcnNlci5hdHRyaWJOYW1lID0gJydcbiAgICBwYXJzZXIuYXR0cmliTGlzdC5sZW5ndGggPSAwXG4gICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVudGl0eSAocGFyc2VyKSB7XG4gICAgdmFyIGVudGl0eSA9IHBhcnNlci5lbnRpdHlcbiAgICB2YXIgZW50aXR5TEMgPSBlbnRpdHkudG9Mb3dlckNhc2UoKVxuICAgIHZhciBudW1cbiAgICB2YXIgbnVtU3RyID0gJydcblxuICAgIGlmIChwYXJzZXIuRU5USVRJRVNbZW50aXR5XSkge1xuICAgICAgcmV0dXJuIHBhcnNlci5FTlRJVElFU1tlbnRpdHldXG4gICAgfVxuICAgIGlmIChwYXJzZXIuRU5USVRJRVNbZW50aXR5TENdKSB7XG4gICAgICByZXR1cm4gcGFyc2VyLkVOVElUSUVTW2VudGl0eUxDXVxuICAgIH1cbiAgICBlbnRpdHkgPSBlbnRpdHlMQ1xuICAgIGlmIChlbnRpdHkuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgIGlmIChlbnRpdHkuY2hhckF0KDEpID09PSAneCcpIHtcbiAgICAgICAgZW50aXR5ID0gZW50aXR5LnNsaWNlKDIpXG4gICAgICAgIG51bSA9IHBhcnNlSW50KGVudGl0eSwgMTYpXG4gICAgICAgIG51bVN0ciA9IG51bS50b1N0cmluZygxNilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudGl0eSA9IGVudGl0eS5zbGljZSgxKVxuICAgICAgICBudW0gPSBwYXJzZUludChlbnRpdHksIDEwKVxuICAgICAgICBudW1TdHIgPSBudW0udG9TdHJpbmcoMTApXG4gICAgICB9XG4gICAgfVxuICAgIGVudGl0eSA9IGVudGl0eS5yZXBsYWNlKC9eMCsvLCAnJylcbiAgICBpZiAobnVtU3RyLnRvTG93ZXJDYXNlKCkgIT09IGVudGl0eSkge1xuICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGNoYXJhY3RlciBlbnRpdHknKVxuICAgICAgcmV0dXJuICcmJyArIHBhcnNlci5lbnRpdHkgKyAnOydcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQobnVtKVxuICB9XG5cbiAgZnVuY3Rpb24gYmVnaW5XaGl0ZVNwYWNlIChwYXJzZXIsIGMpIHtcbiAgICBpZiAoYyA9PT0gJzwnKSB7XG4gICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fV0FLQVxuICAgICAgcGFyc2VyLnN0YXJ0VGFnUG9zaXRpb24gPSBwYXJzZXIucG9zaXRpb25cbiAgICB9IGVsc2UgaWYgKG5vdCh3aGl0ZXNwYWNlLCBjKSkge1xuICAgICAgLy8gaGF2ZSB0byBwcm9jZXNzIHRoaXMgYXMgYSB0ZXh0IG5vZGUuXG4gICAgICAvLyB3ZWlyZCwgYnV0IGhhcHBlbnMuXG4gICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ05vbi13aGl0ZXNwYWNlIGJlZm9yZSBmaXJzdCB0YWcuJylcbiAgICAgIHBhcnNlci50ZXh0Tm9kZSA9IGNcbiAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYXJBdCAoY2h1bmssIGkpIHtcbiAgICB2YXIgcmVzdWx0ID0gJydcbiAgICBpZiAoaSA8IGNodW5rLmxlbmd0aCkge1xuICAgICAgcmVzdWx0ID0gY2h1bmsuY2hhckF0KGkpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyaXRlIChjaHVuaykge1xuICAgIHZhciBwYXJzZXIgPSB0aGlzXG4gICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuZXJyb3JcbiAgICB9XG4gICAgaWYgKHBhcnNlci5jbG9zZWQpIHtcbiAgICAgIHJldHVybiBlcnJvcihwYXJzZXIsXG4gICAgICAgICdDYW5ub3Qgd3JpdGUgYWZ0ZXIgY2xvc2UuIEFzc2lnbiBhbiBvbnJlYWR5IGhhbmRsZXIuJylcbiAgICB9XG4gICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZW5kKHBhcnNlcilcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNodW5rID0gY2h1bmsudG9TdHJpbmcoKVxuICAgIH1cbiAgICB2YXIgaSA9IDBcbiAgICB2YXIgYyA9ICcnXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGMgPSBjaGFyQXQoY2h1bmssIGkrKylcbiAgICAgIHBhcnNlci5jID0gY1xuICAgICAgaWYgKCFjKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAocGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgICAgcGFyc2VyLnBvc2l0aW9uKytcbiAgICAgICAgaWYgKGMgPT09ICdcXG4nKSB7XG4gICAgICAgICAgcGFyc2VyLmxpbmUrK1xuICAgICAgICAgIHBhcnNlci5jb2x1bW4gPSAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyc2VyLmNvbHVtbisrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN3aXRjaCAocGFyc2VyLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgUy5CRUdJTjpcbiAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkJFR0lOX1dISVRFU1BBQ0VcbiAgICAgICAgICBpZiAoYyA9PT0gJ1xcdUZFRkYnKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBiZWdpbldoaXRlU3BhY2UocGFyc2VyLCBjKVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkJFR0lOX1dISVRFU1BBQ0U6XG4gICAgICAgICAgYmVnaW5XaGl0ZVNwYWNlKHBhcnNlciwgYylcbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5URVhUOlxuICAgICAgICAgIGlmIChwYXJzZXIuc2F3Um9vdCAmJiAhcGFyc2VyLmNsb3NlZFJvb3QpIHtcbiAgICAgICAgICAgIHZhciBzdGFydGkgPSBpIC0gMVxuICAgICAgICAgICAgd2hpbGUgKGMgJiYgYyAhPT0gJzwnICYmIGMgIT09ICcmJykge1xuICAgICAgICAgICAgICBjID0gY2hhckF0KGNodW5rLCBpKyspXG4gICAgICAgICAgICAgIGlmIChjICYmIHBhcnNlci50cmFja1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnBvc2l0aW9uKytcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5saW5lKytcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5jb2x1bW4gPSAwXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlci5jb2x1bW4rK1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLnRleHROb2RlICs9IGNodW5rLnN1YnN0cmluZyhzdGFydGksIGkgLSAxKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYyA9PT0gJzwnICYmICEocGFyc2VyLnNhd1Jvb3QgJiYgcGFyc2VyLmNsb3NlZFJvb3QgJiYgIXBhcnNlci5zdHJpY3QpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fV0FLQVxuICAgICAgICAgICAgcGFyc2VyLnN0YXJ0VGFnUG9zaXRpb24gPSBwYXJzZXIucG9zaXRpb25cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5vdCh3aGl0ZXNwYWNlLCBjKSAmJiAoIXBhcnNlci5zYXdSb290IHx8IHBhcnNlci5jbG9zZWRSb290KSkge1xuICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1RleHQgZGF0YSBvdXRzaWRlIG9mIHJvb3Qgbm9kZS4nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICcmJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRfRU5USVRZXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gY1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5TQ1JJUFQ6XG4gICAgICAgICAgLy8gb25seSBub24tc3RyaWN0XG4gICAgICAgICAgaWYgKGMgPT09ICc8Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5TQ1JJUFRfRU5ESU5HOlxuICAgICAgICAgIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0xPU0VfVEFHXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gJzwnICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuT1BFTl9XQUtBOlxuICAgICAgICAgIC8vIGVpdGhlciBhIC8sID8sICEsIG9yIHRleHQgaXMgY29taW5nIG5leHQuXG4gICAgICAgICAgaWYgKGMgPT09ICchJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TR01MX0RFQ0xcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmIChpcyh3aGl0ZXNwYWNlLCBjKSkge1xuICAgICAgICAgICAgLy8gd2FpdCBmb3IgaXQuLi5cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzKG5hbWVTdGFydCwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gY1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNMT1NFX1RBR1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSAnJ1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVFxuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0TmFtZSA9IHBhcnNlci5wcm9jSW5zdEJvZHkgPSAnJ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VuZW5jb2RlZCA8JylcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBzb21lIHdoaXRlc3BhY2UsIHRoZW4gYWRkIHRoYXQgaW4uXG4gICAgICAgICAgICBpZiAocGFyc2VyLnN0YXJ0VGFnUG9zaXRpb24gKyAxIDwgcGFyc2VyLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSBwYXJzZXIucG9zaXRpb24gLSBwYXJzZXIuc3RhcnRUYWdQb3NpdGlvblxuICAgICAgICAgICAgICBjID0gbmV3IEFycmF5KHBhZCkuam9pbignICcpICsgY1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLnRleHROb2RlICs9ICc8JyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5TR01MX0RFQ0w6XG4gICAgICAgICAgaWYgKChwYXJzZXIuc2dtbERlY2wgKyBjKS50b1VwcGVyQ2FzZSgpID09PSBDREFUQSkge1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25vcGVuY2RhdGEnKVxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQVxuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJzZXIuc2dtbERlY2wgKyBjID09PSAnLS0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmICgocGFyc2VyLnNnbWxEZWNsICsgYykudG9VcHBlckNhc2UoKSA9PT0gRE9DVFlQRSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFXG4gICAgICAgICAgICBpZiAocGFyc2VyLmRvY3R5cGUgfHwgcGFyc2VyLnNhd1Jvb3QpIHtcbiAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsXG4gICAgICAgICAgICAgICAgJ0luYXBwcm9wcmlhdGVseSBsb2NhdGVkIGRvY3R5cGUgZGVjbGFyYXRpb24nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLmRvY3R5cGUgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25zZ21sZGVjbGFyYXRpb24nLCBwYXJzZXIuc2dtbERlY2wpXG4gICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfSBlbHNlIGlmIChpcyhxdW90ZSwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0dNTF9ERUNMX1FVT1RFRFxuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsICs9IGNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuU0dNTF9ERUNMX1FVT1RFRDpcbiAgICAgICAgICBpZiAoYyA9PT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0dNTF9ERUNMXG4gICAgICAgICAgICBwYXJzZXIucSA9ICcnXG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuRE9DVFlQRTpcbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uZG9jdHlwZScsIHBhcnNlci5kb2N0eXBlKVxuICAgICAgICAgICAgcGFyc2VyLmRvY3R5cGUgPSB0cnVlIC8vIGp1c3QgcmVtZW1iZXIgdGhhdCB3ZSBzYXcgaXQuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGNcbiAgICAgICAgICAgIGlmIChjID09PSAnWycpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURFxuICAgICAgICAgICAgfSBlbHNlIGlmIChpcyhxdW90ZSwgYykpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX1FVT1RFRFxuICAgICAgICAgICAgICBwYXJzZXIucSA9IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuRE9DVFlQRV9RVU9URUQ6XG4gICAgICAgICAgcGFyc2VyLmRvY3R5cGUgKz0gY1xuICAgICAgICAgIGlmIChjID09PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkRPQ1RZUEVfRFREOlxuICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGNcbiAgICAgICAgICBpZiAoYyA9PT0gJ10nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzKHF1b3RlLCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURF9RVU9URURcbiAgICAgICAgICAgIHBhcnNlci5xID0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5ET0NUWVBFX0RURF9RVU9URUQ6XG4gICAgICAgICAgcGFyc2VyLmRvY3R5cGUgKz0gY1xuICAgICAgICAgIGlmIChjID09PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURFxuICAgICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DT01NRU5UOlxuICAgICAgICAgIGlmIChjID09PSAnLScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DT01NRU5UX0VORElORzpcbiAgICAgICAgICBpZiAoYyA9PT0gJy0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRfRU5ERURcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gdGV4dG9wdHMocGFyc2VyLm9wdCwgcGFyc2VyLmNvbW1lbnQpXG4gICAgICAgICAgICBpZiAocGFyc2VyLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jb21tZW50JywgcGFyc2VyLmNvbW1lbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCA9ICcnXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ICs9ICctJyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DT01NRU5UX0VOREVEOlxuICAgICAgICAgIGlmIChjICE9PSAnPicpIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnTWFsZm9ybWVkIGNvbW1lbnQnKVxuICAgICAgICAgICAgLy8gYWxsb3cgPCEtLSBibGFoIC0tIGJsb28gLS0+IGluIG5vbi1zdHJpY3QgbW9kZSxcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIGEgY29tbWVudCBvZiBcIiBibGFoIC0tIGJsb28gXCJcbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ICs9ICctLScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNPTU1FTlRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNEQVRBOlxuICAgICAgICAgIGlmIChjID09PSAnXScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEFfRU5ESU5HXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNEQVRBX0VORElORzpcbiAgICAgICAgICBpZiAoYyA9PT0gJ10nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBX0VORElOR18yXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSAnXScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNEQVRBX0VORElOR18yOlxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIGlmIChwYXJzZXIuY2RhdGEpIHtcbiAgICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jZGF0YScsIHBhcnNlci5jZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uY2xvc2VjZGF0YScpXG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnXScpIHtcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSArPSAnXSdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNkYXRhICs9ICddXScgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlBST0NfSU5TVDpcbiAgICAgICAgICBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9CT0RZXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdE5hbWUgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5QUk9DX0lOU1RfQk9EWTpcbiAgICAgICAgICBpZiAoIXBhcnNlci5wcm9jSW5zdEJvZHkgJiYgaXMod2hpdGVzcGFjZSwgYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuUFJPQ19JTlNUX0VORElOR1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIucHJvY0luc3RCb2R5ICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuUFJPQ19JTlNUX0VORElORzpcbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnByb2Nlc3NpbmdpbnN0cnVjdGlvbicsIHtcbiAgICAgICAgICAgICAgbmFtZTogcGFyc2VyLnByb2NJbnN0TmFtZSxcbiAgICAgICAgICAgICAgYm9keTogcGFyc2VyLnByb2NJbnN0Qm9keVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdE5hbWUgPSBwYXJzZXIucHJvY0luc3RCb2R5ID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIucHJvY0luc3RCb2R5ICs9ICc/JyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuUFJPQ19JTlNUX0JPRFlcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuT1BFTl9UQUc6XG4gICAgICAgICAgaWYgKGlzKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgKz0gY1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdUYWcocGFyc2VyKVxuICAgICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdfU0xBU0hcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChub3Qod2hpdGVzcGFjZSwgYykpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgY2hhcmFjdGVyIGluIHRhZyBuYW1lJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5PUEVOX1RBR19TTEFTSDpcbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBvcGVuVGFnKHBhcnNlciwgdHJ1ZSlcbiAgICAgICAgICAgIGNsb3NlVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdGb3J3YXJkLXNsYXNoIGluIG9wZW5pbmcgdGFnIG5vdCBmb2xsb3dlZCBieSA+JylcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQjpcbiAgICAgICAgICAvLyBoYXZlbid0IHJlYWQgdGhlIGF0dHJpYnV0ZSBuYW1lIHlldC5cbiAgICAgICAgICBpZiAoaXMod2hpdGVzcGFjZSwgYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fVEFHX1NMQVNIXG4gICAgICAgICAgfSBlbHNlIGlmIChpcyhuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IGNcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZScpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9OQU1FOlxuICAgICAgICAgIGlmIChjID09PSAnPScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnQXR0cmlidXRlIHdpdGhvdXQgdmFsdWUnKVxuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gcGFyc2VyLmF0dHJpYk5hbWVcbiAgICAgICAgICAgIGF0dHJpYihwYXJzZXIpXG4gICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FX1NBV19XSElURVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXMobmFtZUJvZHksIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSArPSBjXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZScpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9OQU1FX1NBV19XSElURTpcbiAgICAgICAgICBpZiAoYyA9PT0gJz0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXMod2hpdGVzcGFjZSwgYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnQXR0cmlidXRlIHdpdGhvdXQgdmFsdWUnKVxuICAgICAgICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzW3BhcnNlci5hdHRyaWJOYW1lXSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25hdHRyaWJ1dGUnLCB7XG4gICAgICAgICAgICAgIG5hbWU6IHBhcnNlci5hdHRyaWJOYW1lLFxuICAgICAgICAgICAgICB2YWx1ZTogJydcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9ICcnXG4gICAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpcyhuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gY1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWUnKVxuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUU6XG4gICAgICAgICAgaWYgKGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXMocXVvdGUsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIucSA9IGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1FVT1RFRFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZScpXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9VTlFVT1RFRFxuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfUVVPVEVEOlxuICAgICAgICAgIGlmIChjICE9PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgaWYgKGMgPT09ICcmJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlICs9IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYihwYXJzZXIpXG4gICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX0NMT1NFRFxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9DTE9TRUQ6XG4gICAgICAgICAgaWYgKGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQlxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1RBR19TTEFTSFxuICAgICAgICAgIH0gZWxzZSBpZiAoaXMobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdObyB3aGl0ZXNwYWNlIGJldHdlZW4gYXR0cmlidXRlcycpXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IGNcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZScpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9VTlFVT1RFRDpcbiAgICAgICAgICBpZiAobm90KGF0dHJpYkVuZCwgYykpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAnJicpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVfRU5USVRZX1VcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSArPSBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyaWIocGFyc2VyKVxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIG9wZW5UYWcocGFyc2VyKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQlxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DTE9TRV9UQUc6XG4gICAgICAgICAgaWYgKCFwYXJzZXIudGFnTmFtZSkge1xuICAgICAgICAgICAgaWYgKGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vdChuYW1lU3RhcnQsIGMpKSB7XG4gICAgICAgICAgICAgIGlmIChwYXJzZXIuc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSAnPC8nICsgY1xuICAgICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIHRhZ25hbWUgaW4gY2xvc2luZyB0YWcuJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIGNsb3NlVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgKz0gY1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VyLnNjcmlwdCkge1xuICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSAnPC8nICsgcGFyc2VyLnRhZ05hbWVcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChub3Qod2hpdGVzcGFjZSwgYykpIHtcbiAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIHRhZ25hbWUgaW4gY2xvc2luZyB0YWcnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DTE9TRV9UQUdfU0FXX1dISVRFXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNMT1NFX1RBR19TQVdfV0hJVEU6XG4gICAgICAgICAgaWYgKGlzKHdoaXRlc3BhY2UsIGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBjbG9zZVRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBjaGFyYWN0ZXJzIGluIGNsb3NpbmcgdGFnJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuVEVYVF9FTlRJVFk6XG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1E6XG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1U6XG4gICAgICAgICAgdmFyIHJldHVyblN0YXRlXG4gICAgICAgICAgdmFyIGJ1ZmZlclxuICAgICAgICAgIHN3aXRjaCAocGFyc2VyLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFMuVEVYVF9FTlRJVFk6XG4gICAgICAgICAgICAgIHJldHVyblN0YXRlID0gUy5URVhUXG4gICAgICAgICAgICAgIGJ1ZmZlciA9ICd0ZXh0Tm9kZSdcbiAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUTpcbiAgICAgICAgICAgICAgcmV0dXJuU3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9RVU9URURcbiAgICAgICAgICAgICAgYnVmZmVyID0gJ2F0dHJpYlZhbHVlJ1xuICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0VOVElUWV9VOlxuICAgICAgICAgICAgICByZXR1cm5TdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1VOUVVPVEVEXG4gICAgICAgICAgICAgIGJ1ZmZlciA9ICdhdHRyaWJWYWx1ZSdcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYyA9PT0gJzsnKSB7XG4gICAgICAgICAgICBwYXJzZXJbYnVmZmVyXSArPSBwYXJzZUVudGl0eShwYXJzZXIpXG4gICAgICAgICAgICBwYXJzZXIuZW50aXR5ID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IHJldHVyblN0YXRlXG4gICAgICAgICAgfSBlbHNlIGlmIChpcyhwYXJzZXIuZW50aXR5Lmxlbmd0aCA/IGVudGl0eUJvZHkgOiBlbnRpdHlTdGFydCwgYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5lbnRpdHkgKz0gY1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgY2hhcmFjdGVyIGluIGVudGl0eSBuYW1lJylcbiAgICAgICAgICAgIHBhcnNlcltidWZmZXJdICs9ICcmJyArIHBhcnNlci5lbnRpdHkgKyBjXG4gICAgICAgICAgICBwYXJzZXIuZW50aXR5ID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IHJldHVyblN0YXRlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwYXJzZXIsICdVbmtub3duIHN0YXRlOiAnICsgcGFyc2VyLnN0YXRlKVxuICAgICAgfVxuICAgIH0gLy8gd2hpbGVcblxuICAgIGlmIChwYXJzZXIucG9zaXRpb24gPj0gcGFyc2VyLmJ1ZmZlckNoZWNrUG9zaXRpb24pIHtcbiAgICAgIGNoZWNrQnVmZmVyTGVuZ3RoKHBhcnNlcilcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlclxuICB9XG5cbiAgLyohIGh0dHA6Ly9tdGhzLmJlL2Zyb21jb2RlcG9pbnQgdjAuMS4wIGJ5IEBtYXRoaWFzICovXG4gIGlmICghU3RyaW5nLmZyb21Db2RlUG9pbnQpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3JcbiAgICAgIHZhciBmcm9tQ29kZVBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgTUFYX1NJWkUgPSAweDQwMDBcbiAgICAgICAgdmFyIGNvZGVVbml0cyA9IFtdXG4gICAgICAgIHZhciBoaWdoU3Vycm9nYXRlXG4gICAgICAgIHZhciBsb3dTdXJyb2dhdGVcbiAgICAgICAgdmFyIGluZGV4ID0gLTFcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gJydcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgY29kZVBvaW50ID0gTnVtYmVyKGFyZ3VtZW50c1tpbmRleF0pXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWlzRmluaXRlKGNvZGVQb2ludCkgfHwgLy8gYE5hTmAsIGArSW5maW5pdHlgLCBvciBgLUluZmluaXR5YFxuICAgICAgICAgICAgY29kZVBvaW50IDwgMCB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgIGNvZGVQb2ludCA+IDB4MTBGRkZGIHx8IC8vIG5vdCBhIHZhbGlkIFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgICAgZmxvb3IoY29kZVBvaW50KSAhPT0gY29kZVBvaW50IC8vIG5vdCBhbiBpbnRlZ2VyXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQ6ICcgKyBjb2RlUG9pbnQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhGRkZGKSB7IC8vIEJNUCBjb2RlIHBvaW50XG4gICAgICAgICAgICBjb2RlVW5pdHMucHVzaChjb2RlUG9pbnQpXG4gICAgICAgICAgfSBlbHNlIHsgLy8gQXN0cmFsIGNvZGUgcG9pbnQ7IHNwbGl0IGluIHN1cnJvZ2F0ZSBoYWx2ZXNcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG4gICAgICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgICAgICAgaGlnaFN1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgPj4gMTApICsgMHhEODAwXG4gICAgICAgICAgICBsb3dTdXJyb2dhdGUgPSAoY29kZVBvaW50ICUgMHg0MDApICsgMHhEQzAwXG4gICAgICAgICAgICBjb2RlVW5pdHMucHVzaChoaWdoU3Vycm9nYXRlLCBsb3dTdXJyb2dhdGUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmRleCArIDEgPT09IGxlbmd0aCB8fCBjb2RlVW5pdHMubGVuZ3RoID4gTUFYX1NJWkUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmdGcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY29kZVVuaXRzKVxuICAgICAgICAgICAgY29kZVVuaXRzLmxlbmd0aCA9IDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaW5nLCAnZnJvbUNvZGVQb2ludCcsIHtcbiAgICAgICAgICB2YWx1ZTogZnJvbUNvZGVQb2ludCxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFN0cmluZy5mcm9tQ29kZVBvaW50ID0gZnJvbUNvZGVQb2ludFxuICAgICAgfVxuICAgIH0oKSlcbiAgfVxufSkodHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gdGhpcy5zYXggPSB7fSA6IGV4cG9ydHMpXG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOS4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxBdHRyaWJ1dGUsIGNyZWF0ZTtcblxuICBjcmVhdGUgPSByZXF1aXJlKCdsb2Rhc2gvY3JlYXRlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxBdHRyaWJ1dGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gWE1MQXR0cmlidXRlKHBhcmVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuc3RyaW5naWZ5ID0gcGFyZW50LnN0cmluZ2lmeTtcbiAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGUgbmFtZSBvZiBlbGVtZW50IFwiICsgcGFyZW50Lm5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhdHRyaWJ1dGUgdmFsdWUgZm9yIGF0dHJpYnV0ZSBcIiArIG5hbWUgKyBcIiBvZiBlbGVtZW50IFwiICsgcGFyZW50Lm5hbWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5uYW1lID0gdGhpcy5zdHJpbmdpZnkuYXR0TmFtZShuYW1lKTtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnN0cmluZ2lmeS5hdHRWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgWE1MQXR0cmlidXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZShYTUxBdHRyaWJ1dGUucHJvdG90eXBlLCB0aGlzKTtcbiAgICB9O1xuXG4gICAgWE1MQXR0cmlidXRlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGxldmVsKSB7XG4gICAgICByZXR1cm4gJyAnICsgdGhpcy5uYW1lICsgJz1cIicgKyB0aGlzLnZhbHVlICsgJ1wiJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTEF0dHJpYnV0ZTtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQnVpbGRlciwgWE1MRGVjbGFyYXRpb24sIFhNTERvY1R5cGUsIFhNTEVsZW1lbnQsIFhNTFN0cmluZ2lmaWVyO1xuXG4gIFhNTFN0cmluZ2lmaWVyID0gcmVxdWlyZSgnLi9YTUxTdHJpbmdpZmllcicpO1xuXG4gIFhNTERlY2xhcmF0aW9uID0gcmVxdWlyZSgnLi9YTUxEZWNsYXJhdGlvbicpO1xuXG4gIFhNTERvY1R5cGUgPSByZXF1aXJlKCcuL1hNTERvY1R5cGUnKTtcblxuICBYTUxFbGVtZW50ID0gcmVxdWlyZSgnLi9YTUxFbGVtZW50Jyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxCdWlsZGVyID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFhNTEJ1aWxkZXIobmFtZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHJvb3QsIHRlbXA7XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvb3QgZWxlbWVudCBuZWVkcyBhIG5hbWVcIik7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB0aGlzLnN0cmluZ2lmeSA9IG5ldyBYTUxTdHJpbmdpZmllcihvcHRpb25zKTtcbiAgICAgIHRlbXAgPSBuZXcgWE1MRWxlbWVudCh0aGlzLCAnZG9jJyk7XG4gICAgICByb290ID0gdGVtcC5lbGVtZW50KG5hbWUpO1xuICAgICAgcm9vdC5pc1Jvb3QgPSB0cnVlO1xuICAgICAgcm9vdC5kb2N1bWVudE9iamVjdCA9IHRoaXM7XG4gICAgICB0aGlzLnJvb3RPYmplY3QgPSByb290O1xuICAgICAgaWYgKCFvcHRpb25zLmhlYWRsZXNzKSB7XG4gICAgICAgIHJvb3QuZGVjbGFyYXRpb24ob3B0aW9ucyk7XG4gICAgICAgIGlmICgob3B0aW9ucy5wdWJJRCAhPSBudWxsKSB8fCAob3B0aW9ucy5zeXNJRCAhPSBudWxsKSkge1xuICAgICAgICAgIHJvb3QuZG9jdHlwZShvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIFhNTEJ1aWxkZXIucHJvdG90eXBlLnJvb3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb3RPYmplY3Q7XG4gICAgfTtcblxuICAgIFhNTEJ1aWxkZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICBYTUxCdWlsZGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBpbmRlbnQsIG5ld2xpbmUsIG9mZnNldCwgcHJldHR5LCByLCByZWYsIHJlZjEsIHJlZjI7XG4gICAgICBwcmV0dHkgPSAob3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5wcmV0dHkgOiB2b2lkIDApIHx8IGZhbHNlO1xuICAgICAgaW5kZW50ID0gKHJlZiA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMuaW5kZW50IDogdm9pZCAwKSAhPSBudWxsID8gcmVmIDogJyAgJztcbiAgICAgIG9mZnNldCA9IChyZWYxID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5vZmZzZXQgOiB2b2lkIDApICE9IG51bGwgPyByZWYxIDogMDtcbiAgICAgIG5ld2xpbmUgPSAocmVmMiA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMubmV3bGluZSA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjIgOiAnXFxuJztcbiAgICAgIHIgPSAnJztcbiAgICAgIGlmICh0aGlzLnhtbGRlYyAhPSBudWxsKSB7XG4gICAgICAgIHIgKz0gdGhpcy54bWxkZWMudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kb2N0eXBlICE9IG51bGwpIHtcbiAgICAgICAgciArPSB0aGlzLmRvY3R5cGUudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByICs9IHRoaXMucm9vdE9iamVjdC50b1N0cmluZyhvcHRpb25zKTtcbiAgICAgIGlmIChwcmV0dHkgJiYgci5zbGljZSgtbmV3bGluZS5sZW5ndGgpID09PSBuZXdsaW5lKSB7XG4gICAgICAgIHIgPSByLnNsaWNlKDAsIC1uZXdsaW5lLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTEJ1aWxkZXI7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTENEYXRhLCBYTUxOb2RlLCBjcmVhdGUsXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBjcmVhdGUgPSByZXF1aXJlKCdsb2Rhc2gvY3JlYXRlJyk7XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MQ0RhdGEgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxDRGF0YSwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxDRGF0YShwYXJlbnQsIHRleHQpIHtcbiAgICAgIFhNTENEYXRhLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgICBpZiAodGV4dCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgQ0RBVEEgdGV4dFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGV4dCA9IHRoaXMuc3RyaW5naWZ5LmNkYXRhKHRleHQpO1xuICAgIH1cblxuICAgIFhNTENEYXRhLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZShYTUxDRGF0YS5wcm90b3R5cGUsIHRoaXMpO1xuICAgIH07XG5cbiAgICBYTUxDRGF0YS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zLCBsZXZlbCkge1xuICAgICAgdmFyIGluZGVudCwgbmV3bGluZSwgb2Zmc2V0LCBwcmV0dHksIHIsIHJlZiwgcmVmMSwgcmVmMiwgc3BhY2U7XG4gICAgICBwcmV0dHkgPSAob3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5wcmV0dHkgOiB2b2lkIDApIHx8IGZhbHNlO1xuICAgICAgaW5kZW50ID0gKHJlZiA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMuaW5kZW50IDogdm9pZCAwKSAhPSBudWxsID8gcmVmIDogJyAgJztcbiAgICAgIG9mZnNldCA9IChyZWYxID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5vZmZzZXQgOiB2b2lkIDApICE9IG51bGwgPyByZWYxIDogMDtcbiAgICAgIG5ld2xpbmUgPSAocmVmMiA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMubmV3bGluZSA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjIgOiAnXFxuJztcbiAgICAgIGxldmVsIHx8IChsZXZlbCA9IDApO1xuICAgICAgc3BhY2UgPSBuZXcgQXJyYXkobGV2ZWwgKyBvZmZzZXQgKyAxKS5qb2luKGluZGVudCk7XG4gICAgICByID0gJyc7XG4gICAgICBpZiAocHJldHR5KSB7XG4gICAgICAgIHIgKz0gc3BhY2U7XG4gICAgICB9XG4gICAgICByICs9ICc8IVtDREFUQVsnICsgdGhpcy50ZXh0ICsgJ11dPic7XG4gICAgICBpZiAocHJldHR5KSB7XG4gICAgICAgIHIgKz0gbmV3bGluZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MQ0RhdGE7XG5cbiAgfSkoWE1MTm9kZSk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOS4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxDb21tZW50LCBYTUxOb2RlLCBjcmVhdGUsXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBjcmVhdGUgPSByZXF1aXJlKCdsb2Rhc2gvY3JlYXRlJyk7XG5cbiAgWE1MTm9kZSA9IHJlcXVpcmUoJy4vWE1MTm9kZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MQ29tbWVudCA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTENvbW1lbnQsIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gWE1MQ29tbWVudChwYXJlbnQsIHRleHQpIHtcbiAgICAgIFhNTENvbW1lbnQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICAgIGlmICh0ZXh0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBjb21tZW50IHRleHRcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnRleHQgPSB0aGlzLnN0cmluZ2lmeS5jb21tZW50KHRleHQpO1xuICAgIH1cblxuICAgIFhNTENvbW1lbnQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlKFhNTENvbW1lbnQucHJvdG90eXBlLCB0aGlzKTtcbiAgICB9O1xuXG4gICAgWE1MQ29tbWVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zLCBsZXZlbCkge1xuICAgICAgdmFyIGluZGVudCwgbmV3bGluZSwgb2Zmc2V0LCBwcmV0dHksIHIsIHJlZiwgcmVmMSwgcmVmMiwgc3BhY2U7XG4gICAgICBwcmV0dHkgPSAob3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5wcmV0dHkgOiB2b2lkIDApIHx8IGZhbHNlO1xuICAgICAgaW5kZW50ID0gKHJlZiA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMuaW5kZW50IDogdm9pZCAwKSAhPSBudWxsID8gcmVmIDogJyAgJztcbiAgICAgIG9mZnNldCA9IChyZWYxID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5vZmZzZXQgOiB2b2lkIDApICE9IG51bGwgPyByZWYxIDogMDtcbiAgICAgIG5ld2xpbmUgPSAocmVmMiA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMubmV3bGluZSA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjIgOiAnXFxuJztcbiAgICAgIGxldmVsIHx8IChsZXZlbCA9IDApO1xuICAgICAgc3BhY2UgPSBuZXcgQXJyYXkobGV2ZWwgKyBvZmZzZXQgKyAxKS5qb2luKGluZGVudCk7XG4gICAgICByID0gJyc7XG4gICAgICBpZiAocHJldHR5KSB7XG4gICAgICAgIHIgKz0gc3BhY2U7XG4gICAgICB9XG4gICAgICByICs9ICc8IS0tICcgKyB0aGlzLnRleHQgKyAnIC0tPic7XG4gICAgICBpZiAocHJldHR5KSB7XG4gICAgICAgIHIgKz0gbmV3bGluZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MQ29tbWVudDtcblxuICB9KShYTUxOb2RlKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTERUREF0dExpc3QsIGNyZWF0ZTtcblxuICBjcmVhdGUgPSByZXF1aXJlKCdsb2Rhc2gvY3JlYXRlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxEVERBdHRMaXN0ID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFhNTERUREF0dExpc3QocGFyZW50LCBlbGVtZW50TmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgZGVmYXVsdFZhbHVlVHlwZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB0aGlzLnN0cmluZ2lmeSA9IHBhcmVudC5zdHJpbmdpZnk7XG4gICAgICBpZiAoZWxlbWVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIERURCBlbGVtZW50IG5hbWVcIik7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgRFREIGF0dHJpYnV0ZSBuYW1lXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFhdHRyaWJ1dGVUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgRFREIGF0dHJpYnV0ZSB0eXBlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFkZWZhdWx0VmFsdWVUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgRFREIGF0dHJpYnV0ZSBkZWZhdWx0XCIpO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmF1bHRWYWx1ZVR5cGUuaW5kZXhPZignIycpICE9PSAwKSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZVR5cGUgPSAnIycgKyBkZWZhdWx0VmFsdWVUeXBlO1xuICAgICAgfVxuICAgICAgaWYgKCFkZWZhdWx0VmFsdWVUeXBlLm1hdGNoKC9eKCNSRVFVSVJFRHwjSU1QTElFRHwjRklYRUR8I0RFRkFVTFQpJC8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGVmYXVsdCB2YWx1ZSB0eXBlOyBleHBlY3RlZDogI1JFUVVJUkVELCAjSU1QTElFRCwgI0ZJWEVEIG9yICNERUZBVUxUXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSAmJiAhZGVmYXVsdFZhbHVlVHlwZS5tYXRjaCgvXigjRklYRUR8I0RFRkFVTFQpJC8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlZmF1bHQgdmFsdWUgb25seSBhcHBsaWVzIHRvICNGSVhFRCBvciAjREVGQVVMVFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWxlbWVudE5hbWUgPSB0aGlzLnN0cmluZ2lmeS5lbGVOYW1lKGVsZW1lbnROYW1lKTtcbiAgICAgIHRoaXMuYXR0cmlidXRlTmFtZSA9IHRoaXMuc3RyaW5naWZ5LmF0dE5hbWUoYXR0cmlidXRlTmFtZSk7XG4gICAgICB0aGlzLmF0dHJpYnV0ZVR5cGUgPSB0aGlzLnN0cmluZ2lmeS5kdGRBdHRUeXBlKGF0dHJpYnV0ZVR5cGUpO1xuICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSB0aGlzLnN0cmluZ2lmeS5kdGRBdHREZWZhdWx0KGRlZmF1bHRWYWx1ZSk7XG4gICAgICB0aGlzLmRlZmF1bHRWYWx1ZVR5cGUgPSBkZWZhdWx0VmFsdWVUeXBlO1xuICAgIH1cblxuICAgIFhNTERUREF0dExpc3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIHZhciBpbmRlbnQsIG5ld2xpbmUsIG9mZnNldCwgcHJldHR5LCByLCByZWYsIHJlZjEsIHJlZjIsIHNwYWNlO1xuICAgICAgcHJldHR5ID0gKG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMucHJldHR5IDogdm9pZCAwKSB8fCBmYWxzZTtcbiAgICAgIGluZGVudCA9IChyZWYgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLmluZGVudCA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZiA6ICcgICc7XG4gICAgICBvZmZzZXQgPSAocmVmMSA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMub2Zmc2V0IDogdm9pZCAwKSAhPSBudWxsID8gcmVmMSA6IDA7XG4gICAgICBuZXdsaW5lID0gKHJlZjIgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLm5ld2xpbmUgOiB2b2lkIDApICE9IG51bGwgPyByZWYyIDogJ1xcbic7XG4gICAgICBsZXZlbCB8fCAobGV2ZWwgPSAwKTtcbiAgICAgIHNwYWNlID0gbmV3IEFycmF5KGxldmVsICsgb2Zmc2V0ICsgMSkuam9pbihpbmRlbnQpO1xuICAgICAgciA9ICcnO1xuICAgICAgaWYgKHByZXR0eSkge1xuICAgICAgICByICs9IHNwYWNlO1xuICAgICAgfVxuICAgICAgciArPSAnPCFBVFRMSVNUICcgKyB0aGlzLmVsZW1lbnROYW1lICsgJyAnICsgdGhpcy5hdHRyaWJ1dGVOYW1lICsgJyAnICsgdGhpcy5hdHRyaWJ1dGVUeXBlO1xuICAgICAgaWYgKHRoaXMuZGVmYXVsdFZhbHVlVHlwZSAhPT0gJyNERUZBVUxUJykge1xuICAgICAgICByICs9ICcgJyArIHRoaXMuZGVmYXVsdFZhbHVlVHlwZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgICByICs9ICcgXCInICsgdGhpcy5kZWZhdWx0VmFsdWUgKyAnXCInO1xuICAgICAgfVxuICAgICAgciArPSAnPic7XG4gICAgICBpZiAocHJldHR5KSB7XG4gICAgICAgIHIgKz0gbmV3bGluZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MRFREQXR0TGlzdDtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MRFRERWxlbWVudCwgY3JlYXRlO1xuXG4gIGNyZWF0ZSA9IHJlcXVpcmUoJ2xvZGFzaC9jcmVhdGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTERUREVsZW1lbnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gWE1MRFRERWxlbWVudChwYXJlbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnN0cmluZ2lmeSA9IHBhcmVudC5zdHJpbmdpZnk7XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgRFREIGVsZW1lbnQgbmFtZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSAnKCNQQ0RBVEEpJztcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9ICcoJyArIHZhbHVlLmpvaW4oJywnKSArICcpJztcbiAgICAgIH1cbiAgICAgIHRoaXMubmFtZSA9IHRoaXMuc3RyaW5naWZ5LmVsZU5hbWUobmFtZSk7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5zdHJpbmdpZnkuZHRkRWxlbWVudFZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBYTUxEVERFbGVtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGxldmVsKSB7XG4gICAgICB2YXIgaW5kZW50LCBuZXdsaW5lLCBvZmZzZXQsIHByZXR0eSwgciwgcmVmLCByZWYxLCByZWYyLCBzcGFjZTtcbiAgICAgIHByZXR0eSA9IChvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLnByZXR0eSA6IHZvaWQgMCkgfHwgZmFsc2U7XG4gICAgICBpbmRlbnQgPSAocmVmID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5pbmRlbnQgOiB2b2lkIDApICE9IG51bGwgPyByZWYgOiAnICAnO1xuICAgICAgb2Zmc2V0ID0gKHJlZjEgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLm9mZnNldCA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjEgOiAwO1xuICAgICAgbmV3bGluZSA9IChyZWYyID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5uZXdsaW5lIDogdm9pZCAwKSAhPSBudWxsID8gcmVmMiA6ICdcXG4nO1xuICAgICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgICBzcGFjZSA9IG5ldyBBcnJheShsZXZlbCArIG9mZnNldCArIDEpLmpvaW4oaW5kZW50KTtcbiAgICAgIHIgPSAnJztcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBzcGFjZTtcbiAgICAgIH1cbiAgICAgIHIgKz0gJzwhRUxFTUVOVCAnICsgdGhpcy5uYW1lICsgJyAnICsgdGhpcy52YWx1ZSArICc+JztcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBuZXdsaW5lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxEVERFbGVtZW50O1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOS4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxEVERFbnRpdHksIGNyZWF0ZSwgaXNPYmplY3Q7XG5cbiAgY3JlYXRlID0gcmVxdWlyZSgnbG9kYXNoL2NyZWF0ZScpO1xuXG4gIGlzT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzT2JqZWN0Jyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxEVERFbnRpdHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gWE1MRFRERW50aXR5KHBhcmVudCwgcGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLnN0cmluZ2lmeSA9IHBhcmVudC5zdHJpbmdpZnk7XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZW50aXR5IG5hbWVcIik7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGVudGl0eSB2YWx1ZVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGUgPSAhIXBlO1xuICAgICAgdGhpcy5uYW1lID0gdGhpcy5zdHJpbmdpZnkuZWxlTmFtZShuYW1lKTtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnN0cmluZ2lmeS5kdGRFbnRpdHlWYWx1ZSh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXZhbHVlLnB1YklEICYmICF2YWx1ZS5zeXNJRCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlB1YmxpYyBhbmQvb3Igc3lzdGVtIGlkZW50aWZpZXJzIGFyZSByZXF1aXJlZCBmb3IgYW4gZXh0ZXJuYWwgZW50aXR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5wdWJJRCAmJiAhdmFsdWUuc3lzSUQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeXN0ZW0gaWRlbnRpZmllciBpcyByZXF1aXJlZCBmb3IgYSBwdWJsaWMgZXh0ZXJuYWwgZW50aXR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5wdWJJRCAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5wdWJJRCA9IHRoaXMuc3RyaW5naWZ5LmR0ZFB1YklEKHZhbHVlLnB1YklEKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuc3lzSUQgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuc3lzSUQgPSB0aGlzLnN0cmluZ2lmeS5kdGRTeXNJRCh2YWx1ZS5zeXNJRCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLm5EYXRhICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLm5EYXRhID0gdGhpcy5zdHJpbmdpZnkuZHRkTkRhdGEodmFsdWUubkRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBlICYmIHRoaXMubkRhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3RhdGlvbiBkZWNsYXJhdGlvbiBpcyBub3QgYWxsb3dlZCBpbiBhIHBhcmFtZXRlciBlbnRpdHlcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBYTUxEVERFbnRpdHkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIHZhciBpbmRlbnQsIG5ld2xpbmUsIG9mZnNldCwgcHJldHR5LCByLCByZWYsIHJlZjEsIHJlZjIsIHNwYWNlO1xuICAgICAgcHJldHR5ID0gKG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMucHJldHR5IDogdm9pZCAwKSB8fCBmYWxzZTtcbiAgICAgIGluZGVudCA9IChyZWYgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLmluZGVudCA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZiA6ICcgICc7XG4gICAgICBvZmZzZXQgPSAocmVmMSA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMub2Zmc2V0IDogdm9pZCAwKSAhPSBudWxsID8gcmVmMSA6IDA7XG4gICAgICBuZXdsaW5lID0gKHJlZjIgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLm5ld2xpbmUgOiB2b2lkIDApICE9IG51bGwgPyByZWYyIDogJ1xcbic7XG4gICAgICBsZXZlbCB8fCAobGV2ZWwgPSAwKTtcbiAgICAgIHNwYWNlID0gbmV3IEFycmF5KGxldmVsICsgb2Zmc2V0ICsgMSkuam9pbihpbmRlbnQpO1xuICAgICAgciA9ICcnO1xuICAgICAgaWYgKHByZXR0eSkge1xuICAgICAgICByICs9IHNwYWNlO1xuICAgICAgfVxuICAgICAgciArPSAnPCFFTlRJVFknO1xuICAgICAgaWYgKHRoaXMucGUpIHtcbiAgICAgICAgciArPSAnICUnO1xuICAgICAgfVxuICAgICAgciArPSAnICcgKyB0aGlzLm5hbWU7XG4gICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICByICs9ICcgXCInICsgdGhpcy52YWx1ZSArICdcIic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5wdWJJRCAmJiB0aGlzLnN5c0lEKSB7XG4gICAgICAgICAgciArPSAnIFBVQkxJQyBcIicgKyB0aGlzLnB1YklEICsgJ1wiIFwiJyArIHRoaXMuc3lzSUQgKyAnXCInO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3lzSUQpIHtcbiAgICAgICAgICByICs9ICcgU1lTVEVNIFwiJyArIHRoaXMuc3lzSUQgKyAnXCInO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5EYXRhKSB7XG4gICAgICAgICAgciArPSAnIE5EQVRBICcgKyB0aGlzLm5EYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByICs9ICc+JztcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBuZXdsaW5lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxEVERFbnRpdHk7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTERURE5vdGF0aW9uLCBjcmVhdGU7XG5cbiAgY3JlYXRlID0gcmVxdWlyZSgnbG9kYXNoL2NyZWF0ZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MRFRETm90YXRpb24gPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gWE1MRFRETm90YXRpb24ocGFyZW50LCBuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5zdHJpbmdpZnkgPSBwYXJlbnQuc3RyaW5naWZ5O1xuICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIG5vdGF0aW9uIG5hbWVcIik7XG4gICAgICB9XG4gICAgICBpZiAoIXZhbHVlLnB1YklEICYmICF2YWx1ZS5zeXNJRCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQdWJsaWMgb3Igc3lzdGVtIGlkZW50aWZpZXJzIGFyZSByZXF1aXJlZCBmb3IgYW4gZXh0ZXJuYWwgZW50aXR5XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5uYW1lID0gdGhpcy5zdHJpbmdpZnkuZWxlTmFtZShuYW1lKTtcbiAgICAgIGlmICh2YWx1ZS5wdWJJRCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMucHViSUQgPSB0aGlzLnN0cmluZ2lmeS5kdGRQdWJJRCh2YWx1ZS5wdWJJRCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUuc3lzSUQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnN5c0lEID0gdGhpcy5zdHJpbmdpZnkuZHRkU3lzSUQodmFsdWUuc3lzSUQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFhNTERURE5vdGF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGxldmVsKSB7XG4gICAgICB2YXIgaW5kZW50LCBuZXdsaW5lLCBvZmZzZXQsIHByZXR0eSwgciwgcmVmLCByZWYxLCByZWYyLCBzcGFjZTtcbiAgICAgIHByZXR0eSA9IChvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLnByZXR0eSA6IHZvaWQgMCkgfHwgZmFsc2U7XG4gICAgICBpbmRlbnQgPSAocmVmID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5pbmRlbnQgOiB2b2lkIDApICE9IG51bGwgPyByZWYgOiAnICAnO1xuICAgICAgb2Zmc2V0ID0gKHJlZjEgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLm9mZnNldCA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjEgOiAwO1xuICAgICAgbmV3bGluZSA9IChyZWYyID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5uZXdsaW5lIDogdm9pZCAwKSAhPSBudWxsID8gcmVmMiA6ICdcXG4nO1xuICAgICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgICBzcGFjZSA9IG5ldyBBcnJheShsZXZlbCArIG9mZnNldCArIDEpLmpvaW4oaW5kZW50KTtcbiAgICAgIHIgPSAnJztcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBzcGFjZTtcbiAgICAgIH1cbiAgICAgIHIgKz0gJzwhTk9UQVRJT04gJyArIHRoaXMubmFtZTtcbiAgICAgIGlmICh0aGlzLnB1YklEICYmIHRoaXMuc3lzSUQpIHtcbiAgICAgICAgciArPSAnIFBVQkxJQyBcIicgKyB0aGlzLnB1YklEICsgJ1wiIFwiJyArIHRoaXMuc3lzSUQgKyAnXCInO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnB1YklEKSB7XG4gICAgICAgIHIgKz0gJyBQVUJMSUMgXCInICsgdGhpcy5wdWJJRCArICdcIic7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3lzSUQpIHtcbiAgICAgICAgciArPSAnIFNZU1RFTSBcIicgKyB0aGlzLnN5c0lEICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIHIgKz0gJz4nO1xuICAgICAgaWYgKHByZXR0eSkge1xuICAgICAgICByICs9IG5ld2xpbmU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTERURE5vdGF0aW9uO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOS4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxEZWNsYXJhdGlvbiwgWE1MTm9kZSwgY3JlYXRlLCBpc09iamVjdCxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIGNyZWF0ZSA9IHJlcXVpcmUoJ2xvZGFzaC9jcmVhdGUnKTtcblxuICBpc09iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc09iamVjdCcpO1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTERlY2xhcmF0aW9uID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoWE1MRGVjbGFyYXRpb24sIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gWE1MRGVjbGFyYXRpb24ocGFyZW50LCB2ZXJzaW9uLCBlbmNvZGluZywgc3RhbmRhbG9uZSkge1xuICAgICAgdmFyIHJlZjtcbiAgICAgIFhNTERlY2xhcmF0aW9uLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgICBpZiAoaXNPYmplY3QodmVyc2lvbikpIHtcbiAgICAgICAgcmVmID0gdmVyc2lvbiwgdmVyc2lvbiA9IHJlZi52ZXJzaW9uLCBlbmNvZGluZyA9IHJlZi5lbmNvZGluZywgc3RhbmRhbG9uZSA9IHJlZi5zdGFuZGFsb25lO1xuICAgICAgfVxuICAgICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICAgIHZlcnNpb24gPSAnMS4wJztcbiAgICAgIH1cbiAgICAgIHRoaXMudmVyc2lvbiA9IHRoaXMuc3RyaW5naWZ5LnhtbFZlcnNpb24odmVyc2lvbik7XG4gICAgICBpZiAoZW5jb2RpbmcgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmVuY29kaW5nID0gdGhpcy5zdHJpbmdpZnkueG1sRW5jb2RpbmcoZW5jb2RpbmcpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YW5kYWxvbmUgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnN0YW5kYWxvbmUgPSB0aGlzLnN0cmluZ2lmeS54bWxTdGFuZGFsb25lKHN0YW5kYWxvbmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFhNTERlY2xhcmF0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGxldmVsKSB7XG4gICAgICB2YXIgaW5kZW50LCBuZXdsaW5lLCBvZmZzZXQsIHByZXR0eSwgciwgcmVmLCByZWYxLCByZWYyLCBzcGFjZTtcbiAgICAgIHByZXR0eSA9IChvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLnByZXR0eSA6IHZvaWQgMCkgfHwgZmFsc2U7XG4gICAgICBpbmRlbnQgPSAocmVmID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5pbmRlbnQgOiB2b2lkIDApICE9IG51bGwgPyByZWYgOiAnICAnO1xuICAgICAgb2Zmc2V0ID0gKHJlZjEgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLm9mZnNldCA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjEgOiAwO1xuICAgICAgbmV3bGluZSA9IChyZWYyID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5uZXdsaW5lIDogdm9pZCAwKSAhPSBudWxsID8gcmVmMiA6ICdcXG4nO1xuICAgICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgICBzcGFjZSA9IG5ldyBBcnJheShsZXZlbCArIG9mZnNldCArIDEpLmpvaW4oaW5kZW50KTtcbiAgICAgIHIgPSAnJztcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBzcGFjZTtcbiAgICAgIH1cbiAgICAgIHIgKz0gJzw/eG1sJztcbiAgICAgIHIgKz0gJyB2ZXJzaW9uPVwiJyArIHRoaXMudmVyc2lvbiArICdcIic7XG4gICAgICBpZiAodGhpcy5lbmNvZGluZyAhPSBudWxsKSB7XG4gICAgICAgIHIgKz0gJyBlbmNvZGluZz1cIicgKyB0aGlzLmVuY29kaW5nICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YW5kYWxvbmUgIT0gbnVsbCkge1xuICAgICAgICByICs9ICcgc3RhbmRhbG9uZT1cIicgKyB0aGlzLnN0YW5kYWxvbmUgKyAnXCInO1xuICAgICAgfVxuICAgICAgciArPSAnPz4nO1xuICAgICAgaWYgKHByZXR0eSkge1xuICAgICAgICByICs9IG5ld2xpbmU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFhNTERlY2xhcmF0aW9uO1xuXG4gIH0pKFhNTE5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQ0RhdGEsIFhNTENvbW1lbnQsIFhNTERUREF0dExpc3QsIFhNTERUREVsZW1lbnQsIFhNTERUREVudGl0eSwgWE1MRFRETm90YXRpb24sIFhNTERvY1R5cGUsIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiwgY3JlYXRlLCBpc09iamVjdDtcblxuICBjcmVhdGUgPSByZXF1aXJlKCdsb2Rhc2gvY3JlYXRlJyk7XG5cbiAgaXNPYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNPYmplY3QnKTtcblxuICBYTUxDRGF0YSA9IHJlcXVpcmUoJy4vWE1MQ0RhdGEnKTtcblxuICBYTUxDb21tZW50ID0gcmVxdWlyZSgnLi9YTUxDb21tZW50Jyk7XG5cbiAgWE1MRFREQXR0TGlzdCA9IHJlcXVpcmUoJy4vWE1MRFREQXR0TGlzdCcpO1xuXG4gIFhNTERUREVudGl0eSA9IHJlcXVpcmUoJy4vWE1MRFRERW50aXR5Jyk7XG5cbiAgWE1MRFRERWxlbWVudCA9IHJlcXVpcmUoJy4vWE1MRFRERWxlbWVudCcpO1xuXG4gIFhNTERURE5vdGF0aW9uID0gcmVxdWlyZSgnLi9YTUxEVEROb3RhdGlvbicpO1xuXG4gIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbiA9IHJlcXVpcmUoJy4vWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxEb2NUeXBlID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFhNTERvY1R5cGUocGFyZW50LCBwdWJJRCwgc3lzSUQpIHtcbiAgICAgIHZhciByZWYsIHJlZjE7XG4gICAgICB0aGlzLmRvY3VtZW50T2JqZWN0ID0gcGFyZW50O1xuICAgICAgdGhpcy5zdHJpbmdpZnkgPSB0aGlzLmRvY3VtZW50T2JqZWN0LnN0cmluZ2lmeTtcbiAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgIGlmIChpc09iamVjdChwdWJJRCkpIHtcbiAgICAgICAgcmVmID0gcHViSUQsIHB1YklEID0gcmVmLnB1YklELCBzeXNJRCA9IHJlZi5zeXNJRDtcbiAgICAgIH1cbiAgICAgIGlmIChzeXNJRCA9PSBudWxsKSB7XG4gICAgICAgIHJlZjEgPSBbcHViSUQsIHN5c0lEXSwgc3lzSUQgPSByZWYxWzBdLCBwdWJJRCA9IHJlZjFbMV07XG4gICAgICB9XG4gICAgICBpZiAocHViSUQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnB1YklEID0gdGhpcy5zdHJpbmdpZnkuZHRkUHViSUQocHViSUQpO1xuICAgICAgfVxuICAgICAgaWYgKHN5c0lEICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zeXNJRCA9IHRoaXMuc3RyaW5naWZ5LmR0ZFN5c0lEKHN5c0lEKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5lbGVtZW50ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGNoaWxkID0gbmV3IFhNTERUREVsZW1lbnQodGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5hdHRMaXN0ID0gZnVuY3Rpb24oZWxlbWVudE5hbWUsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVR5cGUsIGRlZmF1bHRWYWx1ZVR5cGUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MRFREQXR0TGlzdCh0aGlzLCBlbGVtZW50TmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgZGVmYXVsdFZhbHVlVHlwZSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUuZW50aXR5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGNoaWxkID0gbmV3IFhNTERUREVudGl0eSh0aGlzLCBmYWxzZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5wRW50aXR5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGNoaWxkID0gbmV3IFhNTERUREVudGl0eSh0aGlzLCB0cnVlLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFhNTERvY1R5cGUucHJvdG90eXBlLm5vdGF0aW9uID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGNoaWxkID0gbmV3IFhNTERURE5vdGF0aW9uKHRoaXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUuY2RhdGEgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MQ0RhdGEodGhpcywgdmFsdWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5jb21tZW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGNoaWxkID0gbmV3IFhNTENvbW1lbnQodGhpcywgdmFsdWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5pbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGNoaWxkID0gbmV3IFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbih0aGlzLCB0YXJnZXQsIHZhbHVlKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUucm9vdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRPYmplY3Qucm9vdCgpO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5kb2N1bWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRPYmplY3Q7XG4gICAgfTtcblxuICAgIFhNTERvY1R5cGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIHZhciBjaGlsZCwgaSwgaW5kZW50LCBsZW4sIG5ld2xpbmUsIG9mZnNldCwgcHJldHR5LCByLCByZWYsIHJlZjEsIHJlZjIsIHJlZjMsIHNwYWNlO1xuICAgICAgcHJldHR5ID0gKG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMucHJldHR5IDogdm9pZCAwKSB8fCBmYWxzZTtcbiAgICAgIGluZGVudCA9IChyZWYgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLmluZGVudCA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZiA6ICcgICc7XG4gICAgICBvZmZzZXQgPSAocmVmMSA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMub2Zmc2V0IDogdm9pZCAwKSAhPSBudWxsID8gcmVmMSA6IDA7XG4gICAgICBuZXdsaW5lID0gKHJlZjIgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLm5ld2xpbmUgOiB2b2lkIDApICE9IG51bGwgPyByZWYyIDogJ1xcbic7XG4gICAgICBsZXZlbCB8fCAobGV2ZWwgPSAwKTtcbiAgICAgIHNwYWNlID0gbmV3IEFycmF5KGxldmVsICsgb2Zmc2V0ICsgMSkuam9pbihpbmRlbnQpO1xuICAgICAgciA9ICcnO1xuICAgICAgaWYgKHByZXR0eSkge1xuICAgICAgICByICs9IHNwYWNlO1xuICAgICAgfVxuICAgICAgciArPSAnPCFET0NUWVBFICcgKyB0aGlzLnJvb3QoKS5uYW1lO1xuICAgICAgaWYgKHRoaXMucHViSUQgJiYgdGhpcy5zeXNJRCkge1xuICAgICAgICByICs9ICcgUFVCTElDIFwiJyArIHRoaXMucHViSUQgKyAnXCIgXCInICsgdGhpcy5zeXNJRCArICdcIic7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3lzSUQpIHtcbiAgICAgICAgciArPSAnIFNZU1RFTSBcIicgKyB0aGlzLnN5c0lEICsgJ1wiJztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgciArPSAnIFsnO1xuICAgICAgICBpZiAocHJldHR5KSB7XG4gICAgICAgICAgciArPSBuZXdsaW5lO1xuICAgICAgICB9XG4gICAgICAgIHJlZjMgPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hpbGQgPSByZWYzW2ldO1xuICAgICAgICAgIHIgKz0gY2hpbGQudG9TdHJpbmcob3B0aW9ucywgbGV2ZWwgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICByICs9ICddJztcbiAgICAgIH1cbiAgICAgIHIgKz0gJz4nO1xuICAgICAgaWYgKHByZXR0eSkge1xuICAgICAgICByICs9IG5ld2xpbmU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUuZWxlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQobmFtZSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5hdHQgPSBmdW5jdGlvbihlbGVtZW50TmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgZGVmYXVsdFZhbHVlVHlwZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRMaXN0KGVsZW1lbnROYW1lLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBkZWZhdWx0VmFsdWVUeXBlLCBkZWZhdWx0VmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5lbnQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW50aXR5KG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUucGVudCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wRW50aXR5KG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vdGF0aW9uKG5hbWUsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUuZGF0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNkYXRhKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUuY29tID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbW1lbnQodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxEb2NUeXBlLnByb3RvdHlwZS5pbnMgPSBmdW5jdGlvbih0YXJnZXQsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbih0YXJnZXQsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb3QoKTtcbiAgICB9O1xuXG4gICAgWE1MRG9jVHlwZS5wcm90b3R5cGUuZG9jID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2N1bWVudCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MRG9jVHlwZTtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQXR0cmlidXRlLCBYTUxFbGVtZW50LCBYTUxOb2RlLCBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sIGNyZWF0ZSwgZXZlcnksIGlzRnVuY3Rpb24sIGlzT2JqZWN0LFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgY3JlYXRlID0gcmVxdWlyZSgnbG9kYXNoL2NyZWF0ZScpO1xuXG4gIGlzT2JqZWN0ID0gcmVxdWlyZSgnbG9kYXNoL2lzT2JqZWN0Jyk7XG5cbiAgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2xvZGFzaC9pc0Z1bmN0aW9uJyk7XG5cbiAgZXZlcnkgPSByZXF1aXJlKCdsb2Rhc2gvZXZlcnknKTtcblxuICBYTUxOb2RlID0gcmVxdWlyZSgnLi9YTUxOb2RlJyk7XG5cbiAgWE1MQXR0cmlidXRlID0gcmVxdWlyZSgnLi9YTUxBdHRyaWJ1dGUnKTtcblxuICBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24gPSByZXF1aXJlKCcuL1hNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbicpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MRWxlbWVudCA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTEVsZW1lbnQsIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gWE1MRWxlbWVudChwYXJlbnQsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICAgIFhNTEVsZW1lbnQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBlbGVtZW50IG5hbWVcIik7XG4gICAgICB9XG4gICAgICB0aGlzLm5hbWUgPSB0aGlzLnN0cmluZ2lmeS5lbGVOYW1lKG5hbWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgaWYgKGF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZShhdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBYTUxFbGVtZW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGF0dCwgYXR0TmFtZSwgY2xvbmVkU2VsZiwgaSwgbGVuLCBwaSwgcmVmLCByZWYxO1xuICAgICAgY2xvbmVkU2VsZiA9IGNyZWF0ZShYTUxFbGVtZW50LnByb3RvdHlwZSwgdGhpcyk7XG4gICAgICBpZiAoY2xvbmVkU2VsZi5pc1Jvb3QpIHtcbiAgICAgICAgY2xvbmVkU2VsZi5kb2N1bWVudE9iamVjdCA9IG51bGw7XG4gICAgICB9XG4gICAgICBjbG9uZWRTZWxmLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgIHJlZiA9IHRoaXMuYXR0cmlidXRlcztcbiAgICAgIGZvciAoYXR0TmFtZSBpbiByZWYpIHtcbiAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwocmVmLCBhdHROYW1lKSkgY29udGludWU7XG4gICAgICAgIGF0dCA9IHJlZlthdHROYW1lXTtcbiAgICAgICAgY2xvbmVkU2VsZi5hdHRyaWJ1dGVzW2F0dE5hbWVdID0gYXR0LmNsb25lKCk7XG4gICAgICB9XG4gICAgICBjbG9uZWRTZWxmLmluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgcmVmMSA9IHRoaXMuaW5zdHJ1Y3Rpb25zO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwaSA9IHJlZjFbaV07XG4gICAgICAgIGNsb25lZFNlbGYuaW5zdHJ1Y3Rpb25zLnB1c2gocGkuY2xvbmUoKSk7XG4gICAgICB9XG4gICAgICBjbG9uZWRTZWxmLmNoaWxkcmVuID0gW107XG4gICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgdmFyIGNsb25lZENoaWxkO1xuICAgICAgICBjbG9uZWRDaGlsZCA9IGNoaWxkLmNsb25lKCk7XG4gICAgICAgIGNsb25lZENoaWxkLnBhcmVudCA9IGNsb25lZFNlbGY7XG4gICAgICAgIHJldHVybiBjbG9uZWRTZWxmLmNoaWxkcmVuLnB1c2goY2xvbmVkQ2hpbGQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2xvbmVkU2VsZjtcbiAgICB9O1xuXG4gICAgWE1MRWxlbWVudC5wcm90b3R5cGUuYXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBhdHROYW1lLCBhdHRWYWx1ZTtcbiAgICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgIGZvciAoYXR0TmFtZSBpbiBuYW1lKSB7XG4gICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwobmFtZSwgYXR0TmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgIGF0dFZhbHVlID0gbmFtZVthdHROYW1lXTtcbiAgICAgICAgICB0aGlzLmF0dHJpYnV0ZShhdHROYW1lLCBhdHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUuYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5za2lwTnVsbEF0dHJpYnV0ZXMgfHwgKHZhbHVlICE9IG51bGwpKSB7XG4gICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW25hbWVdID0gbmV3IFhNTEF0dHJpYnV0ZSh0aGlzLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxFbGVtZW50LnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgYXR0TmFtZSwgaSwgbGVuO1xuICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGF0dHJpYnV0ZSBuYW1lXCIpO1xuICAgICAgfVxuICAgICAgbmFtZSA9IG5hbWUudmFsdWVPZigpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbmFtZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGF0dE5hbWUgPSBuYW1lW2ldO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbYXR0TmFtZV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRWxlbWVudC5wcm90b3R5cGUuaW5zdHJ1Y3Rpb24gPSBmdW5jdGlvbih0YXJnZXQsIHZhbHVlKSB7XG4gICAgICB2YXIgaSwgaW5zVGFyZ2V0LCBpbnNWYWx1ZSwgaW5zdHJ1Y3Rpb24sIGxlbjtcbiAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRhcmdldC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGluc1RhcmdldCA9IHRhcmdldFtpXTtcbiAgICAgICAgICB0aGlzLmluc3RydWN0aW9uKGluc1RhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodGFyZ2V0KSkge1xuICAgICAgICBmb3IgKGluc1RhcmdldCBpbiB0YXJnZXQpIHtcbiAgICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbCh0YXJnZXQsIGluc1RhcmdldCkpIGNvbnRpbnVlO1xuICAgICAgICAgIGluc1ZhbHVlID0gdGFyZ2V0W2luc1RhcmdldF07XG4gICAgICAgICAgdGhpcy5pbnN0cnVjdGlvbihpbnNUYXJnZXQsIGluc1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5hcHBseSgpO1xuICAgICAgICB9XG4gICAgICAgIGluc3RydWN0aW9uID0gbmV3IFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbih0aGlzLCB0YXJnZXQsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChpbnN0cnVjdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MRWxlbWVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihvcHRpb25zLCBsZXZlbCkge1xuICAgICAgdmFyIGF0dCwgY2hpbGQsIGksIGluZGVudCwgaW5zdHJ1Y3Rpb24sIGosIGxlbiwgbGVuMSwgbmFtZSwgbmV3bGluZSwgb2Zmc2V0LCBwcmV0dHksIHIsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgcmVmNSwgc3BhY2U7XG4gICAgICBwcmV0dHkgPSAob3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5wcmV0dHkgOiB2b2lkIDApIHx8IGZhbHNlO1xuICAgICAgaW5kZW50ID0gKHJlZiA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMuaW5kZW50IDogdm9pZCAwKSAhPSBudWxsID8gcmVmIDogJyAgJztcbiAgICAgIG9mZnNldCA9IChyZWYxID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5vZmZzZXQgOiB2b2lkIDApICE9IG51bGwgPyByZWYxIDogMDtcbiAgICAgIG5ld2xpbmUgPSAocmVmMiA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMubmV3bGluZSA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjIgOiAnXFxuJztcbiAgICAgIGxldmVsIHx8IChsZXZlbCA9IDApO1xuICAgICAgc3BhY2UgPSBuZXcgQXJyYXkobGV2ZWwgKyBvZmZzZXQgKyAxKS5qb2luKGluZGVudCk7XG4gICAgICByID0gJyc7XG4gICAgICByZWYzID0gdGhpcy5pbnN0cnVjdGlvbnM7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGluc3RydWN0aW9uID0gcmVmM1tpXTtcbiAgICAgICAgciArPSBpbnN0cnVjdGlvbi50b1N0cmluZyhvcHRpb25zLCBsZXZlbCk7XG4gICAgICB9XG4gICAgICBpZiAocHJldHR5KSB7XG4gICAgICAgIHIgKz0gc3BhY2U7XG4gICAgICB9XG4gICAgICByICs9ICc8JyArIHRoaXMubmFtZTtcbiAgICAgIHJlZjQgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKG5hbWUgaW4gcmVmNCkge1xuICAgICAgICBpZiAoIWhhc1Byb3AuY2FsbChyZWY0LCBuYW1lKSkgY29udGludWU7XG4gICAgICAgIGF0dCA9IHJlZjRbbmFtZV07XG4gICAgICAgIHIgKz0gYXR0LnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IGV2ZXJ5KHRoaXMuY2hpbGRyZW4sIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIGUudmFsdWUgPT09ICcnO1xuICAgICAgfSkpIHtcbiAgICAgICAgciArPSAnLz4nO1xuICAgICAgICBpZiAocHJldHR5KSB7XG4gICAgICAgICAgciArPSBuZXdsaW5lO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByZXR0eSAmJiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiAodGhpcy5jaGlsZHJlblswXS52YWx1ZSAhPSBudWxsKSkge1xuICAgICAgICByICs9ICc+JztcbiAgICAgICAgciArPSB0aGlzLmNoaWxkcmVuWzBdLnZhbHVlO1xuICAgICAgICByICs9ICc8LycgKyB0aGlzLm5hbWUgKyAnPic7XG4gICAgICAgIHIgKz0gbmV3bGluZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgKz0gJz4nO1xuICAgICAgICBpZiAocHJldHR5KSB7XG4gICAgICAgICAgciArPSBuZXdsaW5lO1xuICAgICAgICB9XG4gICAgICAgIHJlZjUgPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICBmb3IgKGogPSAwLCBsZW4xID0gcmVmNS5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICAgICAgICBjaGlsZCA9IHJlZjVbal07XG4gICAgICAgICAgciArPSBjaGlsZC50b1N0cmluZyhvcHRpb25zLCBsZXZlbCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgICByICs9IHNwYWNlO1xuICAgICAgICB9XG4gICAgICAgIHIgKz0gJzwvJyArIHRoaXMubmFtZSArICc+JztcbiAgICAgICAgaWYgKHByZXR0eSkge1xuICAgICAgICAgIHIgKz0gbmV3bGluZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIFhNTEVsZW1lbnQucHJvdG90eXBlLmF0dCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxFbGVtZW50LnByb3RvdHlwZS5pbnMgPSBmdW5jdGlvbih0YXJnZXQsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbih0YXJnZXQsIHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MRWxlbWVudC5wcm90b3R5cGUuYSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxFbGVtZW50LnByb3RvdHlwZS5pID0gZnVuY3Rpb24odGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb24odGFyZ2V0LCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxFbGVtZW50O1xuXG4gIH0pKFhNTE5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQ0RhdGEsIFhNTENvbW1lbnQsIFhNTERlY2xhcmF0aW9uLCBYTUxEb2NUeXBlLCBYTUxFbGVtZW50LCBYTUxOb2RlLCBYTUxSYXcsIFhNTFRleHQsIGlzRW1wdHksIGlzRnVuY3Rpb24sIGlzT2JqZWN0LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBpc09iamVjdCA9IHJlcXVpcmUoJ2xvZGFzaC9pc09iamVjdCcpO1xuXG4gIGlzRnVuY3Rpb24gPSByZXF1aXJlKCdsb2Rhc2gvaXNGdW5jdGlvbicpO1xuXG4gIGlzRW1wdHkgPSByZXF1aXJlKCdsb2Rhc2gvaXNFbXB0eScpO1xuXG4gIFhNTEVsZW1lbnQgPSBudWxsO1xuXG4gIFhNTENEYXRhID0gbnVsbDtcblxuICBYTUxDb21tZW50ID0gbnVsbDtcblxuICBYTUxEZWNsYXJhdGlvbiA9IG51bGw7XG5cbiAgWE1MRG9jVHlwZSA9IG51bGw7XG5cbiAgWE1MUmF3ID0gbnVsbDtcblxuICBYTUxUZXh0ID0gbnVsbDtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTE5vZGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gWE1MTm9kZShwYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5wYXJlbnQub3B0aW9ucztcbiAgICAgIHRoaXMuc3RyaW5naWZ5ID0gdGhpcy5wYXJlbnQuc3RyaW5naWZ5O1xuICAgICAgaWYgKFhNTEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgWE1MRWxlbWVudCA9IHJlcXVpcmUoJy4vWE1MRWxlbWVudCcpO1xuICAgICAgICBYTUxDRGF0YSA9IHJlcXVpcmUoJy4vWE1MQ0RhdGEnKTtcbiAgICAgICAgWE1MQ29tbWVudCA9IHJlcXVpcmUoJy4vWE1MQ29tbWVudCcpO1xuICAgICAgICBYTUxEZWNsYXJhdGlvbiA9IHJlcXVpcmUoJy4vWE1MRGVjbGFyYXRpb24nKTtcbiAgICAgICAgWE1MRG9jVHlwZSA9IHJlcXVpcmUoJy4vWE1MRG9jVHlwZScpO1xuICAgICAgICBYTUxSYXcgPSByZXF1aXJlKCcuL1hNTFJhdycpO1xuICAgICAgICBYTUxUZXh0ID0gcmVxdWlyZSgnLi9YTUxUZXh0Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuZWxlbWVudCA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgICAgIHZhciBjaGlsZE5vZGUsIGl0ZW0sIGosIGssIGtleSwgbGFzdENoaWxkLCBsZW4sIGxlbjEsIHJlZiwgdmFsO1xuICAgICAgbGFzdENoaWxkID0gbnVsbDtcbiAgICAgIGlmIChhdHRyaWJ1dGVzID09IG51bGwpIHtcbiAgICAgICAgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgfVxuICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMudmFsdWVPZigpO1xuICAgICAgaWYgKCFpc09iamVjdChhdHRyaWJ1dGVzKSkge1xuICAgICAgICByZWYgPSBbYXR0cmlidXRlcywgdGV4dF0sIHRleHQgPSByZWZbMF0sIGF0dHJpYnV0ZXMgPSByZWZbMV07XG4gICAgICB9XG4gICAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbiA9IG5hbWUubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICBpdGVtID0gbmFtZVtqXTtcbiAgICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLmVsZW1lbnQoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihuYW1lKSkge1xuICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLmVsZW1lbnQobmFtZS5hcHBseSgpKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICAgICAgZm9yIChrZXkgaW4gbmFtZSkge1xuICAgICAgICAgIGlmICghaGFzUHJvcC5jYWxsKG5hbWUsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgIHZhbCA9IG5hbWVba2V5XTtcbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWwpKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWwuYXBwbHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChpc09iamVjdCh2YWwpKSAmJiAoaXNFbXB0eSh2YWwpKSkge1xuICAgICAgICAgICAgdmFsID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaWdub3JlRGVjb3JhdG9ycyAmJiB0aGlzLnN0cmluZ2lmeS5jb252ZXJ0QXR0S2V5ICYmIGtleS5pbmRleE9mKHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRBdHRLZXkpID09PSAwKSB7XG4gICAgICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLmF0dHJpYnV0ZShrZXkuc3Vic3RyKHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRBdHRLZXkubGVuZ3RoKSwgdmFsKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuaWdub3JlRGVjb3JhdG9ycyAmJiB0aGlzLnN0cmluZ2lmeS5jb252ZXJ0UElLZXkgJiYga2V5LmluZGV4T2YodGhpcy5zdHJpbmdpZnkuY29udmVydFBJS2V5KSA9PT0gMCkge1xuICAgICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5pbnN0cnVjdGlvbihrZXkuc3Vic3RyKHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRQSUtleS5sZW5ndGgpLCB2YWwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5zZXBhcmF0ZUFycmF5SXRlbXMgJiYgQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAwLCBsZW4xID0gdmFsLmxlbmd0aDsgayA8IGxlbjE7IGsrKykge1xuICAgICAgICAgICAgICBpdGVtID0gdmFsW2tdO1xuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSB7fTtcbiAgICAgICAgICAgICAgY2hpbGROb2RlW2tleV0gPSBpdGVtO1xuICAgICAgICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLmVsZW1lbnQoY2hpbGROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuZWxlbWVudChrZXkpO1xuICAgICAgICAgICAgbGFzdENoaWxkLmVsZW1lbnQodmFsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5lbGVtZW50KGtleSwgdmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZURlY29yYXRvcnMgJiYgdGhpcy5zdHJpbmdpZnkuY29udmVydFRleHRLZXkgJiYgbmFtZS5pbmRleE9mKHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRUZXh0S2V5KSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMudGV4dCh0ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZURlY29yYXRvcnMgJiYgdGhpcy5zdHJpbmdpZnkuY29udmVydENEYXRhS2V5ICYmIG5hbWUuaW5kZXhPZih0aGlzLnN0cmluZ2lmeS5jb252ZXJ0Q0RhdGFLZXkpID09PSAwKSB7XG4gICAgICAgICAgbGFzdENoaWxkID0gdGhpcy5jZGF0YSh0ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZURlY29yYXRvcnMgJiYgdGhpcy5zdHJpbmdpZnkuY29udmVydENvbW1lbnRLZXkgJiYgbmFtZS5pbmRleE9mKHRoaXMuc3RyaW5naWZ5LmNvbnZlcnRDb21tZW50S2V5KSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RDaGlsZCA9IHRoaXMuY29tbWVudCh0ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmlnbm9yZURlY29yYXRvcnMgJiYgdGhpcy5zdHJpbmdpZnkuY29udmVydFJhd0tleSAmJiBuYW1lLmluZGV4T2YodGhpcy5zdHJpbmdpZnkuY29udmVydFJhd0tleSkgPT09IDApIHtcbiAgICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLnJhdyh0ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0Q2hpbGQgPSB0aGlzLm5vZGUobmFtZSwgYXR0cmlidXRlcywgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsYXN0Q2hpbGQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY3JlYXRlIGFueSBlbGVtZW50cyB3aXRoOiBcIiArIG5hbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhc3RDaGlsZDtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgdmFyIGNoaWxkLCBpLCByZW1vdmVkO1xuICAgICAgaWYgKHRoaXMuaXNSb290KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbnNlcnQgZWxlbWVudHMgYXQgcm9vdCBsZXZlbFwiKTtcbiAgICAgIH1cbiAgICAgIGkgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgcmVtb3ZlZCA9IHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpKTtcbiAgICAgIGNoaWxkID0gdGhpcy5wYXJlbnQuZWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMucGFyZW50LmNoaWxkcmVuLCByZW1vdmVkKTtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICB2YXIgY2hpbGQsIGksIHJlbW92ZWQ7XG4gICAgICBpZiAodGhpcy5pc1Jvb3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGluc2VydCBlbGVtZW50cyBhdCByb290IGxldmVsXCIpO1xuICAgICAgfVxuICAgICAgaSA9IHRoaXMucGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgICByZW1vdmVkID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGkgKyAxKTtcbiAgICAgIGNoaWxkID0gdGhpcy5wYXJlbnQuZWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMucGFyZW50LmNoaWxkcmVuLCByZW1vdmVkKTtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSwgcmVmO1xuICAgICAgaWYgKHRoaXMuaXNSb290KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZW1vdmUgdGhlIHJvb3QgZWxlbWVudFwiKTtcbiAgICAgIH1cbiAgICAgIGkgPSB0aGlzLnBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpO1xuICAgICAgW10uc3BsaWNlLmFwcGx5KHRoaXMucGFyZW50LmNoaWxkcmVuLCBbaSwgaSAtIGkgKyAxXS5jb25jYXQocmVmID0gW10pKSwgcmVmO1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24obmFtZSwgYXR0cmlidXRlcywgdGV4dCkge1xuICAgICAgdmFyIGNoaWxkLCByZWY7XG4gICAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGVzID09IG51bGwpIHtcbiAgICAgICAgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgfVxuICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMudmFsdWVPZigpO1xuICAgICAgaWYgKCFpc09iamVjdChhdHRyaWJ1dGVzKSkge1xuICAgICAgICByZWYgPSBbYXR0cmlidXRlcywgdGV4dF0sIHRleHQgPSByZWZbMF0sIGF0dHJpYnV0ZXMgPSByZWZbMV07XG4gICAgICB9XG4gICAgICBjaGlsZCA9IG5ldyBYTUxFbGVtZW50KHRoaXMsIG5hbWUsIGF0dHJpYnV0ZXMpO1xuICAgICAgaWYgKHRleHQgIT0gbnVsbCkge1xuICAgICAgICBjaGlsZC50ZXh0KHRleHQpO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgY2hpbGQ7XG4gICAgICBjaGlsZCA9IG5ldyBYTUxUZXh0KHRoaXMsIHZhbHVlKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuY2RhdGEgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MQ0RhdGEodGhpcywgdmFsdWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5jb21tZW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBjaGlsZDtcbiAgICAgIGNoaWxkID0gbmV3IFhNTENvbW1lbnQodGhpcywgdmFsdWUpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgY2hpbGQgPSBuZXcgWE1MUmF3KHRoaXMsIHZhbHVlKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuZGVjbGFyYXRpb24gPSBmdW5jdGlvbih2ZXJzaW9uLCBlbmNvZGluZywgc3RhbmRhbG9uZSkge1xuICAgICAgdmFyIGRvYywgeG1sZGVjO1xuICAgICAgZG9jID0gdGhpcy5kb2N1bWVudCgpO1xuICAgICAgeG1sZGVjID0gbmV3IFhNTERlY2xhcmF0aW9uKGRvYywgdmVyc2lvbiwgZW5jb2RpbmcsIHN0YW5kYWxvbmUpO1xuICAgICAgZG9jLnhtbGRlYyA9IHhtbGRlYztcbiAgICAgIHJldHVybiBkb2Mucm9vdCgpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5kb2N0eXBlID0gZnVuY3Rpb24ocHViSUQsIHN5c0lEKSB7XG4gICAgICB2YXIgZG9jLCBkb2N0eXBlO1xuICAgICAgZG9jID0gdGhpcy5kb2N1bWVudCgpO1xuICAgICAgZG9jdHlwZSA9IG5ldyBYTUxEb2NUeXBlKGRvYywgcHViSUQsIHN5c0lEKTtcbiAgICAgIGRvYy5kb2N0eXBlID0gZG9jdHlwZTtcbiAgICAgIHJldHVybiBkb2N0eXBlO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXNSb290KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByb290IG5vZGUgaGFzIG5vIHBhcmVudC4gVXNlIGRvYygpIGlmIHlvdSBuZWVkIHRvIGdldCB0aGUgZG9jdW1lbnQgb2JqZWN0LlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUucm9vdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgaWYgKHRoaXMuaXNSb290KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSB0aGlzLnBhcmVudDtcbiAgICAgIHdoaWxlICghY2hpbGQuaXNSb290KSB7XG4gICAgICAgIGNoaWxkID0gY2hpbGQucGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5kb2N1bWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucm9vdCgpLmRvY3VtZW50T2JqZWN0O1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2N1bWVudCgpLnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIGlmICh0aGlzLmlzUm9vdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb290IG5vZGUgaGFzIG5vIHNpYmxpbmdzXCIpO1xuICAgICAgfVxuICAgICAgaSA9IHRoaXMucGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG4gICAgICBpZiAoaSA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSBhdCB0aGUgZmlyc3Qgbm9kZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGlsZHJlbltpIC0gMV07XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpO1xuICAgICAgaWYgKHRoaXMuaXNSb290KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvb3Qgbm9kZSBoYXMgbm8gc2libGluZ3NcIik7XG4gICAgICB9XG4gICAgICBpID0gdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcbiAgICAgIGlmIChpID09PSAtMSB8fCBpID09PSB0aGlzLnBhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFscmVhZHkgYXQgdGhlIGxhc3Qgbm9kZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGlsZHJlbltpICsgMV07XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmltcG9ydFhNTEJ1aWxkZXIgPSBmdW5jdGlvbih4bWxidWlsZGVyKSB7XG4gICAgICB2YXIgY2xvbmVkUm9vdDtcbiAgICAgIGNsb25lZFJvb3QgPSB4bWxidWlsZGVyLnJvb3QoKS5jbG9uZSgpO1xuICAgICAgY2xvbmVkUm9vdC5wYXJlbnQgPSB0aGlzO1xuICAgICAgY2xvbmVkUm9vdC5pc1Jvb3QgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjbG9uZWRSb290KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5lbGUgPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5ub2QgPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS50eHQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmRhdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jZGF0YSh2YWx1ZSk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLmNvbSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21tZW50KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuZG9jID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2N1bWVudCgpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5kZWMgPSBmdW5jdGlvbih2ZXJzaW9uLCBlbmNvZGluZywgc3RhbmRhbG9uZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjbGFyYXRpb24odmVyc2lvbiwgZW5jb2RpbmcsIHN0YW5kYWxvbmUpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5kdGQgPSBmdW5jdGlvbihwdWJJRCwgc3lzSUQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvY3R5cGUocHViSUQsIHN5c0lEKTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuZSA9IGZ1bmN0aW9uKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQobmFtZSwgYXR0cmlidXRlcywgdGV4dCk7XG4gICAgfTtcblxuICAgIFhNTE5vZGUucHJvdG90eXBlLm4gPSBmdW5jdGlvbihuYW1lLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlKG5hbWUsIGF0dHJpYnV0ZXMsIHRleHQpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS5kID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNkYXRhKHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21tZW50KHZhbHVlKTtcbiAgICB9O1xuXG4gICAgWE1MTm9kZS5wcm90b3R5cGUuciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yYXcodmFsdWUpO1xuICAgIH07XG5cbiAgICBYTUxOb2RlLnByb3RvdHlwZS51ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy51cCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gWE1MTm9kZTtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uLCBjcmVhdGU7XG5cbiAgY3JlYXRlID0gcmVxdWlyZSgnbG9kYXNoL2NyZWF0ZScpO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gWE1MUHJvY2Vzc2luZ0luc3RydWN0aW9uID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbihwYXJlbnQsIHRhcmdldCwgdmFsdWUpIHtcbiAgICAgIHRoaXMuc3RyaW5naWZ5ID0gcGFyZW50LnN0cmluZ2lmeTtcbiAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGluc3RydWN0aW9uIHRhcmdldFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudGFyZ2V0ID0gdGhpcy5zdHJpbmdpZnkuaW5zVGFyZ2V0KHRhcmdldCk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc3RyaW5naWZ5Lmluc1ZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlKFhNTFByb2Nlc3NpbmdJbnN0cnVjdGlvbi5wcm90b3R5cGUsIHRoaXMpO1xuICAgIH07XG5cbiAgICBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24ob3B0aW9ucywgbGV2ZWwpIHtcbiAgICAgIHZhciBpbmRlbnQsIG5ld2xpbmUsIG9mZnNldCwgcHJldHR5LCByLCByZWYsIHJlZjEsIHJlZjIsIHNwYWNlO1xuICAgICAgcHJldHR5ID0gKG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMucHJldHR5IDogdm9pZCAwKSB8fCBmYWxzZTtcbiAgICAgIGluZGVudCA9IChyZWYgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLmluZGVudCA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZiA6ICcgICc7XG4gICAgICBvZmZzZXQgPSAocmVmMSA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMub2Zmc2V0IDogdm9pZCAwKSAhPSBudWxsID8gcmVmMSA6IDA7XG4gICAgICBuZXdsaW5lID0gKHJlZjIgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLm5ld2xpbmUgOiB2b2lkIDApICE9IG51bGwgPyByZWYyIDogJ1xcbic7XG4gICAgICBsZXZlbCB8fCAobGV2ZWwgPSAwKTtcbiAgICAgIHNwYWNlID0gbmV3IEFycmF5KGxldmVsICsgb2Zmc2V0ICsgMSkuam9pbihpbmRlbnQpO1xuICAgICAgciA9ICcnO1xuICAgICAgaWYgKHByZXR0eSkge1xuICAgICAgICByICs9IHNwYWNlO1xuICAgICAgfVxuICAgICAgciArPSAnPD8nO1xuICAgICAgciArPSB0aGlzLnRhcmdldDtcbiAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgIHIgKz0gJyAnICsgdGhpcy52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHIgKz0gJz8+JztcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBuZXdsaW5lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb247XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjFcbihmdW5jdGlvbigpIHtcbiAgdmFyIFhNTE5vZGUsIFhNTFJhdywgY3JlYXRlLFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgY3JlYXRlID0gcmVxdWlyZSgnbG9kYXNoL2NyZWF0ZScpO1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTFJhdyA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFhNTFJhdywgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBYTUxSYXcocGFyZW50LCB0ZXh0KSB7XG4gICAgICBYTUxSYXcuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgcGFyZW50KTtcbiAgICAgIGlmICh0ZXh0ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByYXcgdGV4dFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnN0cmluZ2lmeS5yYXcodGV4dCk7XG4gICAgfVxuXG4gICAgWE1MUmF3LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZShYTUxSYXcucHJvdG90eXBlLCB0aGlzKTtcbiAgICB9O1xuXG4gICAgWE1MUmF3LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGxldmVsKSB7XG4gICAgICB2YXIgaW5kZW50LCBuZXdsaW5lLCBvZmZzZXQsIHByZXR0eSwgciwgcmVmLCByZWYxLCByZWYyLCBzcGFjZTtcbiAgICAgIHByZXR0eSA9IChvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLnByZXR0eSA6IHZvaWQgMCkgfHwgZmFsc2U7XG4gICAgICBpbmRlbnQgPSAocmVmID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5pbmRlbnQgOiB2b2lkIDApICE9IG51bGwgPyByZWYgOiAnICAnO1xuICAgICAgb2Zmc2V0ID0gKHJlZjEgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLm9mZnNldCA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjEgOiAwO1xuICAgICAgbmV3bGluZSA9IChyZWYyID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5uZXdsaW5lIDogdm9pZCAwKSAhPSBudWxsID8gcmVmMiA6ICdcXG4nO1xuICAgICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgICBzcGFjZSA9IG5ldyBBcnJheShsZXZlbCArIG9mZnNldCArIDEpLmpvaW4oaW5kZW50KTtcbiAgICAgIHIgPSAnJztcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBzcGFjZTtcbiAgICAgIH1cbiAgICAgIHIgKz0gdGhpcy52YWx1ZTtcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBuZXdsaW5lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxSYXc7XG5cbiAgfSkoWE1MTm9kZSk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOS4xXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxTdHJpbmdpZmllcixcbiAgICBiaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBYTUxTdHJpbmdpZmllciA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBYTUxTdHJpbmdpZmllcihvcHRpb25zKSB7XG4gICAgICB0aGlzLmFzc2VydExlZ2FsQ2hhciA9IGJpbmQodGhpcy5hc3NlcnRMZWdhbENoYXIsIHRoaXMpO1xuICAgICAgdmFyIGtleSwgcmVmLCB2YWx1ZTtcbiAgICAgIHRoaXMuYWxsb3dTdXJyb2dhdGVDaGFycyA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMuYWxsb3dTdXJyb2dhdGVDaGFycyA6IHZvaWQgMDtcbiAgICAgIHRoaXMubm9Eb3VibGVFbmNvZGluZyA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMubm9Eb3VibGVFbmNvZGluZyA6IHZvaWQgMDtcbiAgICAgIHJlZiA9IChvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLnN0cmluZ2lmeSA6IHZvaWQgMCkgfHwge307XG4gICAgICBmb3IgKGtleSBpbiByZWYpIHtcbiAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwocmVmLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgdmFsdWUgPSByZWZba2V5XTtcbiAgICAgICAgdGhpc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmVsZU5hbWUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhbCA9ICcnICsgdmFsIHx8ICcnO1xuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0TGVnYWxDaGFyKHZhbCk7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5lbGVUZXh0ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICAgIHJldHVybiB0aGlzLmFzc2VydExlZ2FsQ2hhcih0aGlzLmVsRXNjYXBlKHZhbCkpO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuY2RhdGEgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhbCA9ICcnICsgdmFsIHx8ICcnO1xuICAgICAgaWYgKHZhbC5tYXRjaCgvXV0+LykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBDREFUQSB0ZXh0OiBcIiArIHZhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5hc3NlcnRMZWdhbENoYXIodmFsKTtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmNvbW1lbnQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhbCA9ICcnICsgdmFsIHx8ICcnO1xuICAgICAgaWYgKHZhbC5tYXRjaCgvLS0vKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21tZW50IHRleHQgY2Fubm90IGNvbnRhaW4gZG91YmxlLWh5cGVuOiBcIiArIHZhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5hc3NlcnRMZWdhbENoYXIodmFsKTtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLnJhdyA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuICcnICsgdmFsIHx8ICcnO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuYXR0TmFtZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgcmV0dXJuICcnICsgdmFsIHx8ICcnO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuYXR0VmFsdWUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhbCA9ICcnICsgdmFsIHx8ICcnO1xuICAgICAgcmV0dXJuIHRoaXMuYXR0RXNjYXBlKHZhbCk7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5pbnNUYXJnZXQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiAnJyArIHZhbCB8fCAnJztcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmluc1ZhbHVlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICAgIGlmICh2YWwubWF0Y2goL1xcPz4vKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gdmFsdWU6IFwiICsgdmFsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS54bWxWZXJzaW9uID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICAgIGlmICghdmFsLm1hdGNoKC8xXFwuWzAtOV0rLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2ZXJzaW9uIG51bWJlcjogXCIgKyB2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLnhtbEVuY29kaW5nID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YWwgPSAnJyArIHZhbCB8fCAnJztcbiAgICAgIGlmICghdmFsLm1hdGNoKC9eW0EtWmEtel0oPzpbQS1aYS16MC05Ll8tXXwtKSokLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBlbmNvZGluZzogXCIgKyB2YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLnhtbFN0YW5kYWxvbmUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIFwieWVzXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJub1wiO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuZHRkUHViSUQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiAnJyArIHZhbCB8fCAnJztcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmR0ZFN5c0lEID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gJycgKyB2YWwgfHwgJyc7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5kdGRFbGVtZW50VmFsdWUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiAnJyArIHZhbCB8fCAnJztcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmR0ZEF0dFR5cGUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiAnJyArIHZhbCB8fCAnJztcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmR0ZEF0dERlZmF1bHQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJycgKyB2YWwgfHwgJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuZHRkRW50aXR5VmFsdWUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiAnJyArIHZhbCB8fCAnJztcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmR0ZE5EYXRhID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gJycgKyB2YWwgfHwgJyc7XG4gICAgfTtcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5jb252ZXJ0QXR0S2V5ID0gJ0AnO1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmNvbnZlcnRQSUtleSA9ICc/JztcblxuICAgIFhNTFN0cmluZ2lmaWVyLnByb3RvdHlwZS5jb252ZXJ0VGV4dEtleSA9ICcjdGV4dCc7XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuY29udmVydENEYXRhS2V5ID0gJyNjZGF0YSc7XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuY29udmVydENvbW1lbnRLZXkgPSAnI2NvbW1lbnQnO1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmNvbnZlcnRSYXdLZXkgPSAnI3Jhdyc7XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuYXNzZXJ0TGVnYWxDaGFyID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgICB2YXIgY2hhcnMsIGNocjtcbiAgICAgIGlmICh0aGlzLmFsbG93U3Vycm9nYXRlQ2hhcnMpIHtcbiAgICAgICAgY2hhcnMgPSAvW1xcdTAwMDAtXFx1MDAwOFxcdTAwMEItXFx1MDAwQ1xcdTAwMEUtXFx1MDAxRlxcdUZGRkUtXFx1RkZGRl0vO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhcnMgPSAvW1xcdTAwMDAtXFx1MDAwOFxcdTAwMEItXFx1MDAwQ1xcdTAwMEUtXFx1MDAxRlxcdUQ4MDAtXFx1REZGRlxcdUZGRkUtXFx1RkZGRl0vO1xuICAgICAgfVxuICAgICAgY2hyID0gc3RyLm1hdGNoKGNoYXJzKTtcbiAgICAgIGlmIChjaHIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjaGFyYWN0ZXIgKFwiICsgY2hyICsgXCIpIGluIHN0cmluZzogXCIgKyBzdHIgKyBcIiBhdCBpbmRleCBcIiArIGNoci5pbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH07XG5cbiAgICBYTUxTdHJpbmdpZmllci5wcm90b3R5cGUuZWxFc2NhcGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciBhbXByZWdleDtcbiAgICAgIGFtcHJlZ2V4ID0gdGhpcy5ub0RvdWJsZUVuY29kaW5nID8gLyg/ISZcXFMrOykmL2cgOiAvJi9nO1xuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKGFtcHJlZ2V4LCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpLnJlcGxhY2UoL1xcci9nLCAnJiN4RDsnKTtcbiAgICB9O1xuXG4gICAgWE1MU3RyaW5naWZpZXIucHJvdG90eXBlLmF0dEVzY2FwZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgdmFyIGFtcHJlZ2V4O1xuICAgICAgYW1wcmVnZXggPSB0aGlzLm5vRG91YmxlRW5jb2RpbmcgPyAvKD8hJlxcUys7KSYvZyA6IC8mL2c7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoYW1wcmVnZXgsICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxTdHJpbmdpZmllcjtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MTm9kZSwgWE1MVGV4dCwgY3JlYXRlLFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgY3JlYXRlID0gcmVxdWlyZSgnbG9kYXNoL2NyZWF0ZScpO1xuXG4gIFhNTE5vZGUgPSByZXF1aXJlKCcuL1hNTE5vZGUnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFhNTFRleHQgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChYTUxUZXh0LCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFhNTFRleHQocGFyZW50LCB0ZXh0KSB7XG4gICAgICBYTUxUZXh0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgICBpZiAodGV4dCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgZWxlbWVudCB0ZXh0XCIpO1xuICAgICAgfVxuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc3RyaW5naWZ5LmVsZVRleHQodGV4dCk7XG4gICAgfVxuXG4gICAgWE1MVGV4dC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGUoWE1MVGV4dC5wcm90b3R5cGUsIHRoaXMpO1xuICAgIH07XG5cbiAgICBYTUxUZXh0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGxldmVsKSB7XG4gICAgICB2YXIgaW5kZW50LCBuZXdsaW5lLCBvZmZzZXQsIHByZXR0eSwgciwgcmVmLCByZWYxLCByZWYyLCBzcGFjZTtcbiAgICAgIHByZXR0eSA9IChvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLnByZXR0eSA6IHZvaWQgMCkgfHwgZmFsc2U7XG4gICAgICBpbmRlbnQgPSAocmVmID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5pbmRlbnQgOiB2b2lkIDApICE9IG51bGwgPyByZWYgOiAnICAnO1xuICAgICAgb2Zmc2V0ID0gKHJlZjEgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLm9mZnNldCA6IHZvaWQgMCkgIT0gbnVsbCA/IHJlZjEgOiAwO1xuICAgICAgbmV3bGluZSA9IChyZWYyID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucy5uZXdsaW5lIDogdm9pZCAwKSAhPSBudWxsID8gcmVmMiA6ICdcXG4nO1xuICAgICAgbGV2ZWwgfHwgKGxldmVsID0gMCk7XG4gICAgICBzcGFjZSA9IG5ldyBBcnJheShsZXZlbCArIG9mZnNldCArIDEpLmpvaW4oaW5kZW50KTtcbiAgICAgIHIgPSAnJztcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBzcGFjZTtcbiAgICAgIH1cbiAgICAgIHIgKz0gdGhpcy52YWx1ZTtcbiAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgciArPSBuZXdsaW5lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfTtcblxuICAgIHJldHVybiBYTUxUZXh0O1xuXG4gIH0pKFhNTE5vZGUpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MQnVpbGRlciwgYXNzaWduO1xuXG4gIGFzc2lnbiA9IHJlcXVpcmUoJ2xvZGFzaC9hc3NpZ24nKTtcblxuICBYTUxCdWlsZGVyID0gcmVxdWlyZSgnLi9YTUxCdWlsZGVyJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24obmFtZSwgeG1sZGVjLCBkb2N0eXBlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGFzc2lnbih7fSwgeG1sZGVjLCBkb2N0eXBlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IFhNTEJ1aWxkZXIobmFtZSwgb3B0aW9ucykucm9vdCgpO1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcbiIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcbiIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG4iLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpLFxuICAgIHNldENhY2hlQWRkID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVBZGQnKSxcbiAgICBzZXRDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX3NldENhY2hlSGFzJyk7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID8gdmFsdWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0Q2FjaGU7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWFrTWFwO1xuIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICB2YXIgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZXZlcnlgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUV2ZXJ5KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFdmVyeTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheU1hcDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVNvbWU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ247XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlQ3JlYXRlKHByb3RvKSB7XG4gIHJldHVybiBpc09iamVjdChwcm90bykgPyBvYmplY3RDcmVhdGUocHJvdG8pIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNyZWF0ZTtcbiIsInZhciBiYXNlRm9yT3duID0gcmVxdWlyZSgnLi9fYmFzZUZvck93bicpLFxuICAgIGNyZWF0ZUJhc2VFYWNoID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUVhY2g7XG4iLCJ2YXIgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmV2ZXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgXG4gKi9cbmZ1bmN0aW9uIGJhc2VFdmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdCA9ICEhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUV2ZXJ5O1xuIiwidmFyIGNyZWF0ZUJhc2VGb3IgPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRm9yJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuIiwidmFyIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvck93bjtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBpc0tleShwYXRoLCBvYmplY3QpID8gW3BhdGhdIDogY2FzdFBhdGgocGF0aCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG4iLCJ2YXIgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhcyhvYmplY3QsIGtleSkge1xuICAvLyBBdm9pZCBhIGJ1ZyBpbiBJRSAxMC0xMSB3aGVyZSBvYmplY3RzIHdpdGggYSBbW1Byb3RvdHlwZV1dIG9mIGBudWxsYCxcbiAgLy8gdGhhdCBhcmUgY29tcG9zZWQgZW50aXJlbHkgb2YgaW5kZXggcHJvcGVydGllcywgcmV0dXJuIGBmYWxzZWAgZm9yXG4gIC8vIGBoYXNPd25Qcm9wZXJ0eWAgY2hlY2tzIG9mIHRoZW0uXG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSB8fFxuICAgICh0eXBlb2Ygb2JqZWN0ID09ICdvYmplY3QnICYmIGtleSBpbiBvYmplY3QgJiYgZ2V0UHJvdG90eXBlKG9iamVjdCkgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VIYXM7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuIiwidmFyIGJhc2VJc0VxdWFsRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsRGVlcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2JpdG1hc2tdIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuXG4gKiAgVGhlIGJpdG1hc2sgbWF5IGJlIGNvbXBvc2VkIG9mIHRoZSBmb2xsb3dpbmcgZmxhZ3M6XG4gKiAgICAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgICAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3QodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiYXNlSXNFcXVhbCwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vX2VxdWFsQnlUYWcnKSxcbiAgICBlcXVhbE9iamVjdHMgPSByZXF1aXJlKCcuL19lcXVhbE9iamVjdHMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNIb3N0T2JqZWN0ID0gcmVxdWlyZSgnLi9faXNIb3N0T2JqZWN0JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY29tcGFyaXNvbiBzdHlsZXMuICovXG52YXIgUEFSVElBTF9DT01QQVJFX0ZMQUcgPSAyO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYml0bWFza10gVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcbiAqICBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBhcnJheVRhZyxcbiAgICAgIG90aFRhZyA9IGFycmF5VGFnO1xuXG4gIGlmICghb2JqSXNBcnIpIHtcbiAgICBvYmpUYWcgPSBnZXRUYWcob2JqZWN0KTtcbiAgICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgfVxuICBpZiAoIW90aElzQXJyKSB7XG4gICAgb3RoVGFnID0gZ2V0VGFnKG90aGVyKTtcbiAgICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcbiAgfVxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnICYmICFpc0hvc3RPYmplY3Qob2JqZWN0KSxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyAmJiAhaXNIb3N0T2JqZWN0KG90aGVyKSxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbERlZXA7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY29tcGFyaXNvbiBzdHlsZXMuICovXG52YXIgVU5PUkRFUkVEX0NPTVBBUkVfRkxBRyA9IDEsXG4gICAgUEFSVElBTF9DT01QQVJFX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBjdXN0b21pemVyLCBVTk9SREVSRURfQ09NUEFSRV9GTEFHIHwgUEFSVElBTF9DT01QQVJFX0ZMQUcsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWF0Y2g7XG4iLCJ2YXIgYmFzZU1hdGNoZXMgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlcycpLFxuICAgIGJhc2VNYXRjaGVzUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlc1Byb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIHByb3BlcnR5ID0gcmVxdWlyZSgnLi9wcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJdGVyYXRlZTtcbiIsIi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gT2JqZWN0LmtleXM7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCBza2lwIHRoZSBjb25zdHJ1Y3RvclxuICogcHJvcGVydHkgb2YgcHJvdG90eXBlcyBvciB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIG5hdGl2ZUtleXMoT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuIiwidmFyIGJhc2VJc01hdGNoID0gcmVxdWlyZSgnLi9fYmFzZUlzTWF0Y2gnKSxcbiAgICBnZXRNYXRjaERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXRjaERhdGEnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKSxcbiAgICBnZXQgPSByZXF1aXJlKCcuL2dldCcpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjb21wYXJpc29uIHN0eWxlcy4gKi9cbnZhciBVTk9SREVSRURfQ09NUEFSRV9GTEFHID0gMSxcbiAgICBQQVJUSUFMX0NPTVBBUkVfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIHVuZGVmaW5lZCwgVU5PUkRFUkVEX0NPTVBBUkVfRkxBRyB8IFBBUlRJQUxfQ09NUEFSRV9GTEFHKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHk7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5RGVlcDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1BhaXJzYCBhbmQgYF8udG9QYWlyc0luYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5XG4gKiBvZiBrZXktdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzIG9mIGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvUGFpcnMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBba2V5LCBvYmplY3Rba2V5XV07XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1BhaXJzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IHN0cmluZ1RvUGF0aCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZ2xvYmFsIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7bnVsbHxPYmplY3R9IFJldHVybnMgYHZhbHVlYCBpZiBpdCdzIGEgZ2xvYmFsIG9iamVjdCwgZWxzZSBgbnVsbGAuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrR2xvYmFsKHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgJiYgdmFsdWUuT2JqZWN0ID09PSBPYmplY3QpID8gdmFsdWUgOiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrR2xvYmFsO1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogc291cmNlW2tleV07XG5cbiAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weU9iamVjdDtcbiIsInZhciBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyksXG4gICAgcmVzdCA9IHJlcXVpcmUoJy4vcmVzdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiByZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXNzaWduZXI7XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUVhY2g7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuIiwidmFyIGJhc2VUb1BhaXJzID0gcmVxdWlyZSgnLi9fYmFzZVRvUGFpcnMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpLFxuICAgIHNldFRvUGFpcnMgPSByZXF1aXJlKCcuL19zZXRUb1BhaXJzJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgYF8udG9QYWlyc2Agb3IgYF8udG9QYWlyc0luYCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBhIGdpdmVuIG9iamVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhaXJzIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVUb1BhaXJzKGtleXNGdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKG9iamVjdCk7XG4gICAgaWYgKHRhZyA9PSBtYXBUYWcpIHtcbiAgICAgIHJldHVybiBtYXBUb0FycmF5KG9iamVjdCk7XG4gICAgfVxuICAgIGlmICh0YWcgPT0gc2V0VGFnKSB7XG4gICAgICByZXR1cm4gc2V0VG9QYWlycyhvYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZVRvUGFpcnMob2JqZWN0LCBrZXlzRnVuYyhvYmplY3QpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUb1BhaXJzO1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheVNvbWUgPSByZXF1aXJlKCcuL19hcnJheVNvbWUnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY29tcGFyaXNvbiBzdHlsZXMuICovXG52YXIgVU5PUkRFUkVEX0NPTVBBUkVfRkxBRyA9IDEsXG4gICAgUEFSVElBTF9DT01QQVJFX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIFBBUlRJQUxfQ09NUEFSRV9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgVU5PUkRFUkVEX0NPTVBBUkVfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIXNlZW4uaGFzKG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5hZGQob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEFycmF5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNvbXBhcmlzb24gc3R5bGVzLiAqL1xudmFyIFVOT1JERVJFRF9DT01QQVJFX0ZMQUcgPSAxLFxuICAgIFBBUlRJQUxfQ09NUEFSRV9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYFxuICogIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1iZXJzLCBkYXRlcyB0byBtaWxsaXNlY29uZHMgYW5kXG4gICAgICAvLyBib29sZWFucyB0byBgMWAgb3IgYDBgIHRyZWF0aW5nIGludmFsaWQgZGF0ZXMgY29lcmNlZCB0byBgTmFOYCBhc1xuICAgICAgLy8gbm90IGVxdWFsLlxuICAgICAgcmV0dXJuICtvYmplY3QgPT0gK290aGVyO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIFRyZWF0IGBOYU5gIHZzLiBgTmFOYCBhcyBlcXVhbC5cbiAgICAgIHJldHVybiAob2JqZWN0ICE9ICtvYmplY3QpID8gb3RoZXIgIT0gK290aGVyIDogb2JqZWN0ID09ICtvdGhlcjtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIFBBUlRJQUxfQ09NUEFSRV9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gVU5PUkRFUkVEX0NPTVBBUkVfRkxBRztcbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICByZXR1cm4gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjayk7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEJ5VGFnO1xuIiwidmFyIGJhc2VIYXMgPSByZXF1aXJlKCcuL19iYXNlSGFzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjb21wYXJpc29uIHN0eWxlcy4gKi9cbnZhciBQQVJUSUFMX0NPTVBBUkVfRkxBRyA9IDI7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcbiAqICBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIFBBUlRJQUxfQ09NUEFSRV9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogYmFzZUhhcyhvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbE9iamVjdHM7XG4iLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSB2YWx1ZSBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGF2b2lkIGFcbiAqIFtKSVQgYnVnXShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNzkyKSB0aGF0IGFmZmVjdHNcbiAqIFNhZmFyaSBvbiBhdCBsZWFzdCBpT1MgOC4xLTguMyBBUk02NC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFwibGVuZ3RoXCIgdmFsdWUuXG4gKi9cbnZhciBnZXRMZW5ndGggPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldExlbmd0aDtcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgdG9QYWlycyA9IHJlcXVpcmUoJy4vdG9QYWlycycpO1xuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IHRvUGFpcnMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgcmVzdWx0W2xlbmd0aF1bMl0gPSBpc1N0cmljdENvbXBhcmFibGUocmVzdWx0W2xlbmd0aF1bMV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWF0Y2hEYXRhO1xuIiwidmFyIGlzTmF0aXZlID0gcmVxdWlyZSgnLi9pc05hdGl2ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG4gIHJldHVybiBpc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG4iLCIvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0UHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG4vKipcbiAqIEdldHMgdGhlIGBbW1Byb3RvdHlwZV1dYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtudWxsfE9iamVjdH0gUmV0dXJucyB0aGUgYFtbUHJvdG90eXBlXV1gLlxuICovXG5mdW5jdGlvbiBnZXRQcm90b3R5cGUodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZUdldFByb3RvdHlwZShPYmplY3QodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG4iLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFRhZyh2YWx1ZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExLFxuLy8gZm9yIGRhdGEgdmlld3MgaW4gRWRnZSwgYW5kIHByb21pc2VzIGluIE5vZGUuanMuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc1N0cmluZyA9IHJlcXVpcmUoJy4vaXNTdHJpbmcnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBpc0tleShwYXRoLCBvYmplY3QpID8gW3BhdGhdIDogY2FzdFBhdGgocGF0aCk7XG5cbiAgdmFyIHJlc3VsdCxcbiAgICAgIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IG9iamVjdCA/IG9iamVjdC5sZW5ndGggOiAwO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNTdHJpbmcob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQYXRoO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyBkYXRhW2tleV0gIT09IHVuZGVmaW5lZCA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc1N0cmluZyA9IHJlcXVpcmUoJy4vaXNTdHJpbmcnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGluZGV4IGtleXMgZm9yIGBvYmplY3RgIHZhbHVlcyBvZiBhcnJheXMsXG4gKiBgYXJndW1lbnRzYCBvYmplY3RzLCBhbmQgc3RyaW5ncywgb3RoZXJ3aXNlIGBudWxsYCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fG51bGx9IFJldHVybnMgaW5kZXgga2V5cywgZWxzZSBgbnVsbGAuXG4gKi9cbmZ1bmN0aW9uIGluZGV4S2V5cyhvYmplY3QpIHtcbiAgdmFyIGxlbmd0aCA9IG9iamVjdCA/IG9iamVjdC5sZW5ndGggOiB1bmRlZmluZWQ7XG4gIGlmIChpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzU3RyaW5nKG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSkpIHtcbiAgICByZXR1cm4gYmFzZVRpbWVzKGxlbmd0aCwgU3RyaW5nKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbmRleEtleXM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSG9zdE9iamVjdDtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXRlcmF0ZWVDYWxsO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaWN0Q29tcGFyYWJsZTtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFRvQXJyYXk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuIiwidmFyIGNoZWNrR2xvYmFsID0gcmVxdWlyZSgnLi9fY2hlY2tHbG9iYWwnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHZhbHVlcyBhcmUgb2YgdGhlIGxhbmd1YWdlIHR5cGUgYE9iamVjdGAuICovXG52YXIgb2JqZWN0VHlwZXMgPSB7XG4gICdmdW5jdGlvbic6IHRydWUsXG4gICdvYmplY3QnOiB0cnVlXG59O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gKG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlKVxuICA/IGV4cG9ydHNcbiAgOiB1bmRlZmluZWQ7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gKG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlKVxuICA/IG1vZHVsZVxuICA6IHVuZGVmaW5lZDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gY2hlY2tHbG9iYWwoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSAmJiB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSBjaGVja0dsb2JhbChvYmplY3RUeXBlc1t0eXBlb2Ygc2VsZl0gJiYgc2VsZik7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgd2luZG93YC4gKi9cbnZhciBmcmVlV2luZG93ID0gY2hlY2tHbG9iYWwob2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93KTtcblxuLyoqIERldGVjdCBgdGhpc2AgYXMgdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgdGhpc0dsb2JhbCA9IGNoZWNrR2xvYmFsKG9iamVjdFR5cGVzW3R5cGVvZiB0aGlzXSAmJiB0aGlzKTtcblxuLyoqXG4gKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LlxuICpcbiAqIFRoZSBgdGhpc2AgdmFsdWUgaXMgdXNlZCBpZiBpdCdzIHRoZSBnbG9iYWwgb2JqZWN0IHRvIGF2b2lkIEdyZWFzZW1vbmtleSdzXG4gKiByZXN0cmljdGVkIGB3aW5kb3dgIG9iamVjdCwgb3RoZXJ3aXNlIHRoZSBgd2luZG93YCBvYmplY3QgaXMgdXNlZC5cbiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8XG4gICgoZnJlZVdpbmRvdyAhPT0gKHRoaXNHbG9iYWwgJiYgdGhpc0dsb2JhbC53aW5kb3cpKSAmJiBmcmVlV2luZG93KSB8fFxuICAgIGZyZWVTZWxmIHx8IHRoaXNHbG9iYWwgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuIiwiLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVBZGQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVIYXM7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvQXJyYXk7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGl0cyB2YWx1ZS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlLXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBzZXRUb1BhaXJzKHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFt2YWx1ZSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb1BhaXJzO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX19bJ2RlbGV0ZSddKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrSGFzO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgY2FjaGUgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoY2FjaGUgaW5zdGFuY2VvZiBMaXN0Q2FjaGUgJiYgY2FjaGUuX19kYXRhX18ubGVuZ3RoID09IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICBjYWNoZSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUoY2FjaGUuX19kYXRhX18pO1xuICB9XG4gIGNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG4iLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHRvU3RyaW5nKHN0cmluZykucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1RvUGF0aDtcbiIsInZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9LZXk7XG4iLCIvKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAgY3JlYXRlQXNzaWduZXIgPSByZXF1aXJlKCcuL19jcmVhdGVBc3NpZ25lcicpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKiBEZXRlY3QgaWYgcHJvcGVydGllcyBzaGFkb3dpbmcgdGhvc2Ugb24gYE9iamVjdC5wcm90b3R5cGVgIGFyZSBub24tZW51bWVyYWJsZS4gKi9cbnZhciBub25FbnVtU2hhZG93cyA9ICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgJ3ZhbHVlT2YnOiAxIH0sICd2YWx1ZU9mJyk7XG5cbi8qKlxuICogQXNzaWducyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICogU3Vic2VxdWVudCBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYE9iamVjdC5hc3NpZ25gXShodHRwczovL21kbi5pby9PYmplY3QvYXNzaWduKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMTAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmFzc2lnbkluXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5jID0gMztcbiAqIH1cbiAqXG4gKiBmdW5jdGlvbiBCYXIoKSB7XG4gKiAgIHRoaXMuZSA9IDU7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5kID0gNDtcbiAqIEJhci5wcm90b3R5cGUuZiA9IDY7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzLCAnZSc6IDUgfVxuICovXG52YXIgYXNzaWduID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgaWYgKG5vbkVudW1TaGFkb3dzIHx8IGlzUHJvdG90eXBlKHNvdXJjZSkgfHwgaXNBcnJheUxpa2Uoc291cmNlKSkge1xuICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfVxuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ247XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICogdmFyIGdldHRlciA9IF8uY29uc3RhbnQob2JqZWN0KTtcbiAqXG4gKiBnZXR0ZXIoKSA9PT0gb2JqZWN0O1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuIiwidmFyIGJhc2VBc3NpZ24gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduJyksXG4gICAgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxuICogYHByb3BlcnRpZXNgIG9iamVjdCBpcyBnaXZlbiwgaXRzIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzXG4gKiBhcmUgYXNzaWduZWQgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFRoZSBwcm9wZXJ0aWVzIHRvIGFzc2lnbiB0byB0aGUgb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gKiAgIHRoaXMueCA9IDA7XG4gKiAgIHRoaXMueSA9IDA7XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gQ2lyY2xlKCkge1xuICogICBTaGFwZS5jYWxsKHRoaXMpO1xuICogfVxuICpcbiAqIENpcmNsZS5wcm90b3R5cGUgPSBfLmNyZWF0ZShTaGFwZS5wcm90b3R5cGUsIHtcbiAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXG4gKiB9KTtcbiAqXG4gKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAqIGNpcmNsZSBpbnN0YW5jZW9mIENpcmNsZTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBjaXJjbGUgaW5zdGFuY2VvZiBTaGFwZTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICByZXR1cm4gcHJvcGVydGllcyA/IGJhc2VBc3NpZ24ocmVzdWx0LCBwcm9wZXJ0aWVzKSA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGU7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICogdmFyIG90aGVyID0geyAndXNlcic6ICdmcmVkJyB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG4iLCJ2YXIgYXJyYXlFdmVyeSA9IHJlcXVpcmUoJy4vX2FycmF5RXZlcnknKSxcbiAgICBiYXNlRXZlcnkgPSByZXF1aXJlKCcuL19iYXNlRXZlcnknKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbGwqKiBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAuXG4gKiBJdGVyYXRpb24gaXMgc3RvcHBlZCBvbmNlIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb258T2JqZWN0fHN0cmluZ30gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XVxuICogIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10sIEJvb2xlYW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gKiBdO1xuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmV2ZXJ5KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5ldmVyeSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5ldmVyeSh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUV2ZXJ5IDogYmFzZUV2ZXJ5O1xuICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkpIHtcbiAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV2ZXJ5O1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgdXNlZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldDtcbiIsInZhciBiYXNlSGFzSW4gPSByZXF1aXJlKCcuL19iYXNlSGFzSW4nKSxcbiAgICBoYXNQYXRoID0gcmVxdWlyZSgnLi9faGFzUGF0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzSW47XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGdpdmVuIHRvIGl0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gKlxuICogXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3Q7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgLy8gU2FmYXJpIDguMSBpbmNvcnJlY3RseSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsInZhciBnZXRMZW5ndGggPSByZXF1aXJlKCcuL19nZXRMZW5ndGgnKSxcbiAgICBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKGdldExlbmd0aCh2YWx1ZSkpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2VPYmplY3Q7XG4iLCJ2YXIgY29uc3RhbnQgPSByZXF1aXJlKCcuL2NvbnN0YW50JyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHZhbHVlcyBhcmUgb2YgdGhlIGxhbmd1YWdlIHR5cGUgYE9iamVjdGAuICovXG52YXIgb2JqZWN0VHlwZXMgPSB7XG4gICdmdW5jdGlvbic6IHRydWUsXG4gICdvYmplY3QnOiB0cnVlXG59O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gKG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlKVxuICA/IGV4cG9ydHNcbiAgOiB1bmRlZmluZWQ7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gKG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlKVxuICA/IG1vZHVsZVxuICA6IHVuZGVmaW5lZDtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gKGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cylcbiAgPyBmcmVlRXhwb3J0c1xuICA6IHVuZGVmaW5lZDtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSAhQnVmZmVyID8gY29uc3RhbnQoZmFsc2UpIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQnVmZmVyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbiIsInZhciBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyksXG4gICAgaXNTdHJpbmcgPSByZXF1aXJlKCcuL2lzU3RyaW5nJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKiBEZXRlY3QgaWYgcHJvcGVydGllcyBzaGFkb3dpbmcgdGhvc2Ugb24gYE9iamVjdC5wcm90b3R5cGVgIGFyZSBub24tZW51bWVyYWJsZS4gKi9cbnZhciBub25FbnVtU2hhZG93cyA9ICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgJ3ZhbHVlT2YnOiAxIH0sICd2YWx1ZU9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAqXG4gKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAqIHByb3BlcnRpZXMuXG4gKlxuICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRW1wdHkobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KHRydWUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSgxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAoaXNBcnJheSh2YWx1ZSkgfHwgaXNTdHJpbmcodmFsdWUpIHx8IGlzRnVuY3Rpb24odmFsdWUuc3BsaWNlKSB8fFxuICAgICAgICBpc0FyZ3VtZW50cyh2YWx1ZSkgfHwgaXNCdWZmZXIodmFsdWUpKSkge1xuICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICB9XG4gIGlmIChpc09iamVjdExpa2UodmFsdWUpKSB7XG4gICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSk7XG4gICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gIShub25FbnVtU2hhZG93cyAmJiBrZXlzKHZhbHVlKS5sZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRW1wdHk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA4IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCB3ZWFrIG1hcCBjb25zdHJ1Y3RvcnMsXG4gIC8vIGFuZCBQaGFudG9tSlMgMS45IHdoaWNoIHJldHVybnMgJ2Z1bmN0aW9uJyBmb3IgYE5vZGVMaXN0YCBpbnN0YW5jZXMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNIb3N0T2JqZWN0ID0gcmVxdWlyZSgnLi9faXNIb3N0T2JqZWN0JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOYXRpdmUoXyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05hdGl2ZTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N0cmluZygnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N0cmluZygxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAoIWlzQXJyYXkodmFsdWUpICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmluZztcbiIsInZhciBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcbiIsInZhciBiYXNlSGFzID0gcmVxdWlyZSgnLi9fYmFzZUhhcycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpbmRleEtleXMgPSByZXF1aXJlKCcuL19pbmRleEtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCk7XG4gIGlmICghKGlzUHJvdG8gfHwgaXNBcnJheUxpa2Uob2JqZWN0KSkpIHtcbiAgICByZXR1cm4gYmFzZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgaW5kZXhlcyA9IGluZGV4S2V5cyhvYmplY3QpLFxuICAgICAgc2tpcEluZGV4ZXMgPSAhIWluZGV4ZXMsXG4gICAgICByZXN1bHQgPSBpbmRleGVzIHx8IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKGJhc2VIYXMob2JqZWN0LCBrZXkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKGtleSA9PSAnbGVuZ3RoJyB8fCBpc0luZGV4KGtleSwgbGVuZ3RoKSkpICYmXG4gICAgICAgICEoaXNQcm90byAmJiBrZXkgPT0gJ2NvbnN0cnVjdG9yJykpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEFzc2lnbiBjYWNoZSB0byBgXy5tZW1vaXplYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuIiwidmFyIGJhc2VQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eScpLFxuICAgIGJhc2VQcm9wZXJ0eURlZXAgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHlEZWVwJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3BlcnR5O1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKSxcbiAgICB0b0ludGVnZXIgPSByZXF1aXJlKCcuL3RvSW50ZWdlcicpO1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICogY3JlYXRlZCBmdW5jdGlvbiBhbmQgYXJndW1lbnRzIGZyb20gYHN0YXJ0YCBhbmQgYmV5b25kIHByb3ZpZGVkIGFzXG4gKiBhbiBhcnJheS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gKiBbcmVzdCBwYXJhbWV0ZXJdKGh0dHBzOi8vbWRuLmlvL3Jlc3RfcGFyYW1ldGVycykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBzYXkgPSBfLnJlc3QoZnVuY3Rpb24od2hhdCwgbmFtZXMpIHtcbiAqICAgcmV0dXJuIHdoYXQgKyAnICcgKyBfLmluaXRpYWwobmFtZXMpLmpvaW4oJywgJykgK1xuICogICAgIChfLnNpemUobmFtZXMpID4gMSA/ICcsICYgJyA6ICcnKSArIF8ubGFzdChuYW1lcyk7XG4gKiB9KTtcbiAqXG4gKiBzYXkoJ2hlbGxvJywgJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnKTtcbiAqIC8vID0+ICdoZWxsbyBmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAqL1xuZnVuY3Rpb24gcmVzdChmdW5jLCBzdGFydCkge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiB0b0ludGVnZXIoc3RhcnQpLCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBzd2l0Y2ggKHN0YXJ0KSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJyYXkpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFycmF5KTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdLCBhcnJheSk7XG4gICAgfVxuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIGluZGV4ID0gLTE7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gYXJyYXk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVzdDtcbiIsInZhciB0b051bWJlciA9IHJlcXVpcmUoJy4vdG9OdW1iZXInKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBmaW5pdGUgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMi4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9GaW5pdGUoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvRmluaXRlKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0Zpbml0ZSgnMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgfVxuICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7XG4gICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcbiAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICB9XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9GaW5pdGU7XG4iLCJ2YXIgdG9GaW5pdGUgPSByZXF1aXJlKCcuL3RvRmluaXRlJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0ludGVnZXI7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gaXNGdW5jdGlvbih2YWx1ZS52YWx1ZU9mKSA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9OdW1iZXI7XG4iLCJ2YXIgY3JlYXRlVG9QYWlycyA9IHJlcXVpcmUoJy4vX2NyZWF0ZVRvUGFpcnMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgXG4gKiB3aGljaCBjYW4gYmUgY29uc3VtZWQgYnkgYF8uZnJvbVBhaXJzYC4gSWYgYG9iamVjdGAgaXMgYSBtYXAgb3Igc2V0LCBpdHNcbiAqIGVudHJpZXMgYXJlIHJldHVybmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBhbGlhcyBlbnRyaWVzXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy50b1BhaXJzKG5ldyBGb28pO1xuICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xudmFyIHRvUGFpcnMgPSBjcmVhdGVUb1BhaXJzKGtleXMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRvUGFpcnM7XG4iLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0UGFuZWxNYW5hZ2VyIDogcmVxdWlyZSgnLi9zcmMvUGFuZWxNYW5hZ2VyJyksXHJcblx0UGFuZWw6IHJlcXVpcmUoJy4vc3JjL1BhbmVsJyksXHJcblx0QmFzZVRyYW5zaXRpb246IHJlcXVpcmUoJy4vc3JjL3RyYW5zaXRpb24vQmFzZVRyYW5zaXRpb24nKSxcclxuXHRTaG93VHJhbnNpdGlvbk1vdmVtZW50OiByZXF1aXJlKCcuL3NyYy90cmFuc2l0aW9uL3Nob3cvU2hvd1RyYW5zaXRpb25Nb3ZlbWVudCcpLFxyXG5cdFNob3dUcmFuc2l0aW9uQWxwaGFBbmRNb3ZlbWVudDogcmVxdWlyZSgnLi9zcmMvdHJhbnNpdGlvbi9zaG93L1Nob3dUcmFuc2l0aW9uQWxwaGFBbmRNb3ZlbWVudCcpLFxyXG5cdFNob3dUcmFuc2l0aW9uQWxwaGE6IHJlcXVpcmUoJy4vc3JjL3RyYW5zaXRpb24vc2hvdy9TaG93VHJhbnNpdGlvbkFscGhhJyksXHJcblx0SGlkZVRyYW5zaXRpb25Nb3ZlbWVudDogcmVxdWlyZSgnLi9zcmMvdHJhbnNpdGlvbi9oaWRlL0hpZGVUcmFuc2l0aW9uTW92ZW1lbnQnKVxyXG5cclxufTtcclxuIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgSklvY2Igb24gMi8zLzIwMTYuXHJcbiAqL1xyXG5cclxudmFyIFNob3dUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi90cmFuc2l0aW9uL3Nob3cvU2hvd1RyYW5zaXRpb25Nb3ZlbWVudCcpO1xyXG52YXIgSGlkZVRyYW5zaXRpb24gPSByZXF1aXJlKCcuL3RyYW5zaXRpb24vaGlkZS9IaWRlVHJhbnNpdGlvbk1vdmVtZW50Jyk7XHJcblxyXG52YXIgUGFuZWwgPSBmdW5jdGlvbiAoZ2FtZSxndWlCdWlsZGVyKVxyXG57XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICBQaGFzZXIuR3JvdXAuY2FsbCh0aGlzLCBnYW1lLCBudWxsKTtcclxuICAgIHRoaXMuX2dhbWUgPSBnYW1lO1xyXG4gICAgdGhpcy5fZ3VpQnVpbGRlciA9IGd1aUJ1aWxkZXI7XHJcbiAgICB0aGlzLnNpZ25hbCA9IG5ldyBQaGFzZXIuU2lnbmFsKCk7XHJcblxyXG59O1xyXG5cclxuLy8gPT09PT09PT09PSBQcm90b3R5cGUgPT09PT09PT09XHJcblBhbmVsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGhhc2VyLkdyb3VwLnByb3RvdHlwZSk7XHJcblBhbmVsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhbmVsO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFBhbmVsO1xyXG5cclxuXHJcblBhbmVsLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG59O1xyXG5cclxuUGFuZWwucHJvdG90eXBlLm9uQ2xvc2VkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdGhpcy5zaWduYWwuZGlzcGF0Y2godGhpcywncHJlc3NDbG9zZScpO1xyXG59O1xyXG5cclxuUGFuZWwucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdGhpcy5fZGF0YSA9IG51bGw7XHJcblxyXG4gICAgaWYgKHRoaXMuX3Nob3dUcmFuc2l0aW9uKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX3Nob3dUcmFuc2l0aW9uLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLl9zaG93VHJhbnNpdGlvbiA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYodGhpcy5faGlkZVRyYW5zaXRpb24pXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5faGlkZVRyYW5zaXRpb24uZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuX2hpZGVUcmFuc2l0aW9uID0gbnVsbDtcclxuICAgIH1cclxufTtcclxuXHJcblBhbmVsLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oYXNwZWN0UmF0aW8sZGF0YSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XHJcbiAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IGFzcGVjdFJhdGlvIHx8ICdsYW5kc2NhcGUnO1xyXG4gICAgdGhpcy5idWlsZCgpO1xyXG59O1xyXG5cclxuUGFuZWwucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKGFzcGVjdFJhdGlvKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgaWYodGhpcy5fYXNwZWN0UmF0aW8gIT09IGFzcGVjdFJhdGlvKVxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gYXNwZWN0UmF0aW87XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VBc3BlY3RSYXRpbygpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuUGFuZWwucHJvdG90eXBlLmNoYW5nZUFzcGVjdFJhdGlvID0gZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICB0aGlzLmJ1aWxkKCk7XHJcbn07XHJcblxyXG5QYW5lbC5wcm90b3R5cGUuY3JlYXRlU2hvd1RyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiBuZXcgU2hvd1RyYW5zaXRpb24odGhpcy5fZ2FtZSwgdGhpcywgMCwgLTMwMDAsIDAsIDAsIDI1MCwgUGhhc2VyLkVhc2luZy5MaW5lYXIuTm9uZSk7XHJcbn07XHJcblxyXG5QYW5lbC5wcm90b3R5cGUuY3JlYXRlSGlkZVRyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiBuZXcgSGlkZVRyYW5zaXRpb24odGhpcy5fZ2FtZSwgdGhpcywgdGhpcy54LCB0aGlzLnkgLSAzMDAwLCAyNTAsIFBoYXNlci5FYXNpbmcuTGluZWFyLk5vbmUpO1xyXG59O1xyXG5cclxuUGFuZWwucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XHJcbiAgICB0aGlzLl9zaG93VHJhbnNpdGlvbiA9IHRoaXMuY3JlYXRlU2hvd1RyYW5zaXRpb24oKTtcclxuICAgIHRoaXMuX3Nob3dUcmFuc2l0aW9uLnN0YXJ0KHRoaXMub25TaG93ZWQsdGhpcyk7XHJcbn07XHJcblxyXG5QYW5lbC5wcm90b3R5cGUub25TaG93ZWQgPSBmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICB0aGlzLl9zaG93VHJhbnNpdGlvbi5kZXN0cm95KCk7XHJcbiAgICB0aGlzLl9zaG93VHJhbnNpdGlvbiA9IG51bGw7XHJcbn07XHJcblxyXG5cclxuUGFuZWwucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB0aGlzLl9oaWRlVHJhbnNpdGlvbiA9IHRoaXMuY3JlYXRlSGlkZVRyYW5zaXRpb24oKTtcclxuICAgIHRoaXMuX2hpZGVUcmFuc2l0aW9uLnN0YXJ0KHRoaXMub25IaWRlZCx0aGlzKTtcclxufTtcclxuXHJcblBhbmVsLnByb3RvdHlwZS5vbkhpZGVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcclxuICAgIHRoaXMuX2hpZGVUcmFuc2l0aW9uLmRlc3Ryb3koKTtcclxuICAgIHRoaXMuX2hpZGVUcmFuc2l0aW9uID0gbnVsbDtcclxuICAgIHRoaXMuc2lnbmFsLmRpc3BhdGNoKHRoaXMsJ2hpZGVkJyk7XHJcbn07XHJcblxyXG5cclxuUGFuZWwucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICB0aGlzLl9ndWlCdWlsZGVyID0gbnVsbDtcclxuICAgIHRoaXMuX2dhbWUgPSBudWxsO1xyXG4gICAgdGhpcy5zaWduYWwucmVtb3ZlQWxsKCk7XHJcbiAgICB0aGlzLnNpZ25hbCA9IG51bGw7XHJcbiAgICB0aGlzLl9uYW1lID0gbnVsbDtcclxufTtcclxuIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgSklvY2Igb24gMi8zLzIwMTYuXHJcbiAqL1xyXG5cclxudmFyIFBhbmVsTWFuYWdlciA9IGZ1bmN0aW9uIChnYW1lLGd1aUJ1aWxkZXIsYXNwZWN0UmF0aW8pXHJcbntcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICB0aGlzLl9nYW1lID0gZ2FtZTtcclxuICAgIHRoaXMuX2d1aUJ1aWxkZXIgPSBndWlCdWlsZGVyO1xyXG4gICAgdGhpcy5fY2xhc3NCeUtleSA9IHt9O1xyXG4gICAgdGhpcy5fY3VycmVudFBhbmVscyA9IHt9O1xyXG4gICAgdGhpcy5fYXNwZWN0UmF0aW8gPSBhc3BlY3RSYXRpbztcclxuXHJcbn07XHJcblxyXG4vLyA9PT09PT09PT09IFByb3RvdHlwZSA9PT09PT09PT1cclxuUGFuZWxNYW5hZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LnByb3RvdHlwZSk7XHJcblBhbmVsTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYW5lbE1hbmFnZXI7XHJcbm1vZHVsZS5leHBvcnRzID0gUGFuZWxNYW5hZ2VyO1xyXG5cclxuUGFuZWxNYW5hZ2VyLnByb3RvdHlwZS5zZXRSb290ID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB0aGlzLl9ib2FyZENvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuXHJcbn07XHJcblxyXG5QYW5lbE1hbmFnZXIucHJvdG90eXBlLnJlZ2lzdGVyUGFuZWwgPSBmdW5jdGlvbihwYW5lbE5hbWUsIHBhbmVsQ2xhc3MpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHRoaXMuX2NsYXNzQnlLZXlbcGFuZWxOYW1lXSA9IHBhbmVsQ2xhc3M7XHJcblxyXG59O1xyXG5cclxuUGFuZWxNYW5hZ2VyLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24ocGFuZWxOYW1lLGRhdGEpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICB2YXIgcGFuZWwgPSB0aGlzLl9jdXJyZW50UGFuZWxzW3BhbmVsTmFtZV07XHJcbiAgICBpZihwYW5lbClcclxuICAgIHtcclxuICAgICAgICBwYW5lbC5yZXNldCgpO1xyXG4gICAgICAgIHRoaXMuX2JvYXJkQ29udGFpbmVyLmFkZENoaWxkKHBhbmVsKTtcclxuICAgICAgICBwYW5lbC5pbml0aWFsaXplKHRoaXMuX2FzcGVjdFJhdGlvLGRhdGEpO1xyXG4gICAgICAgIHBhbmVsLm9wZW4oKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50UGFuZWxzW3BhbmVsTmFtZV0gID0gcGFuZWw7XHJcbiAgICAgICAgcmV0dXJuIHBhbmVsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjbCA9IHRoaXMuX2NsYXNzQnlLZXlbcGFuZWxOYW1lXTtcclxuICAgIHBhbmVsID0gbmV3IGNsKHRoaXMuX2dhbWUsdGhpcy5fZ3VpQnVpbGRlcik7XHJcbiAgICB0aGlzLl9ib2FyZENvbnRhaW5lci5hZGRDaGlsZChwYW5lbCk7XHJcbiAgICBwYW5lbC5pbml0aWFsaXplKHRoaXMuX2FzcGVjdFJhdGlvLGRhdGEpO1xyXG4gICAgcGFuZWwub3BlbigpO1xyXG4gICAgdGhpcy5fY3VycmVudFBhbmVsc1twYW5lbE5hbWVdICA9IHBhbmVsO1xyXG4gICAgcmV0dXJuIHBhbmVsO1xyXG59O1xyXG5cclxuUGFuZWxNYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKHBhbmVsTmFtZSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIHZhciBwYW5lbCA9IHRoaXMuX2N1cnJlbnRQYW5lbHNbcGFuZWxOYW1lXTtcclxuXHJcbiAgICBpZihwYW5lbClcclxuICAgIHtcclxuICAgICAgICBwYW5lbC5jbG9zZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYW5lbDtcclxufTtcclxuXHJcblBhbmVsTWFuYWdlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24oYXNwZWN0UmF0aW8pIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IGFzcGVjdFJhdGlvO1xyXG5cclxuICAgIGZvcih2YXIga2V5IGluIHRoaXMuX2N1cnJlbnRQYW5lbHMpXHJcbiAgICB7XHJcbiAgICAgICAgaWYodGhpcy5fY3VycmVudFBhbmVscy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIHZhciBwYW5lbCA9IHRoaXMuX2N1cnJlbnRQYW5lbHNba2V5XTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwYW5lbCAhPSBudWxsICYmIHBhbmVsLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgcGFuZWwucmVzaXplKHRoaXMuX2FzcGVjdFJhdGlvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn07XHJcblxyXG4vKlxyXG5QYW5lbE1hbmFnZXIucHJvdG90eXBlLm9uUGFuZWxFdmVudCA9IGZ1bmN0aW9uKHBhbmVsLGV2ZW50bmFtZSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgY29uc29sZS5sb2coJ29uQ2xvc2VQYW5lbEV2ZW50JyxldmVudG5hbWUscGFuZWwpO1xyXG4gICAgaWYoZXZlbnRuYW1lID09ICdwcmVzc0Nsb3NlJylcclxuICAgIHtcclxuICAgICAgICBwYW5lbC5jbG9zZSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZihldmVudG5hbWUgPT09ICdoaWRlZCcpXHJcbiAgICB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJSRU1PVkVEIFBBTkVMXCIpXHJcbiAgICAgICAgdGhpcy5fYm9hcmRDb250YWluZXIucmVtb3ZlQ2hpbGQocGFuZWwpO1xyXG4gICAgICAgIGRlbGV0ZSh0aGlzLl9jdXJyZW50UGFuZWxzW3BhbmVsLm5hbWVdKTtcclxuICAgICAgICBwYW5lbC5yZXNldCgpO1xyXG4gICAgfVxyXG59O1xyXG4qL1xyXG5cclxuUGFuZWxNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJEZXN0cm95XCIpXHJcblxyXG4gICAgZm9yKHZhciBrZXkgaW4gdGhpcy5fY3VycmVudFBhbmVscylcclxuICAgIHtcclxuICAgICAgICBpZih0aGlzLl9jdXJyZW50UGFuZWxzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgdmFyIHBhbmVsID0gdGhpcy5fY3VycmVudFBhbmVsc1trZXldO1xyXG5cclxuICAgICAgICAgICAgaWYgKHBhbmVsICE9IG51bGwgJiYgcGFuZWwucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBwYW5lbC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2FyZENvbnRhaW5lci5yZW1vdmVDaGlsZChwYW5lbClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IG51bGw7XHJcbiAgICB0aGlzLl9jbGFzc0J5S2V5ID0gbnVsbDtcclxuICAgIHRoaXMuX2N1cnJlbnRQYW5lbHMgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX2JvYXJkQ29udGFpbmVyID0gbnVsbDtcclxuICAgIHRoaXMuX2dhbWUgPSBudWxsO1xyXG4gICAgdGhpcy5fZ3VpQnVpbGRlciA9IG51bGw7XHJcblxyXG59OyIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IEpJb2NiIG9uIDIvNC8yMDE2LlxyXG4gKi9cclxudmFyIEJhc2VUcmFuc2l0aW9uID0gZnVuY3Rpb24gKGdhbWUscGFuZWwpXHJcbntcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgdGhpcy5fZ2FtZSA9IGdhbWU7XHJcbiAgICB0aGlzLl9wYW5lbCA9IHBhbmVsO1xyXG5cclxufTtcclxuXHJcbi8vID09PT09PT09PT0gUHJvdG90eXBlID09PT09PT09PVxyXG5CYXNlVHJhbnNpdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5wcm90b3R5cGUpO1xyXG5CYXNlVHJhbnNpdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCYXNlVHJhbnNpdGlvbjtcclxubW9kdWxlLmV4cG9ydHMgPSBCYXNlVHJhbnNpdGlvbjtcclxuXHJcbkJhc2VUcmFuc2l0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGNhbGxCYWNrLGNhbGxCYWNrQ29udGV4dClcclxue1xyXG4gICAgdGhpcy5fY2FsbEJhY2sgPSBjYWxsQmFjaztcclxuICAgIHRoaXMuX2NhbGxCYWNrQ29udGV4dCA9IGNhbGxCYWNrQ29udGV4dDtcclxuXHJcbiAgICBpZih0aGlzLl9jYWxsQmFjayAmJiB0aGlzLl9jYWxsQmFja0NvbnRleHQpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fY2FsbEJhY2suY2FsbCh0aGlzLl9jYWxsQmFja0NvbnRleHQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbkJhc2VUcmFuc2l0aW9uLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxyXG57XHJcbiAgICB0aGlzLl9jYWxsQmFjayA9IG51bGw7XHJcbiAgICB0aGlzLl9jYWxsQmFja0NvbnRleHQgPSBudWxsO1xyXG5cclxufTsiLCIvKipcclxuICogQ3JlYXRlZCBieSBKSW9jYiBvbiAyLzQvMjAxNi5cclxuICovXHJcbnZhciBCYXNlVHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4vLi4vQmFzZVRyYW5zaXRpb24nKTtcclxuXHJcbnZhciBIaWRlVHJhbnNpdGlvbk1vdmVtZW50ID0gZnVuY3Rpb24gKGdhbWUsIHBhbmVsLCB0b1gsIHRvWSwgdGltZUluTXNjLCBlYXNpbmcpXHJcbntcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIEJhc2VUcmFuc2l0aW9uLmNhbGwodGhpcywgZ2FtZSxwYW5lbCk7XHJcbiAgICB0aGlzLl90b1ggPSB0b1g7XHJcbiAgICB0aGlzLl90b1kgPSB0b1k7XHJcbiAgICB0aGlzLl90aW1lSW5Nc2MgPSB0aW1lSW5Nc2MgfHwgMTAwO1xyXG4gICAgdGhpcy5fZWFzaW5nID0gZWFzaW5nIHx8IFBoYXNlci5FYXNpbmcuTGluZWFyLk5vbmU7XHJcbn07XHJcblxyXG4vLyA9PT09PT09PT09IFByb3RvdHlwZSA9PT09PT09PT1cclxuSGlkZVRyYW5zaXRpb25Nb3ZlbWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VUcmFuc2l0aW9uKTtcclxuSGlkZVRyYW5zaXRpb25Nb3ZlbWVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIaWRlVHJhbnNpdGlvbk1vdmVtZW50O1xyXG5tb2R1bGUuZXhwb3J0cyA9IEhpZGVUcmFuc2l0aW9uTW92ZW1lbnQ7XHJcblxyXG5cclxuSGlkZVRyYW5zaXRpb25Nb3ZlbWVudC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihjYWxsQmFjayxjYWxsQmFja0NvbnRleHQpXHJcbntcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHRoaXMuX2NhbGxCYWNrID0gY2FsbEJhY2s7XHJcbiAgICB0aGlzLl9jYWxsQmFja0NvbnRleHQgPSBjYWxsQmFja0NvbnRleHQ7XHJcblxyXG4gICAgdGhpcy5fdHdlZW4gPSB0aGlzLl9nYW1lLmFkZC50d2Vlbih0aGlzLl9wYW5lbCk7XHJcbiAgICB0aGlzLl90d2Vlbi5vbkNvbXBsZXRlLmFkZCh0aGlzLl9jYWxsQmFjayx0aGlzLl9jYWxsQmFja0NvbnRleHQpO1xyXG4gICAgdGhpcy5fdHdlZW4udG8oeyB4IDogdGhpcy5fdG9YLCB5IDogdGhpcy5fdG9ZfSwgdGhpcy5fdGltZUluTXNjLCB0aGlzLl9lYXNpbmcpO1xyXG4gICAgdGhpcy5fdHdlZW4uc3RhcnQoKTtcclxufTtcclxuXHJcblxyXG5IaWRlVHJhbnNpdGlvbk1vdmVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxyXG57XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB0aGlzLl9jYWxsQmFjayA9IG51bGw7XHJcbiAgICB0aGlzLl9jYWxsQmFja0NvbnRleHQgPSBudWxsO1xyXG4gICAgaWYodGhpcy5fdHdlZW4pXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fdHdlZW4ucGF1c2UoKTtcclxuICAgIH1cclxuICAgIHRoaXMuX2dhbWUudHdlZW5zLnJlbW92ZSh0aGlzLl90d2Vlbik7XHJcbn07XHJcblxyXG4iLCIvKipcclxuICogQ3JlYXRlZCBieSBqZWRpIG9uIDI0LUZlYi0xNi5cclxuICovXHJcblxyXG52YXIgQmFzZVRyYW5zaXRpb24gPSByZXF1aXJlKCcuLy4uL0Jhc2VUcmFuc2l0aW9uJyk7XHJcbnZhciBTaG93VHJhbnNpdGlvbkFscGhhID0gZnVuY3Rpb24gKGdhbWUsIHBhbmVsLCBmcm9tQWxwaGEsIHRvQWxwaGEsIHRpbWVJbk1zYywgZWFzaW5nKVxyXG57XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICBCYXNlVHJhbnNpdGlvbi5jYWxsKHRoaXMsIGdhbWUscGFuZWwpO1xyXG4gICAgdGhpcy5fZnJvbUFscGhhID0gZnJvbUFscGhhO1xyXG4gICAgdGhpcy5fdG9BbHBoYSA9IHRvQWxwaGE7XHJcbiAgICB0aGlzLl90aW1lSW5Nc2MgPSB0aW1lSW5Nc2MgfHwgMTAwO1xyXG4gICAgdGhpcy5fZWFzaW5nID0gZWFzaW5nIHx8IFBoYXNlci5FYXNpbmcuTGluZWFyLk5vbmU7XHJcbn07XHJcblxyXG4vLyA9PT09PT09PT09IFByb3RvdHlwZSA9PT09PT09PT1cclxuU2hvd1RyYW5zaXRpb25BbHBoYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VUcmFuc2l0aW9uKTtcclxuU2hvd1RyYW5zaXRpb25BbHBoYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTaG93VHJhbnNpdGlvbkFscGhhO1xyXG5tb2R1bGUuZXhwb3J0cyA9IFNob3dUcmFuc2l0aW9uQWxwaGE7XHJcblxyXG5cclxuU2hvd1RyYW5zaXRpb25BbHBoYS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihjYWxsQmFjaywgY2FsbEJhY2tDb250ZXh0KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB0aGlzLl9jYWxsQmFjayA9IGNhbGxCYWNrO1xyXG4gICAgdGhpcy5fY2FsbEJhY2tDb250ZXh0ID0gY2FsbEJhY2tDb250ZXh0O1xyXG5cclxuICAgIHRoaXMuX3R3ZWVuID0gdGhpcy5fZ2FtZS5hZGQudHdlZW4odGhpcy5fcGFuZWwpO1xyXG4gICAgdGhpcy5fdHdlZW4ub25Db21wbGV0ZS5hZGQodGhpcy5fY2FsbEJhY2ssIHRoaXMuX2NhbGxCYWNrQ29udGV4dCk7XHJcbiAgICB0aGlzLl9wYW5lbC5hbHBoYSA9IHRoaXMuX2Zyb21BbHBoYTtcclxuICAgIHRoaXMuX3R3ZWVuLnRvKHsgYWxwaGEgOiB0aGlzLl90b0FscGhhfSwgdGhpcy5fdGltZUluTXNjLCB0aGlzLl9lYXNpbmcpO1xyXG4gICAgdGhpcy5fdHdlZW4uc3RhcnQoKTtcclxufTtcclxuXHJcblxyXG5TaG93VHJhbnNpdGlvbkFscGhhLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKVxyXG57XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICB0aGlzLl9jYWxsQmFjayA9IG51bGw7XHJcbiAgICB0aGlzLl9jYWxsQmFja0NvbnRleHQgPSBudWxsO1xyXG4gICAgaWYodGhpcy5fdHdlZW4pXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fdHdlZW4ucGF1c2UoKTtcclxuICAgIH1cclxuICAgIHRoaXMuX2dhbWUudHdlZW5zLnJlbW92ZSh0aGlzLl90d2Vlbik7XHJcbn07XHJcblxyXG4iLCIvKipcclxuICogQ3JlYXRlZCBieSBqZWRpIG9uIDI4LUZlYi0xNi5cclxuICovXHJcblxyXG52YXIgQmFzZVRyYW5zaXRpb24gPSByZXF1aXJlKCcuLy4uL0Jhc2VUcmFuc2l0aW9uJyk7XHJcbnZhciBTaG93VHJhbnNpdGlvbkFscGhhQW5kTW92ZW1lbnQgPSBmdW5jdGlvbiAoZ2FtZSwgcGFuZWwsIGZyb21YLCBmcm9tWSwgdG9YLCB0b1ksIGZyb21BbHBoYSwgdG9BbHBoYSwgdGltZUluTXNjLCBlYXNpbmcpXHJcbntcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIEJhc2VUcmFuc2l0aW9uLmNhbGwodGhpcywgZ2FtZSxwYW5lbCk7XHJcbiAgICB0aGlzLl9mcm9tWCA9IGZyb21YO1xyXG4gICAgdGhpcy5fZnJvbVkgPSBmcm9tWTtcclxuICAgIHRoaXMuX3RvWCA9IHRvWDtcclxuICAgIHRoaXMuX3RvWSA9IHRvWTtcclxuICAgIHRoaXMuX2Zyb21BbHBoYSA9IGZyb21BbHBoYTtcclxuICAgIHRoaXMuX3RvQWxwaGEgPSB0b0FscGhhO1xyXG4gICAgdGhpcy5fdGltZUluTXNjID0gdGltZUluTXNjIHx8IDEwMDtcclxuICAgIHRoaXMuX2Vhc2luZyA9IGVhc2luZyB8fCBQaGFzZXIuRWFzaW5nLkxpbmVhci5Ob25lO1xyXG59O1xyXG5cclxuLy8gPT09PT09PT09PSBQcm90b3R5cGUgPT09PT09PT09XHJcblNob3dUcmFuc2l0aW9uQWxwaGFBbmRNb3ZlbWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhc2VUcmFuc2l0aW9uKTtcclxuU2hvd1RyYW5zaXRpb25BbHBoYUFuZE1vdmVtZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNob3dUcmFuc2l0aW9uQWxwaGFBbmRNb3ZlbWVudDtcclxubW9kdWxlLmV4cG9ydHMgPSBTaG93VHJhbnNpdGlvbkFscGhhQW5kTW92ZW1lbnQ7XHJcblxyXG5cclxuU2hvd1RyYW5zaXRpb25BbHBoYUFuZE1vdmVtZW50LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGNhbGxCYWNrLCBjYWxsQmFja0NvbnRleHQpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHRoaXMuX2NhbGxCYWNrID0gY2FsbEJhY2s7XHJcbiAgICB0aGlzLl9jYWxsQmFja0NvbnRleHQgPSBjYWxsQmFja0NvbnRleHQ7XHJcblxyXG4gICAgdGhpcy5fdHdlZW4gPSB0aGlzLl9nYW1lLmFkZC50d2Vlbih0aGlzLl9wYW5lbCk7XHJcbiAgICB0aGlzLl90d2Vlbi5vbkNvbXBsZXRlLmFkZCh0aGlzLl9jYWxsQmFjaywgdGhpcy5fY2FsbEJhY2tDb250ZXh0KTtcclxuICAgIHRoaXMuX3BhbmVsLnggPSB0aGlzLl9mcm9tWDtcclxuICAgIHRoaXMuX3BhbmVsLnkgPSB0aGlzLl9mcm9tWTtcclxuICAgIHRoaXMuX3BhbmVsLmFscGhhID0gdGhpcy5fZnJvbUFscGhhO1xyXG4gICAgdGhpcy5fdHdlZW4udG8oeyB4IDogdGhpcy5fdG9YLCB5IDogdGhpcy5fdG9ZLCBhbHBoYSA6IHRoaXMuX3RvQWxwaGF9LCB0aGlzLl90aW1lSW5Nc2MsIHRoaXMuX2Vhc2luZyk7XHJcbiAgICB0aGlzLl90d2Vlbi5zdGFydCgpO1xyXG5cclxufTtcclxuXHJcblxyXG5TaG93VHJhbnNpdGlvbkFscGhhQW5kTW92ZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXHJcbntcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHRoaXMuX2NhbGxCYWNrID0gbnVsbDtcclxuICAgIHRoaXMuX2NhbGxCYWNrQ29udGV4dCA9IG51bGw7XHJcbiAgICBpZih0aGlzLl90d2VlbilcclxuICAgIHtcclxuICAgICAgICB0aGlzLl90d2Vlbi5wYXVzZSgpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fZ2FtZS50d2VlbnMucmVtb3ZlKHRoaXMuX3R3ZWVuKTtcclxufTtcclxuXHJcbiIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IEpJb2NiIG9uIDIvNC8yMDE2LlxyXG4gKi9cclxudmFyIEJhc2VUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi8uLi9CYXNlVHJhbnNpdGlvbicpO1xyXG52YXIgU2hvd1RyYW5zaXRpb25Nb3ZlbWVudCA9IGZ1bmN0aW9uIChnYW1lLCBwYW5lbCwgZnJvbVgsIGZyb21ZLCB0b1gsIHRvWSwgdGltZUluTXNjLCBlYXNpbmcpXHJcbntcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIEJhc2VUcmFuc2l0aW9uLmNhbGwodGhpcywgZ2FtZSxwYW5lbCk7XHJcbiAgICB0aGlzLl9mcm9tWCA9IGZyb21YO1xyXG4gICAgdGhpcy5fZnJvbVkgPSBmcm9tWTtcclxuICAgIHRoaXMuX3RvWCA9IHRvWDtcclxuICAgIHRoaXMuX3RvWSA9IHRvWTtcclxuICAgIHRoaXMuX3RpbWVJbk1zYyA9IHRpbWVJbk1zYyB8fCAxMDA7XHJcbiAgICB0aGlzLl9lYXNpbmcgPSBlYXNpbmcgfHwgUGhhc2VyLkVhc2luZy5MaW5lYXIuTm9uZTtcclxufTtcclxuXHJcbi8vID09PT09PT09PT0gUHJvdG90eXBlID09PT09PT09PVxyXG5TaG93VHJhbnNpdGlvbk1vdmVtZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFzZVRyYW5zaXRpb24pO1xyXG5TaG93VHJhbnNpdGlvbk1vdmVtZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNob3dUcmFuc2l0aW9uTW92ZW1lbnQ7XHJcbm1vZHVsZS5leHBvcnRzID0gU2hvd1RyYW5zaXRpb25Nb3ZlbWVudDtcclxuXHJcblxyXG5TaG93VHJhbnNpdGlvbk1vdmVtZW50LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGNhbGxCYWNrLCBjYWxsQmFja0NvbnRleHQpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHRoaXMuX2NhbGxCYWNrID0gY2FsbEJhY2s7XHJcbiAgICB0aGlzLl9jYWxsQmFja0NvbnRleHQgPSBjYWxsQmFja0NvbnRleHQ7XHJcbiAgICB0aGlzLl9wYW5lbC55ID0gdGhpcy5fZnJvbVk7XHJcbiAgICB0aGlzLl9wYW5lbC54ID0gdGhpcy5fZnJvbVg7XHJcblxyXG4gICAgdGhpcy5fdHdlZW4gPSB0aGlzLl9nYW1lLmFkZC50d2Vlbih0aGlzLl9wYW5lbCk7XHJcbiAgICB0aGlzLl90d2Vlbi5vbkNvbXBsZXRlLmFkZCh0aGlzLl9jYWxsQmFjaywgdGhpcy5fY2FsbEJhY2tDb250ZXh0KTtcclxuICAgIHRoaXMuX3BhbmVsLnggPSB0aGlzLl9mcm9tWDtcclxuICAgIHRoaXMuX3BhbmVsLnkgPSB0aGlzLl9mcm9tWTtcclxuICAgIHRoaXMuX3R3ZWVuLnRvKHsgeCA6IHRoaXMuX3RvWCwgeSA6IHRoaXMuX3RvWX0sIHRoaXMuX3RpbWVJbk1zYywgdGhpcy5fZWFzaW5nKTtcclxuICAgIHRoaXMuX3R3ZWVuLnN0YXJ0KCk7XHJcblxyXG59O1xyXG5cclxuXHJcblNob3dUcmFuc2l0aW9uTW92ZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpXHJcbntcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHRoaXMuX2NhbGxCYWNrID0gbnVsbDtcclxuICAgIHRoaXMuX2NhbGxCYWNrQ29udGV4dCA9IG51bGw7XHJcbiAgICBpZih0aGlzLl90d2VlbilcclxuICAgIHtcclxuICAgICAgICB0aGlzLl90d2Vlbi5wYXVzZSgpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fZ2FtZS50d2VlbnMucmVtb3ZlKHRoaXMuX3R3ZWVuKTtcclxufTtcclxuIiwiIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIC8vIERlcHJlY2F0ZWRcbiAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICBjYXNlICdyYXdzJzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGJpbmFyeVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICBmb3IgKHZhciBpID0gMDsgYnl0ZU9mZnNldCArIGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgIGlmIChyZWFkKGFyciwgYnl0ZU9mZnNldCArIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiAoYnl0ZU9mZnNldCArIGZvdW5kSW5kZXgpICogaW5kZXhTaXplXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID4+PSAwXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVybiAtMVxuXG4gIC8vIE5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0LCAwKVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBzcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7IGkrKykge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG5mdW5jdGlvbiBpbml0ICgpIHtcbiAgdmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gICAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG4gIH1cblxuICByZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbiAgcmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG59XG5cbmluaXQoKVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHBsYWNlSG9sZGVycyA9IGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcblxuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgYXJyID0gbmV3IEFycihsZW4gKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlblxuXG4gIHZhciBMID0gMFxuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIG91dHB1dCA9ICcnXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9PSdcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz0nXG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dClcblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBCdWZmZXJcbiAqXG4gKiBBdXRob3I6ICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIExpY2Vuc2U6ICBNSVRcbiAqXG4gKiBgbnBtIGluc3RhbGwgaXMtYnVmZmVyYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gISEob2JqICE9IG51bGwgJiZcbiAgICAob2JqLl9pc0J1ZmZlciB8fCAvLyBGb3IgU2FmYXJpIDUtNyAobWlzc2luZyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yKVxuICAgICAgKG9iai5jb25zdHJ1Y3RvciAmJlxuICAgICAgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iaikpXG4gICAgKSlcbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcIilcbiIsIi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxudmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5mb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzc05leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59IiwiLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbTtcbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTtcbiAgfSBjYXRjaCAoXykge30gZmluYWxseSB7XG4gICAgaWYgKCFTdHJlYW0pIFN0cmVhbSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiAgfVxufSkoKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBidWZmZXJTaGltID0gcmVxdWlyZSgnYnVmZmVyLXNoaW1zJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBoYXNQcmVwZW5kTGlzdGVuZXIgPSB0eXBlb2YgRUUucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJztcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICBpZiAoaGFzUHJlcGVuZExpc3RlbmVyKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgYnJ1dGFsbHkgdWdseSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyXG4gIC8vIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnkgdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZVxuICAvLyBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9uc1xuICAvLyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGUgdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWxcbiAgLy8gaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxudmFyIER1cGxleDtcbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH4gfnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxudmFyIER1cGxleDtcbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IGJ1ZmZlclNoaW0uZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIF9lID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgX2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2tpcEFkZDtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICBza2lwQWRkID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgY2h1bmsubGVuZ3RoID09PSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFkZFRvRnJvbnQpIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gRG9uJ3QgYWRkIHRvIHRoZSBidWZmZXIgaWYgd2UndmUgZGVjb2RlZCB0byBhbiBlbXB0eSBzdHJpbmcgY2h1bmsgYW5kXG4gICAgICAvLyB3ZSdyZSBub3QgaW4gb2JqZWN0IG1vZGVcbiAgICAgIGlmICghc2tpcEFkZCkge1xuICAgICAgICAvLyBpZiB3ZSB3YW50IHRoZSBkYXRhIG5vdywganVzdCBlbWl0IGl0LlxuICAgICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcblxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAobiA9PT0gbnVsbCB8fCBpc05hTihuKSkge1xuICAgIC8vIG9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXJbMF0ubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApIHJldHVybiAwO1xuXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSB0YXJnZXQgYnVmZmVyIGxldmVsLFxuICAvLyB0aGVuIHJhaXNlIHRoZSB3YXRlciBtYXJrLiAgQnVtcCB1cCB0byB0aGUgbmV4dCBoaWdoZXN0XG4gIC8vIHBvd2VyIG9mIDIsIHRvIHByZXZlbnQgaW5jcmVhc2luZyBpdCBleGNlc3NpdmVseSBpbiB0aW55XG4gIC8vIGFtb3VudHMuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuXG4gIC8vIGRvbid0IGhhdmUgdGhhdCBtdWNoLiAgcmV0dXJuIG51bGwsIHVubGVzcyB3ZSd2ZSBlbmRlZC5cbiAgaWYgKG4gPiBzdGF0ZS5sZW5ndGgpIHtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG47XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuID4gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfVxuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gIH1cblxuICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gIGlmIChkb1JlYWQgJiYgIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9XG5cbiAgc3RhdGUubGVuZ3RoIC09IG47XG5cbiAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcHJvY2Vzc05leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3NOZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuOyBfaSsrKSB7XG4gICAgICBkZXN0c1tfaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaSwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICAvLyBJZiBsaXN0ZW5pbmcgdG8gZGF0YSwgYW5kIGl0IGhhcyBub3QgZXhwbGljaXRseSBiZWVuIHBhdXNlZCxcbiAgLy8gdGhlbiBjYWxsIHJlc3VtZSB0byBzdGFydCB0aGUgZmxvdyBvZiBkYXRhIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmIGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICB0aGlzLnJlc3VtZSgpO1xuICB9XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzTmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgY2h1bmsgPSBzdHJlYW0ucmVhZCgpO1xuICAgIH0gd2hpbGUgKG51bGwgIT09IGNodW5rICYmIHN0YXRlLmZsb3dpbmcpO1xuICB9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uIChldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIHZhciBsaXN0ID0gc3RhdGUuYnVmZmVyO1xuICB2YXIgbGVuZ3RoID0gc3RhdGUubGVuZ3RoO1xuICB2YXIgc3RyaW5nTW9kZSA9ICEhc3RhdGUuZGVjb2RlcjtcbiAgdmFyIG9iamVjdE1vZGUgPSAhIXN0YXRlLm9iamVjdE1vZGU7XG4gIHZhciByZXQ7XG5cbiAgLy8gbm90aGluZyBpbiB0aGUgbGlzdCwgZGVmaW5pdGVseSBlbXB0eS5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICBpZiAobGVuZ3RoID09PSAwKSByZXQgPSBudWxsO2Vsc2UgaWYgKG9iamVjdE1vZGUpIHJldCA9IGxpc3Quc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgYXJyYXkuXG4gICAgaWYgKHN0cmluZ01vZGUpIHJldCA9IGxpc3Quam9pbignJyk7ZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHJldCA9IGxpc3RbMF07ZWxzZSByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpIHJldCA9ICcnO2Vsc2UgcmV0ID0gYnVmZmVyU2hpbS5hbGxvY1Vuc2FmZShuKTtcblxuICAgICAgdmFyIGMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGwgJiYgYyA8IG47IGkrKykge1xuICAgICAgICB2YXIgX2J1ZiA9IGxpc3RbMF07XG4gICAgICAgIHZhciBjcHkgPSBNYXRoLm1pbihuIC0gYywgX2J1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKSByZXQgKz0gX2J1Zi5zbGljZSgwLCBjcHkpO2Vsc2UgX2J1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgX2J1Zi5sZW5ndGgpIGxpc3RbMF0gPSBfYnVmLnNsaWNlKGNweSk7ZWxzZSBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUoc3RyZWFtKSB7XG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRoaXMud3JpdGVlbmNvZGluZyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUodGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyKSB7XG4gICAgICBkb25lKHN0cmVhbSwgZXIpO1xuICAgIH0pO2Vsc2UgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcHJvY2Vzc05leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW07XG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIFN0cmVhbSA9IHJlcXVpcmUoJ3N0JyArICdyZWFtJyk7XG4gIH0gY2F0Y2ggKF8pIHt9IGZpbmFsbHkge1xuICAgIGlmICghU3RyZWFtKSBTdHJlYW0gPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4gIH1cbn0pKCk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYnVmZmVyU2hpbSA9IHJlcXVpcmUoJ2J1ZmZlci1zaGltcycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxudmFyIER1cGxleDtcbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfiB+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiB3cml0YWJsZVN0YXRlR2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbnZhciBEdXBsZXg7XG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0aG91Z2ggdGhleSdyZSBub3RcbiAgLy8gaW5zdGFuY2VvZiBXcml0YWJsZSwgdGhleSdyZSBpbnN0YW5jZW9mIFJlYWRhYmxlLlxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIElmIHdlIGdldCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkLFxuLy8gYW5kIHdlJ3JlIG5vdCBpbiBvYmplY3RNb2RlLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbi8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxuLy8gd2F0ZXJtYXJrcyBkZXRlcm1pbmUgaG93IG1hbnkgb2JqZWN0cyB0byBrZWVwIGluIHRoZSBidWZmZXIsIHJhdGhlciB0aGFuXG4vLyBob3cgbWFueSBieXRlcyBvciBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG4gIC8vIEFsd2F5cyB0aHJvdyBlcnJvciBpZiBhIG51bGwgaXMgd3JpdHRlblxuICAvLyBpZiB3ZSBhcmUgbm90IGluIG9iamVjdCBtb2RlIHRoZW4gdGhyb3dcbiAgLy8gaWYgaXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG9yIHVuZGVmaW5lZC5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBidWZmZXJTaGltLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuICBpZiAoc3luYykgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7ZWxzZSBjYihlcik7XG5cbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzTmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuXG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKGVycikge1xuICAgIHZhciBlbnRyeSA9IF90aGlzLmVudHJ5O1xuICAgIF90aGlzLmVudHJ5ID0gbnVsbDtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICBjYihlcnIpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgIH1cbiAgICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IF90aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBfdGhpcztcbiAgICB9XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyk7XG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlcjtcbnZhciBTbG93QnVmZmVyID0gYnVmZmVyLlNsb3dCdWZmZXI7XG52YXIgTUFYX0xFTiA9IGJ1ZmZlci5rTWF4TGVuZ3RoIHx8IDIxNDc0ODM2NDc7XG5leHBvcnRzLmFsbG9jID0gZnVuY3Rpb24gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKTtcbiAgfVxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3Qgbm90IGJlIG51bWJlcicpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAoc2l6ZSA+IE1BWF9MRU4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgfVxuICB2YXIgZW5jID0gZW5jb2Rpbmc7XG4gIHZhciBfZmlsbCA9IGZpbGw7XG4gIGlmIChfZmlsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jID0gdW5kZWZpbmVkO1xuICAgIF9maWxsID0gMDtcbiAgfVxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgaWYgKHR5cGVvZiBfZmlsbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgZmlsbEJ1ZiA9IG5ldyBCdWZmZXIoX2ZpbGwsIGVuYyk7XG4gICAgdmFyIGZsZW4gPSBmaWxsQnVmLmxlbmd0aDtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHdoaWxlICgrK2kgPCBzaXplKSB7XG4gICAgICBidWZbaV0gPSBmaWxsQnVmW2kgJSBmbGVuXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoX2ZpbGwpO1xuICB9XG4gIHJldHVybiBidWY7XG59XG5leHBvcnRzLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gYWxsb2NVbnNhZmUoc2l6ZSkge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvY1Vuc2FmZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmIChzaXplID4gTUFYX0xFTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaXplIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xufVxuZXhwb3J0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmZyb20gPT09ICdmdW5jdGlvbicgJiYgKCFnbG9iYWwuVWludDhBcnJheSB8fCBVaW50OEFycmF5LmZyb20gIT09IEJ1ZmZlci5mcm9tKSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpO1xuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgb2Zmc2V0ID0gZW5jb2RpbmdPck9mZnNldDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuICAgIHZhciBsZW4gPSBsZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBsZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsZW4gPSB2YWx1ZS5ieXRlTGVuZ3RoIC0gb2Zmc2V0O1xuICAgIH1cbiAgICBpZiAob2Zmc2V0ID49IHZhbHVlLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAobGVuID4gdmFsdWUuYnl0ZUxlbmd0aCAtIG9mZnNldCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIH1cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJ1ZmZlcih2YWx1ZS5sZW5ndGgpO1xuICAgIHZhbHVlLmNvcHkob3V0LCAwLCAwLCB2YWx1ZS5sZW5ndGgpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8ICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZS5kYXRhKSkge1xuICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUuZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCAnICsgJ0FycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJyk7XG59XG5leHBvcnRzLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIGFsbG9jVW5zYWZlU2xvdyhzaXplKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KHNpemUpO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIG11c3QgYmUgYSBudW1iZXInKTtcbiAgfVxuICBpZiAoc2l6ZSA+PSBNQVhfTEVOKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpemUgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBTbG93QnVmZmVyKHNpemUpO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IG5leHRUaWNrO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzLm5leHRUaWNrO1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCIpXG4iLCJ2YXIgU3RyZWFtID0gKGZ1bmN0aW9uICgpe1xuICB0cnkge1xuICAgIHJldHVybiByZXF1aXJlKCdzdCcgKyAncmVhbScpOyAvLyBoYWNrIHRvIGZpeCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgaXNzdWUgd2hlbiB1c2VkIHdpdGggYnJvd3NlcmlmeVxuICB9IGNhdGNoKF8pe31cbn0oKSk7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IFN0cmVhbSB8fCBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcblxuaWYgKCFwcm9jZXNzLmJyb3dzZXIgJiYgcHJvY2Vzcy5lbnYuUkVBREFCTEVfU1RSRUFNID09PSAnZGlzYWJsZScgJiYgU3RyZWFtKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcIilcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcIilcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcbiAgfHwgZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XG4gICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9XG5cblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuLy9cbi8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXG4vLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG4vLyB3cml0ZSBkZWNvZGVzIHRoZSBnaXZlbiBidWZmZXIgYW5kIHJldHVybnMgaXQgYXMgSlMgc3RyaW5nIHRoYXQgaXNcbi8vIGd1YXJhbnRlZWQgdG8gbm90IGNvbnRhaW4gYW55IHBhcnRpYWwgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLiBBbnkgcGFydGlhbFxuLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcbi8vIHJldHVybmVkIHdoZW4gY2FsbGluZyB3cml0ZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMuXG4vL1xuLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcbi8vIGN1cnJlbnRseSB3b3JrcywgYnV0IGNvbnZlcnRpbmcgYSBTdHJpbmcgdG8gYSBCdWZmZXIgKHZpYSBgbmV3IEJ1ZmZlcmAsIG9yXG4vLyBCdWZmZXIjd3JpdGUpIHdpbGwgcmVwbGFjZSBpbmNvbXBsZXRlIHN1cnJvZ2F0ZXMgd2l0aCB0aGUgdW5pY29kZVxuLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIDAsIGF2YWlsYWJsZSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShhdmFpbGFibGUsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2hhclN0cjtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgYW5kIHNldCBjaGFyTGVuZ3RoIC8gY2hhclJlY2VpdmVkXG4gIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQsIGVuZCk7XG4gICAgZW5kIC09IHRoaXMuY2hhclJlY2VpdmVkO1xuICB9XG5cbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICB2YXIgZW5kID0gY2hhclN0ci5sZW5ndGggLSAxO1xuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xuICAgIHJldHVybiBjaGFyU3RyLnN1YnN0cmluZygwLCBlbmQpO1xuICB9XG5cbiAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gIHJldHVybiBjaGFyU3RyO1xufTtcblxuLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxuLy8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiBJZiBzbywgaXQgc2V0cyB0aGlzLmNoYXJMZW5ndGggdG8gdGhlIGJ5dGVcbi8vIGxlbmd0aCB0aGF0IGNoYXJhY3RlciwgYW5kIHNldHMgdGhpcy5jaGFyUmVjZWl2ZWQgdG8gdGhlIG51bWJlciBvZiBieXRlc1xuLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBpO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQpIHtcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgIHZhciBlbmMgPSB0aGlzLmVuY29kaW5nO1xuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMyA6IDA7XG59XG4iLCJ2YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpbW1lZGlhdGVJZHMgPSB7fTtcbnZhciBuZXh0SW1tZWRpYXRlSWQgPSAwO1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkgeyB0aW1lb3V0LmNsb3NlKCk7IH07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gVGhhdCdzIG5vdCBob3cgbm9kZS5qcyBpbXBsZW1lbnRzIGl0IGJ1dCB0aGUgZXhwb3NlZCBhcGkgaXMgdGhlIHNhbWUuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHNldEltbWVkaWF0ZSA6IGZ1bmN0aW9uKGZuKSB7XG4gIHZhciBpZCA9IG5leHRJbW1lZGlhdGVJZCsrO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZmFsc2UgOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaW1tZWRpYXRlSWRzW2lkXSA9IHRydWU7XG5cbiAgbmV4dFRpY2soZnVuY3Rpb24gb25OZXh0VGljaygpIHtcbiAgICBpZiAoaW1tZWRpYXRlSWRzW2lkXSkge1xuICAgICAgLy8gZm4uY2FsbCgpIGlzIGZhc3RlciBzbyB3ZSBvcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiB1c2UtY2FzZVxuICAgICAgLy8gQHNlZSBodHRwOi8vanNwZXJmLmNvbS9jYWxsLWFwcGx5LXNlZ3VcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4uY2FsbChudWxsKTtcbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnQgaWRzIGZyb20gbGVha2luZ1xuICAgICAgZXhwb3J0cy5jbGVhckltbWVkaWF0ZShpZCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaWQ7XG59O1xuXG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gdHlwZW9mIGNsZWFySW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBjbGVhckltbWVkaWF0ZSA6IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSBpbW1lZGlhdGVJZHNbaWRdO1xufTsiLCJ2YXIgcmVtb3ZlSW52YWxpZENoYXJhY3RlcnMgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgIC8vIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi94bWwvI05ULUNoYXIgZm9yIHZhbGlkIFhNTCAxLjAgY2hhcmFjdGVyc1xuICAgIHJldHVybiBjb250ZW50LnJlcGxhY2UoL1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRl0vZywgJycpO1xufTtcblxudmFyIHNlcmlhbGl6ZUF0dHJpYnV0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgICAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgICAgIC5yZXBsYWNlKC8nL2csICcmYXBvczsnKTtcbn07XG5cbnZhciBzZXJpYWxpemVUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gICAgcmV0dXJuIGNvbnRlbnRcbiAgICAgICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xufTtcblxudmFyIHNlcmlhbGl6ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgdmFyIHZhbHVlID0gYXR0ci52YWx1ZTtcblxuICAgIHJldHVybiAnICcgKyBhdHRyLm5hbWUgKyAnPVwiJyArIHNlcmlhbGl6ZUF0dHJpYnV0ZVZhbHVlKHZhbHVlKSArICdcIic7XG59O1xuXG52YXIgZ2V0VGFnTmFtZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBub2RlLnRhZ05hbWU7XG5cbiAgICAvLyBBaWQgaW4gc2VyaWFsaXppbmcgb2Ygb3JpZ2luYWwgSFRNTCBkb2N1bWVudHNcbiAgICBpZiAobm9kZS5uYW1lc3BhY2VVUkkgPT09ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJykge1xuICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGFnTmFtZTtcbn07XG5cbnZhciBzZXJpYWxpemVOYW1lc3BhY2UgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBub2RlSGFzWG1sbnNBdHRyID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKG5vZGUuYXR0cmlidXRlcyB8fCBub2RlLmF0dHJzLCBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgcmV0dXJuIGF0dHIubmFtZTtcbiAgICAgICAgfSlcbiAgICAgICAgLmluZGV4T2YoJ3htbG5zJykgPj0gMDtcbiAgICAvLyBTZXJpYWxpemUgdGhlIG5hbWVzcGFjZSBhcyBhbiB4bWxucyBhdHRyaWJ1dGUgd2hlbmV2ZXIgdGhlIGVsZW1lbnRcbiAgICAvLyBkb2Vzbid0IGFscmVhZHkgaGF2ZSBvbmUgYW5kIHRoZSBpbmhlcml0ZWQgbmFtZXNwYWNlIGRvZXMgbm90IG1hdGNoXG4gICAgLy8gdGhlIGVsZW1lbnQncyBuYW1lc3BhY2UuXG4gICAgLy8gQXMgYSBzcGVjaWFsIGNhc2UsIGFsd2F5cyBpbmNsdWRlIGFuIHhtbG5zIGZvciBodG1sIGVsZW1lbnRzLCBpbiBjYXNlXG4gICAgLy8gb2YgYnJva2VuIG5hbWVzcGFjZVVSSSBoYW5kbGluZyBieSBicm93c2Vycy5cbiAgICBpZiAoIW5vZGVIYXNYbWxuc0F0dHIgJiZcbiAgICAgICAgICAgICghbm9kZS5wYXJlbnROb2RlIHx8XG4gICAgICAgICAgICAgbm9kZS5uYW1lc3BhY2VVUkkgIT09IG5vZGUucGFyZW50Tm9kZS5uYW1lc3BhY2VVUkkgfHxcbiAgICAgICAgICAgICBnZXRUYWdOYW1lKG5vZGUpID09PSAnaHRtbCcpKSB7XG4gICAgICAgICByZXR1cm4gJyB4bWxucz1cIicgKyBub2RlLm5hbWVzcGFjZVVSSSArICdcIic7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn07XG5cbnZhciBzZXJpYWxpemVDaGlsZHJlbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChub2RlLmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVUcmVlVG9YSFRNTChjaGlsZE5vZGUpO1xuICAgIH0pLmpvaW4oJycpO1xufTtcblxudmFyIHNlcmlhbGl6ZVRhZyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIG91dHB1dCA9ICc8JyArIGdldFRhZ05hbWUobm9kZSk7XG4gICAgb3V0cHV0ICs9IHNlcmlhbGl6ZU5hbWVzcGFjZShub2RlKTtcblxuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwobm9kZS5hdHRyaWJ1dGVzIHx8IG5vZGUuYXR0cnMsIGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgIG91dHB1dCArPSBzZXJpYWxpemVBdHRyaWJ1dGUoYXR0cik7XG4gICAgfSk7XG5cbiAgICBpZiAobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3V0cHV0ICs9ICc+JztcbiAgICAgICAgb3V0cHV0ICs9IHNlcmlhbGl6ZUNoaWxkcmVuKG5vZGUpO1xuICAgICAgICBvdXRwdXQgKz0gJzwvJyArIGdldFRhZ05hbWUobm9kZSkgKyAnPic7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ICs9ICcvPic7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG52YXIgc2VyaWFsaXplVGV4dCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIHRleHQgPSBub2RlLm5vZGVWYWx1ZSB8fCBub2RlLnZhbHVlIHx8ICcnO1xuICAgIHJldHVybiBzZXJpYWxpemVUZXh0Q29udGVudCh0ZXh0KTtcbn07XG5cbnZhciBzZXJpYWxpemVDb21tZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gJzwhLS0nICtcbiAgICAgICAgbm9kZS5kYXRhXG4gICAgICAgICAgICAucmVwbGFjZSgvLS9nLCAnJiM0NTsnKSArXG4gICAgICAgICctLT4nO1xufTtcblxudmFyIHNlcmlhbGl6ZUNEQVRBID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gJzwhW0NEQVRBWycgKyBub2RlLm5vZGVWYWx1ZSArICddXT4nO1xufTtcblxudmFyIG5vZGVUcmVlVG9YSFRNTCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjZG9jdW1lbnQnIHx8XG4gICAgICAgIG5vZGUubm9kZU5hbWUgPT09ICcjZG9jdW1lbnQtZnJhZ21lbnQnKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVDaGlsZHJlbihub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobm9kZS50YWdOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVGFnKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjdGV4dCcpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUZXh0KG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjY29tbWVudCcpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVDb21tZW50KG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjY2RhdGEtc2VjdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVDREFUQShub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydHMuc2VyaWFsaXplVG9TdHJpbmcgPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgICByZXR1cm4gcmVtb3ZlSW52YWxpZENoYXJhY3RlcnMobm9kZVRyZWVUb1hIVE1MKGRvY3VtZW50KSk7XG59O1xuIiwiLyoqXG4gKiBDcmVhdGVkIGJ5IFN0YXMgb24gMS8xNi8yMDE1LlxuICovXG5cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PSBDb25zdHJ1Y3Rpb24gPT09PT09PT09PT09PT09PT09PT09PT09PVxuLyoqXG4gKiBDb250YWlucyBnYW1lIG9wdGlvbiwgbWVhbnQgdG8gYmUgdXNlZCBhcyBzaW5nbGV0b25cbiAqIEB0eXBlIHt7YWxwaGFiZXQ6IHN0cmluZ319XG4gKi9cbnZhciBHYW1lU2V0dGluZ3MgPSB7XG4gICAgLy8gRm9udHNcbiAgICBsaWdodEZvbnQ6IFwiR290aGFtLUxpZ2h0XCIsXG4gICAgbWVkaXVtRm9udDogXCJHb3RoYW0tTWVkaXVtXCIsXG5cbiAgICAvLyBBdGxhc2VzXG4gICAgZ2FtZUF0bGFzOiBcImdhbWVBdGxhc1wiLFxuICAgIHVpQXRsYXM6IFwidWlBdGxhc1wiLFxuICAgIGFzc2V0U2NhbGU6IDEsXG5cbiAgICAvLyBEZXZpY2UgdmFyaWFibGVzIChzZXR0aW5ncyB0aGF0IGFyZSBhZmZlY3RlZCBieSBzcGVjaWZpYyBkZXZpY2VzKVxuICAgIGN1cnJlbnREZXZpY2U6IDAsXG4gICAgYW5pbWF0ZVBvcHVwczogdHJ1ZSwgLy8gcGxheSBwb3B1cCB0d2VlbnMgaWYgcnVubmluZyBpbiBXZWJHTCwgYnV0IG5vdCBpbiBjYW52YXNcbiAgICBjdWxsTGlzdEl0ZW1zOiBmYWxzZSwgLy8gbWFudWFsbHkgY3VsbCBsaXN0IGl0ZW1zIGlmIHRoZSBkZXZpY2UgZG9lc24ndCBzdXBwb3J0IG1hc2tpbmdcblxuICAgIC8vIEdhbWUgdmFyaWFibGVzXG4gICAgd2VyZU9wdGlvbnNDaGFuZ2VkOiBmYWxzZSxcblxuICAgIC8vIEFwcCB2YXJpYWJsZXNcbiAgICB2ZXJzaW9uOiBcIjAuMDFcIixcbiAgICBERUJVRzogdHJ1ZVxufTtcbm1vZHVsZS5leHBvcnRzID0gR2FtZVNldHRpbmdzO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09IFNpemVzID09PT09PT09PT09PT09PT09PT09PT09PT1cbkdhbWVTZXR0aW5ncy5TaXplcyA9IHtcbiAgICBzbWFsbDogXCJzbWFsbFwiLFxuICAgIG1lZGl1bTogXCJtZWRpdW1cIixcbiAgICBsYXJnZTogXCJsYXJnZVwiXG59O1xuT2JqZWN0LmZyZWV6ZShHYW1lU2V0dGluZ3MuU2l6ZXMpO1xuXG5HYW1lU2V0dGluZ3MuQXNzZXRTY2FsZXMgPSB7XG4gICAgc21hbGw6IDAuNixcbiAgICBtZWRpdW06IDAuOCxcbiAgICBsYXJnZTogMVxufTtcbk9iamVjdC5mcmVlemUoR2FtZVNldHRpbmdzLkFzc2V0U2NhbGVzKTtcblxuR2FtZVNldHRpbmdzLnNldEFzc2V0U2l6ZU11bHRpcGxpZXIgPSBmdW5jdGlvbiAoZ2FtZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGdhbWUuc2NhbGUuc2V0TWF4aW11bSgpO1xuICAgIGdhbWUuc2NhbGUucmVmcmVzaCgpO1xuICAgIGdhbWUuc2NhbGUuYm9vdCgpO1xuICAgIEdhbWVTZXR0aW5ncy5hc3NldFNjYWxlID0gR2FtZVNldHRpbmdzLkFzc2V0U2NhbGVzLmxhcmdlO1xuXG4gICAgdmFyIG1pblNpZGVMZW5ndGggPSBNYXRoLm1pbihnYW1lLnNjYWxlLndpZHRoLCBnYW1lLnNjYWxlLmhlaWdodCk7XG4gICAgaWYobWluU2lkZUxlbmd0aCA+IDkwMCl7XG4gICAgICAgIEdhbWVTZXR0aW5ncy5hc3NldFNjYWxlID0gR2FtZVNldHRpbmdzLkFzc2V0U2NhbGVzLmxhcmdlO1xuICAgIH1cbiAgICBlbHNlIGlmKG1pblNpZGVMZW5ndGg+NjAwKXtcbiAgICAgICAgR2FtZVNldHRpbmdzLmFzc2V0U2NhbGUgPSBHYW1lU2V0dGluZ3MuQXNzZXRTY2FsZXMubWVkaXVtO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgR2FtZVNldHRpbmdzLmFzc2V0U2NhbGUgPSBHYW1lU2V0dGluZ3MuQXNzZXRTY2FsZXMuc21hbGw7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKFwiR2FtZVNldHRpbmdzLnNldEFzc2V0U2l6ZU11bHRpcGxpZXIoKVwiLCBnYW1lLndpZHRoLCBnYW1lLmhlaWdodCwgR2FtZVNldHRpbmdzLmFzc2V0U2NhbGUpO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PSBPcHRpb25zID09PT09PT09PT09PT09PT09PT09PT09PT1cbkdhbWVTZXR0aW5ncy5PcHRpb25zID0ge1xuICAgIHNob3dUaW1lcjogdHJ1ZVxufTtcblxuR2FtZVNldHRpbmdzLmxvYWRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICh0eXBlb2YoU3RvcmFnZSkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdmFyIGxvYWRlZE9wdGlvbnMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIkdhbWVTZXR0aW5ncy5PcHRpb25zXCIpO1xuICAgICAgICBpZiAobG9hZGVkT3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICBHYW1lU2V0dGluZ3MuT3B0aW9ucyA9IEpTT04ucGFyc2UobG9hZGVkT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5HYW1lU2V0dGluZ3Muc2F2ZU9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZihTdG9yYWdlKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJHYW1lU2V0dGluZ3MuT3B0aW9uc1wiLCBKU09OLnN0cmluZ2lmeShHYW1lU2V0dGluZ3MuT3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkdhbWVTZXR0aW5ncy5zYXZlT3B0aW9ucygpXCIsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09IEVudW1zID09PT09PT09PT09PT09PT09PT09PT09PT1cbkdhbWVTZXR0aW5ncy5Qb3B1cFN0YXRlcyA9IHtcbiAgICBoaWRkZW46IDAsIC8vIFBvcHVwIGlzIG5vdCBzaG93blxuICAgIGFwcGVhcmluZzogMSwgLy8gUG9wdXAgaXMgcGxheWluZyBhIHR3ZWVuLWluIGFuaW1hdGlvblxuICAgIHZpc2libGU6IDIsIC8vIFBvcHVwIGlzIHNob3duIG9uc2NyZWVuXG4gICAgZGlzYXBwZWFyaW5nOiAzIC8vIFBvcHVwIGlzIHBsYXlpbmcgYSB0d2Vlbi1vdXQgYW5pbWF0aW9uLCByZXR1cm5zIHRvIEhpZGRlbiBzdGF0ZSBhZnRlcndhcmRzXG59O1xuT2JqZWN0LmZyZWV6ZShHYW1lU2V0dGluZ3MuUG9wdXBTdGF0ZXMpO1xuXG5HYW1lU2V0dGluZ3MuT3B0aW9uc0l0ZW1zID0ge1xuICAgIEhlbHA6IDMsXG4gICAgRXhpdFB1enpsZTogNVxufTtcbk9iamVjdC5mcmVlemUoR2FtZVNldHRpbmdzLk9wdGlvbnNJdGVtcyk7XG5cbkdhbWVTZXR0aW5ncy5FbmRHYW1lUmVhc29uID0ge1xuICAgIENvbXBsZXRlZDogXCJHYW1lIENvbXBsZXRlZFwiLFxuICAgIFF1aXQ6IFwiUXVpdFwiXG59O1xuT2JqZWN0LmZyZWV6ZShHYW1lU2V0dGluZ3MuRW5kR2FtZVJlYXNvbik7XG5cbkdhbWVTZXR0aW5ncy5JbnB1dFByaW9yaXRpZXMgPSB7XG4gICAgRGVmYXVsdDogMCxcbiAgICBTY3JpbTogMSxcbiAgICBQb3B1cHM6IDIsXG4gICAgUG9wdXBJdGVtczogMyxcbiAgICBCdXR0b25zOiA0XG59O1xuT2JqZWN0LmZyZWV6ZShHYW1lU2V0dGluZ3MuSW5wdXRQcmlvcml0aWVzKTtcblxuR2FtZVNldHRpbmdzLkRldmljZXMgPSB7XG4gICAgRGVza3RvcDogMCxcbiAgICBUYWJsZXQ6IDEsXG4gICAgUGhvbmU6IDJcbn07XG5PYmplY3QuZnJlZXplKEdhbWVTZXR0aW5ncy5EZXZpY2VzKTtcbiIsIi8qKlxuICogQSBGUFMgbWV0ZXIgUGx1Z2luIHRoYXQgaW50ZWdyYXRlcyBzdGF0anMgaW50byBwaGFzZXIganMgYmVoYXZpb3JcbiAqIHlvdSBuZWVkIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2Ivc3RhdHMuanMvIGluIG9yZGVyIHRvIG1ha2UgdGhpcyBwbHVnaW4gd29yayBwcm9wZXJseVxuICovXG52YXIgU3RhdHMgPSByZXF1aXJlKFwiLi9TdGF0c1wiKTtcblBoYXNlci5QbHVnaW4uRlBTTWV0ZXIgPSBmdW5jdGlvbiAoZ2FtZSwgcGFyZW50KSB7XG4gICAgUGhhc2VyLlBsdWdpbi5jYWxsKHRoaXMsIGdhbWUsIHBhcmVudCk7XG4gICAgdGhpcy5lbmFibGVTdGF0cygpO1xufTtcbi8vIEV4dGVuZHMgdGhlIFBoYXNlci5QbHVnaW4gdGVtcGxhdGUsIHNldHRpbmcgdXAgdmFsdWVzIHdlIG5lZWRcblBoYXNlci5QbHVnaW4uRlBTTWV0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQaGFzZXIuUGx1Z2luLnByb3RvdHlwZSk7XG5QaGFzZXIuUGx1Z2luLkZQU01ldGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBoYXNlci5QbHVnaW4uRlBTTWV0ZXI7XG4vKipcbiAqIFRoaXMgaXMgcnVuIHdoZW4gdGhlIHBsdWdpbnMgdXBkYXRlIGR1cmluZyB0aGUgY29yZSBnYW1lIGxvb3AuXG4gKi9cblBoYXNlci5QbHVnaW4uRlBTTWV0ZXIucHJvdG90eXBlLnByZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLlN0YXRzLmJlZ2luKCk7XG59O1xuUGhhc2VyLlBsdWdpbi5GUFNNZXRlci5wcm90b3R5cGUucG9zdFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLlN0YXRzLmVuZCgpO1xufTtcblBoYXNlci5QbHVnaW4uRlBTTWV0ZXIucHJvdG90eXBlLmVuYWJsZVN0YXRzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLlN0YXRzID0gbmV3IFN0YXRzKCk7XG4gICAgdGhpcy5TdGF0cy5zZXRNb2RlKDApOyAvLyAwOiBmcHMsIDE6IG1zXG5cbiAgICAvLyBhbGlnbiB0b3AtbGVmdFxuICAgIHRoaXMuU3RhdHMuZG9tRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy5TdGF0cy5kb21FbGVtZW50LnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICB0aGlzLlN0YXRzLmRvbUVsZW1lbnQuc3R5bGUudG9wID0gJzBweCc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggdGhpcy5TdGF0cy5kb21FbGVtZW50ICk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBQaGFzZXIuUGx1Z2luLkZQU01ldGVyO1xuLyoqXG4gKiBDcmVhdGVkIGJ5IFN0YXMgb24gMTIvMS8yMDE0LlxuICovXG4iLCIvKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IEl2YW5peCBNb2JpbGUgTExDXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKi9cblxuLypcbiAqIFBsdWdpbjogU2F2ZUNQVVxuICogQXV0aG9yOiBJdmFuaXggQCBJdmFuaXggTW9iaWxlIExMQ1xuICogUHVycG9zZTogIFJlZHVjZSBDUFUgdXNhZ2UgY2F1c2VkIGZyb20gcmVkdWRhbnQgcmVuZGVyaW5nXG4gKiAgICAgICAgICAgb24gaWRsZSBvciBzdGF0aWMgZGlzcGxheSBzY2VuZXNcbiAqICAgICAgICAgICByZWR1Y2UgZnBzIGZvciBjYXN1YWwvcHV6emxlIGdhbWVzXG4gKlxuICpcbiAqIENvbmZpZ3VyYWJsZSBQcm9wZXJ0aWVzOlxuICogICAgICAgICAgICAgICAgXG4gKiBbcmVuZGVyT25GUFNdICAgXG4gKiBDb25zdHJhaW5zIG1heGltdW0gRlBTIHRvIHZhbHVlIHNldC4gXG4gKiBSZWFzb25hYmxlIHZhbHVlcyBmcm9tIDAgdG8gNjAgXG4gKiBEZWZhdWx0IHZhbHVlIDMwXG4gKiBTZXQgdmFsdWUgdG8gMCBkaXNhYmxlIHJlbmRlcmluZyBiYXNlZCBvbiBGUFNcbiAqIGFuZCB1c2UgbWV0aG9kcyBkZXNjcmliZWQgYmVsb3cuXG4gKlxuICogW3JlbmRlck9uUG9pbnRlckNoYW5nZV0gICBcbiAqIFJlbmRlciB3aGVuIHBvaW50ZXIgbW92ZW1lbnQgZGV0ZWN0ZWQuXG4gKiBQb3NzaWJsZSB2YWx1ZXMgIFwidHJ1ZVwiIG9yIFwiZmFsc2VcIlxuICogRGVmYXVsdDogZmFsc2VcbiAqIE5vdGUgdGhhdCByZW5kZXJPbkZQUyBtdXN0IGJlIHNldCB0byAwXG4gKlxuICpcbiAqIENhbGxhYmxlIE1ldGhvZHM6XG4gKiBcbiAqIFtmb3JjZVJlbmRlcigpXVxuICogRm9yY2VzIHJlbmRlcmluZyBkdXJpbmcgY29yZSBnYW1lIGxvb3BcbiAqIENhbiBiZSBjYWxsZWQgaW5kZXBlbmRlbnRseSBvciBpbiB0YW5kZW0gd2l0aCBhYm92ZSBwcm9wZXJ0aWVzLlxuICogU2hvdWxkIGJlIGNhbGxlZCBpbnNpZGUgdXBkYXRlIGZ1bmN0aW9uLlxuICpcbiAqL1xuXG4vKmdsb2JhbFxuICAgIFBoYXNlcjogdHJ1ZSxcbiAgICB3aW5kb3c6IHRydWVcbiAqL1xuLypqc2xpbnQgbm9tZW46IHRydWUgKi9cblxuUGhhc2VyLlBsdWdpbi5TYXZlQ1BVID0gZnVuY3Rpb24gKGdhbWUsIHBhcmVudCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIFBoYXNlci5QbHVnaW4uY2FsbCh0aGlzLCBnYW1lLCBwYXJlbnQpO1xuXG59O1xuUGhhc2VyLlBsdWdpbi5TYXZlQ1BVLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGhhc2VyLlBsdWdpbi5wcm90b3R5cGUpO1xuUGhhc2VyLlBsdWdpbi5TYXZlQ1BVLmNvbnN0cnVjdG9yID0gUGhhc2VyLlBsdWdpbi5TYXZlQ1BVO1xuXG5QaGFzZXIuUGx1Z2luLlNhdmVDUFUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHRoaXMubm93ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMucmVuZGVyVHlwZSA9IHRoaXMuZ2FtZS5yZW5kZXJUeXBlO1xuXG4gICAgLy8gZnBzIGRlZmF1bHRcbiAgICB0aGlzLnJlbmRlck9uRlBTID0gMzA7XG4gICAgdGhpcy5yZW5kZXJPblBvaW50ZXJDaGFuZ2UgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlckRpcnR5ID0gdHJ1ZTtcbn07XG5QaGFzZXIuUGx1Z2luLlNhdmVDUFUucHJvdG90eXBlLnNldFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgaWYgKHRoaXMucmVuZGVyRGlydHkpIHtcbiAgICAgICAgdGhpcy5nYW1lLnJlbmRlclR5cGUgPSB0aGlzLnJlbmRlclR5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nYW1lLnJlbmRlclR5cGUgPSBQaGFzZXIuSEVBRExFU1M7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyRGlydHkgPSBmYWxzZTtcbn07XG5QaGFzZXIuUGx1Z2luLlNhdmVDUFUucHJvdG90eXBlLmZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB0aGlzLnJlbmRlckRpcnR5ID0gdHJ1ZTtcbn07XG5QaGFzZXIuUGx1Z2luLlNhdmVDUFUucHJvdG90eXBlLmZvcmNlUmVuZGVyT25Qb2ludGVyQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBcbiAgICB2YXIgaW5wdXQgPSB0aGlzLmdhbWUuaW5wdXQ7XG5cbiAgICBpZiAoaW5wdXQub2xkeCAhPT0gaW5wdXQueCB8fCBpbnB1dC5vbGR5ICE9PSBpbnB1dC55KSB7XG4gICAgICAgIHRoaXMuZm9yY2VSZW5kZXIoKTtcbiAgICAgICAgaW5wdXQub2xkeCA9IGlucHV0Lng7XG4gICAgICAgIGlucHV0Lm9sZHkgPSBpbnB1dC55O1xuICAgIH1cbiAgICBpZiAoaW5wdXQub2xkRG93biAhPT0gaW5wdXQuYWN0aXZlUG9pbnRlci5pc0Rvd24pIHtcbiAgICAgICAgdGhpcy5mb3JjZVJlbmRlcigpO1xuICAgICAgICBpbnB1dC5vbGREb3duID0gaW5wdXQuYWN0aXZlUG9pbnRlci5pc0Rvd247XG4gICAgfVxufTtcblBoYXNlci5QbHVnaW4uU2F2ZUNQVS5wcm90b3R5cGUuZm9yY2VSZW5kZXJPbkZQUyA9IGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgXG4gICAgdmFyIHRzLCBkaWZmO1xuXG4gICAgdHMgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgZGlmZiA9IHRzIC0gdGhpcy5ub3c7XG4gICAgaWYgKGRpZmYgPCAoMTAwMCAvIHRoaXMucmVuZGVyT25GUFMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5ub3cgPSB0cztcbiAgICB0aGlzLmZvcmNlUmVuZGVyKCk7XG4gICAgcmV0dXJuIHRydWU7XG5cbn07XG5QaGFzZXIuUGx1Z2luLlNhdmVDUFUucHJvdG90eXBlLnBvc3RVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGlmICh0aGlzLnJlbmRlck9uRlBTICYmIHRoaXMuZm9yY2VSZW5kZXJPbkZQUygpKSB7XG4gICAgICAgIHRoaXMuc2V0UmVuZGVyKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVuZGVyT25Qb2ludGVyQ2hhbmdlICYmIHRoaXMuZm9yY2VSZW5kZXJPblBvaW50ZXJDaGFuZ2UoKSkge1xuICAgICAgICB0aGlzLnNldFJlbmRlcigpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0UmVuZGVyKCk7XG59O1xuUGhhc2VyLlBsdWdpbi5TYXZlQ1BVLnByb3RvdHlwZS5wb3N0UmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBpZiAodGhpcy5nYW1lLl9wYXVzZWQpIHtcbiAgICAgICAgdGhpcy5nYW1lLnJlbmRlclR5cGUgPSBQaGFzZXIuSEVBRExFU1M7XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gUGhhc2VyLlBsdWdpbi5TYXZlQ1BVO1xuIiwiLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbnZhciBTdGF0cyA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKSwgcHJldlRpbWUgPSBzdGFydFRpbWU7XG5cdHZhciBtcyA9IDAsIG1zTWluID0gSW5maW5pdHksIG1zTWF4ID0gMDtcblx0dmFyIGZwcyA9IDAsIGZwc01pbiA9IEluZmluaXR5LCBmcHNNYXggPSAwO1xuXHR2YXIgZnJhbWVzID0gMCwgbW9kZSA9IDA7XG5cblx0dmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdGNvbnRhaW5lci5pZCA9ICdzdGF0cyc7XG5cdGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKCBldmVudCApIHsgZXZlbnQucHJldmVudERlZmF1bHQoKTsgc2V0TW9kZSggKysgbW9kZSAlIDIgKSB9LCBmYWxzZSApO1xuXHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9ICd3aWR0aDo4MHB4O29wYWNpdHk6MC45O2N1cnNvcjpwb2ludGVyJztcblxuXHR2YXIgZnBzRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblx0ZnBzRGl2LmlkID0gJ2Zwcyc7XG5cdGZwc0Rpdi5zdHlsZS5jc3NUZXh0ID0gJ3BhZGRpbmc6MCAwIDNweCAzcHg7dGV4dC1hbGlnbjpsZWZ0O2JhY2tncm91bmQtY29sb3I6IzAwMic7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZnBzRGl2ICk7XG5cblx0dmFyIGZwc1RleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRmcHNUZXh0LmlkID0gJ2Zwc1RleHQnO1xuXHRmcHNUZXh0LnN0eWxlLmNzc1RleHQgPSAnY29sb3I6IzBmZjtmb250LWZhbWlseTpIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZjtmb250LXNpemU6OXB4O2ZvbnQtd2VpZ2h0OmJvbGQ7bGluZS1oZWlnaHQ6MTVweCc7XG5cdGZwc1RleHQuaW5uZXJIVE1MID0gJ0ZQUyc7XG5cdGZwc0Rpdi5hcHBlbmRDaGlsZCggZnBzVGV4dCApO1xuXG5cdHZhciBmcHNHcmFwaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdGZwc0dyYXBoLmlkID0gJ2Zwc0dyYXBoJztcblx0ZnBzR3JhcGguc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDo3NHB4O2hlaWdodDozMHB4O2JhY2tncm91bmQtY29sb3I6IzBmZic7XG5cdGZwc0Rpdi5hcHBlbmRDaGlsZCggZnBzR3JhcGggKTtcblxuXHR3aGlsZSAoIGZwc0dyYXBoLmNoaWxkcmVuLmxlbmd0aCA8IDc0ICkge1xuXG5cdFx0dmFyIGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdzcGFuJyApO1xuXHRcdGJhci5zdHlsZS5jc3NUZXh0ID0gJ3dpZHRoOjFweDtoZWlnaHQ6MzBweDtmbG9hdDpsZWZ0O2JhY2tncm91bmQtY29sb3I6IzExMyc7XG5cdFx0ZnBzR3JhcGguYXBwZW5kQ2hpbGQoIGJhciApO1xuXG5cdH1cblxuXHR2YXIgbXNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRtc0Rpdi5pZCA9ICdtcyc7XG5cdG1zRGl2LnN0eWxlLmNzc1RleHQgPSAncGFkZGluZzowIDAgM3B4IDNweDt0ZXh0LWFsaWduOmxlZnQ7YmFja2dyb3VuZC1jb2xvcjojMDIwO2Rpc3BsYXk6bm9uZSc7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggbXNEaXYgKTtcblxuXHR2YXIgbXNUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblx0bXNUZXh0LmlkID0gJ21zVGV4dCc7XG5cdG1zVGV4dC5zdHlsZS5jc3NUZXh0ID0gJ2NvbG9yOiMwZjA7Zm9udC1mYW1pbHk6SGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjlweDtmb250LXdlaWdodDpib2xkO2xpbmUtaGVpZ2h0OjE1cHgnO1xuXHRtc1RleHQuaW5uZXJIVE1MID0gJ01TJztcblx0bXNEaXYuYXBwZW5kQ2hpbGQoIG1zVGV4dCApO1xuXG5cdHZhciBtc0dyYXBoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblx0bXNHcmFwaC5pZCA9ICdtc0dyYXBoJztcblx0bXNHcmFwaC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjc0cHg7aGVpZ2h0OjMwcHg7YmFja2dyb3VuZC1jb2xvcjojMGYwJztcblx0bXNEaXYuYXBwZW5kQ2hpbGQoIG1zR3JhcGggKTtcblxuXHR3aGlsZSAoIG1zR3JhcGguY2hpbGRyZW4ubGVuZ3RoIDwgNzQgKSB7XG5cblx0XHR2YXIgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ3NwYW4nICk7XG5cdFx0YmFyLnN0eWxlLmNzc1RleHQgPSAnd2lkdGg6MXB4O2hlaWdodDozMHB4O2Zsb2F0OmxlZnQ7YmFja2dyb3VuZC1jb2xvcjojMTMxJztcblx0XHRtc0dyYXBoLmFwcGVuZENoaWxkKCBiYXIgKTtcblxuXHR9XG5cblx0dmFyIHNldE1vZGUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0bW9kZSA9IHZhbHVlO1xuXG5cdFx0c3dpdGNoICggbW9kZSApIHtcblxuXHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRmcHNEaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdFx0XHRcdG1zRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRmcHNEaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdFx0bXNEaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHR9O1xuXG5cdHZhciB1cGRhdGVHcmFwaCA9IGZ1bmN0aW9uICggZG9tLCB2YWx1ZSApIHtcblxuXHRcdHZhciBjaGlsZCA9IGRvbS5hcHBlbmRDaGlsZCggZG9tLmZpcnN0Q2hpbGQgKTtcblx0XHRjaGlsZC5zdHlsZS5oZWlnaHQgPSB2YWx1ZSArICdweCc7XG5cblx0fTtcblxuXHRyZXR1cm4ge1xuXG5cdFx0UkVWSVNJT046IDEyLFxuXG5cdFx0ZG9tRWxlbWVudDogY29udGFpbmVyLFxuXG5cdFx0c2V0TW9kZTogc2V0TW9kZSxcblxuXHRcdGJlZ2luOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cblx0XHR9LFxuXG5cdFx0ZW5kOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHZhciB0aW1lID0gRGF0ZS5ub3coKTtcblxuXHRcdFx0bXMgPSB0aW1lIC0gc3RhcnRUaW1lO1xuXHRcdFx0bXNNaW4gPSBNYXRoLm1pbiggbXNNaW4sIG1zICk7XG5cdFx0XHRtc01heCA9IE1hdGgubWF4KCBtc01heCwgbXMgKTtcblxuXHRcdFx0bXNUZXh0LnRleHRDb250ZW50ID0gbXMgKyAnIE1TICgnICsgbXNNaW4gKyAnLScgKyBtc01heCArICcpJztcblx0XHRcdHVwZGF0ZUdyYXBoKCBtc0dyYXBoLCBNYXRoLm1pbiggMzAsIDMwIC0gKCBtcyAvIDIwMCApICogMzAgKSApO1xuXG5cdFx0XHRmcmFtZXMgKys7XG5cblx0XHRcdGlmICggdGltZSA+IHByZXZUaW1lICsgMTAwMCApIHtcblxuXHRcdFx0XHRmcHMgPSBNYXRoLnJvdW5kKCAoIGZyYW1lcyAqIDEwMDAgKSAvICggdGltZSAtIHByZXZUaW1lICkgKTtcblx0XHRcdFx0ZnBzTWluID0gTWF0aC5taW4oIGZwc01pbiwgZnBzICk7XG5cdFx0XHRcdGZwc01heCA9IE1hdGgubWF4KCBmcHNNYXgsIGZwcyApO1xuXG5cdFx0XHRcdGZwc1RleHQudGV4dENvbnRlbnQgPSBmcHMgKyAnIEZQUyAoJyArIGZwc01pbiArICctJyArIGZwc01heCArICcpJztcblx0XHRcdFx0dXBkYXRlR3JhcGgoIGZwc0dyYXBoLCBNYXRoLm1pbiggMzAsIDMwIC0gKCBmcHMgLyAxMDAgKSAqIDMwICkgKTtcblxuXHRcdFx0XHRwcmV2VGltZSA9IHRpbWU7XG5cdFx0XHRcdGZyYW1lcyA9IDA7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRpbWU7XG5cblx0XHR9LFxuXG5cdFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHN0YXJ0VGltZSA9IHRoaXMuZW5kKCk7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG5pZiAoIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICkge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gU3RhdHM7XG5cbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnYW1lID0gbmV3IFBoYXNlci5HYW1lKDE2MDAsIDEyMDAsIFBoYXNlci5BVVRPLCAnZ2FtZS10ZW1wbGF0ZScpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuXG53aW5kb3cuVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3V0aWxzJyk7XG53aW5kb3cucGxheWVyU3RhdGUgPSB7XG4gICAgY3VycmVudExldmVsOiAnR2FtZSdcbn07XG5cbmdhbWUuc3RhdGUuYWRkKCdCb290JywgcmVxdWlyZSgnLi9zdGF0ZXMvYm9vdCcpKTtcbmdhbWUuc3RhdGUuYWRkKCdQcmVsb2FkZXInLCByZXF1aXJlKCcuL3N0YXRlcy9wcmVsb2FkZXInKSk7XG5nYW1lLnN0YXRlLmFkZCgnTWVudScsIHJlcXVpcmUoJy4vc3RhdGVzL21lbnUnKSk7XG4vL2dhbWUuc3RhdGUuYWRkKCdHYW1lJywgcmVxdWlyZSgnLi9zdGF0ZXMvZ2FtZScpKTtcblxuZ2FtZS5zdGF0ZS5zdGFydCgnQm9vdCcpOyIsIi8qKlxyXG4gKiBDcmVhdGVkIGJ5IGtsaW1hc2hldnNreVxyXG4gKi9cclxudmFyIFBhbmVsTWFuYWdlck1vZHVsZSA9IHJlcXVpcmUoXCJhcmthZGl1bS1wYW5lbG1hbmFnZXItdGVzdFwiKTtcclxudmFyIEdhbWVTZXR0aW5ncyA9IHJlcXVpcmUoXCIuLi9HYW1lU2V0dGluZ3NcIik7XHJcbmZ1bmN0aW9uIFNhbXBsZVBhbmVsKGdhbWUsIGd1aUJ1aWxkZXIpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIFBhbmVsTWFuYWdlck1vZHVsZS5QYW5lbC5jYWxsKHRoaXMsIGdhbWUsIGd1aUJ1aWxkZXIpO1xyXG4gICAgXHJcbn1cclxuU2FtcGxlUGFuZWwuTkFNRSA9ICdTYW1wbGVQYW5lbCc7XHJcblxyXG5TYW1wbGVQYW5lbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBhbmVsTWFuYWdlck1vZHVsZS5QYW5lbC5wcm90b3R5cGUpO1xyXG5TYW1wbGVQYW5lbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTYW1wbGVQYW5lbDtcclxubW9kdWxlLmV4cG9ydHMgPSBTYW1wbGVQYW5lbDtcclxuXHJcblNhbXBsZVBhbmVsLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgUGFuZWxNYW5hZ2VyTW9kdWxlLlBhbmVsLnByb3RvdHlwZS5idWlsZC5jYWxsKHRoaXMpO1xyXG4gICAgdGhpcy5pbWcgPSBuZXcgUGhhc2VyLkltYWdlKHRoaXMuX2dhbWUsMCwwLCdnYW1lQmFja2dyb3VuZCcpO1xyXG4gICAgdGhpcy5hZGRDaGlsZCh0aGlzLmltZyk7XHJcblxyXG4gICAgdGhpcy5sYWJlbCA9IG5ldyBQaGFzZXIuQml0bWFwVGV4dCh0aGlzLl9nYW1lLCAwLCAwLCBHYW1lU2V0dGluZ3MubWVkaXVtRm9udCwgXCIxMDBcIiwgNTYpO1xyXG4gICAgdGhpcy5sYWJlbC50ZXh0ID0gXCJTYW1wbGUgUGFuZWwgXCIrIHRoaXMuX2RhdGEuY3VzdG9tRGF0YTtcclxuXHJcbiAgICB0aGlzLmxhYmVsLnkgPSAxMDA7XHJcblxyXG4gICAgdGhpcy5hZGRDaGlsZCh0aGlzLmxhYmVsKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIkkgd2FzIENyZWF0ZWRcIix0aGlzLl9kYXRhLmN1c3RvbURhdGEpO1xyXG5cclxufTtcclxuXHJcblNhbXBsZVBhbmVsLnByb3RvdHlwZS5kZXN0cm95PSBmdW5jdGlvbigpXHJcbntcclxuXHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5pbWcsdHJ1ZSlcclxuICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5sYWJlbCx0cnVlKVxyXG4gICAgUGFuZWxNYW5hZ2VyTW9kdWxlLlBhbmVsLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XHJcbn07XHJcblxyXG5TYW1wbGVQYW5lbC5wcm90b3R5cGUuY3JlYXRlU2hvd1RyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiBuZXcgUGFuZWxNYW5hZ2VyTW9kdWxlLlNob3dUcmFuc2l0aW9uTW92ZW1lbnQodGhpcy5fZ2FtZSwgdGhpcywgMCwgLTEwMDAsIDAsIDAsIDUwMCwgUGhhc2VyLkVhc2luZy5MaW5lYXIuTm9uZSk7XHJcbn07XHJcblxyXG5TYW1wbGVQYW5lbC5wcm90b3R5cGUuY3JlYXRlSGlkZVRyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHJldHVybiBuZXcgUGFuZWxNYW5hZ2VyTW9kdWxlLkhpZGVUcmFuc2l0aW9uTW92ZW1lbnQodGhpcy5fZ2FtZSwgdGhpcywgdGhpcy54LCB0aGlzLnkgLSAxMDAwLCA1MDAsIFBoYXNlci5FYXNpbmcuTGluZWFyLk5vbmUpO1xyXG59O1xyXG5cclxuIiwidmFyIFNhdmVDUFUgPSByZXF1aXJlKFwiLi4vUGx1Z2lucy9TYXZlQ1BVXCIpO1xudmFyIEZQU01ldGVyID0gcmVxdWlyZShcIi4uL1BsdWdpbnMvRlBTTWV0ZXJcIik7XG52YXIgQm9vdCA9IGZ1bmN0aW9uICgpIHtcbn07XG5cbkJvb3QucHJvdG90eXBlID0ge1xuXG4gICAgcHJlbG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgY29uc29sZS5sb2coXCJib290IHN0YXJ0ZWRcIik7XG4gICAgICAgIC8vSlNHYW1lQWRhcHQuSW5pdGlhbGl6ZSgnNmQ3MDI4NjgtNDNlYS00MzZiLWE0NjEtZjI4ODU3NmNkMzY0JywgJ2E4ODBiZjg4LTlmMDAtNGQwMy04YzIzLTA5NjEzMGRmOWJiNScsICdodHRwOi8vYWRhcHQuYXMuYXJrYWRpdW1ob3N0ZWQuY29tLycsIHRydWUpO1xuICAgICAgICB0aGlzLmdhbWUuc3RhZ2Uuc2V0QmFja2dyb3VuZENvbG9yKFwiMHhmZmZmZmZcIik7XG4gICAgfSxcblxuICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdGhpcy5nYW1lLnNjYWxlLnNjYWxlTW9kZSA9IFBoYXNlci5TY2FsZU1hbmFnZXIuUkVTSVpFO1xuICAgICAgICB0aGlzLmdhbWUuc2NhbGUucGFnZUFsaWduSG9yaXpvbnRhbGx5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5nYW1lLnNjYWxlLnBhZ2VBbGlnblZlcnRpY2FsbHkgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdhbWUuc2NhbGUuaGVpZ2h0KTtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5nYW1lLnNjYWxlLndpZHRoKTtcbiAgICAgICAgdGhpcy5nYW1lLnBsdWdpbnMuYWRkKFNhdmVDUFUpO1xuICAgICAgICAvL3RoaXMuZ2FtZS5wbHVnaW5zLmFkZChGUFNNZXRlcik7XG4gICAgICAgIHRoaXMuZ2FtZS5zdGF0ZS5zdGFydCgnUHJlbG9hZGVyJyk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb290O1xuIiwidmFyIFBhbmVsTWFuYWdlck1vZHVsZSA9IHJlcXVpcmUoXCJhcmthZGl1bS1wYW5lbG1hbmFnZXItdGVzdFwiKTtcbnZhciBTYW1wbGVQYW5lbCA9IHJlcXVpcmUoXCIuLi9wYW5lbC9TYW1wbGVQYW5lbFwiKTtcbnZhciBHYW1lU2V0dGluZ3MgPSByZXF1aXJlKFwiLi4vR2FtZVNldHRpbmdzXCIpO1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PSBDb25zdHJ1Y3Rpb24gPT09PT09PT09PT09PT09PT09PT09PT09PVxudmFyIE1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB0aGlzLnB1enpsZUluZm9MaXN0ID0gW107IC8vIExpc3Qgb2YgaW5mbyBmb3IgYWxsIHRoZSBwdXp6bGVzIHRoYXQgd2UgYXR0ZW1wdGVkIHRvIGxvYWRcbn07XG5cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PSBQcm90b3R5cGUgPT09PT09PT09PT09PT09PT09PT09PT09PVxuTWVudS5wcm90b3R5cGUgPSB7XG4gIHByZWxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG5cbiAgfSxcblxuICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2FtZV9wcmVsb2FkZXInKS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT0gQ29udGFpbmVyID09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIHRoaXMuY29udGFpbmVyID0gbmV3IFBoYXNlci5Hcm91cCh0aGlzLmdhbWUsbnVsbCk7XG4gICAgdGhpcy5nYW1lLmFkZC5leGlzdGluZyh0aGlzLmNvbnRhaW5lcik7XG5cbiAgICAvL2luIGNhc2UgaWYgeW91IGhhdmUgZ3VpYnVpbGRlciBtb2R1bGUgeW91IGNhbiBwYXNzIGl0IGhlcmUgYW5kIHVzZSBpbiB5b3VyIHBhbmVsc1xuICAgIHZhciBndWlCdWlsZGVyID0gbnVsbDtcbiAgICB0aGlzLl9wYW5lbE1hbmFnZXIgPSBuZXcgUGFuZWxNYW5hZ2VyTW9kdWxlLlBhbmVsTWFuYWdlcih0aGlzLmdhbWUsZ3VpQnVpbGRlcixcImxhbmRzY2FwZVwiKTtcbiAgICB0aGlzLl9wYW5lbE1hbmFnZXIuc2V0Um9vdCh0aGlzLmNvbnRhaW5lcilcbiAgICB0aGlzLl9wYW5lbE1hbmFnZXIucmVnaXN0ZXJQYW5lbChcInNhbXBsZV9wYW5lbFwiLFNhbXBsZVBhbmVsKVxuXG4gICAgdGhpcy5sYWJlbCA9IG5ldyBQaGFzZXIuQml0bWFwVGV4dCh0aGlzLmdhbWUsIDAsIDAsIEdhbWVTZXR0aW5ncy5tZWRpdW1Gb250LCBcIjEwMFwiLCA1Nik7XG4gICAgdGhpcy5sYWJlbC50ZXh0ID0gXCJDTElDSyBUTyBPUEVOIFBBTkVMXCI7XG4gICAgdGhpcy5sYWJlbC50aW50ID0gMHhiMzZkNDM7XG4gICAgdGhpcy5nYW1lLmFkZC5leGlzdGluZyh0aGlzLmxhYmVsKTtcbiAgICB0aGlzLm9wZW5lZCA9IGZhbHNlO1xuICAgIHRoaXMuZ2FtZS5pbnB1dC5tb3VzZS5tb3VzZURvd25DYWxsYmFjayA9IHRoaXMub25JbnB1dERvd25IYW5kbGVyLmJpbmQodGhpcyk7XG5cblxuICAgIC8vdGhpcy5fcGFuZWxNYW5hZ2VyLm9wZW4oXCJzYW1wbGVfcGFuZWxcIix7Y3VzdG9tRGF0YTpcIkJsYSBibGEgYmxhXCJ9KTtcbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgdGhpcy5vblJlc2l6ZSgpO1xuICB9LFxuXG4gIG9uSW5wdXREb3duSGFuZGxlcjpmdW5jdGlvbiAoc3ByaXRlLCBwb2ludGVyKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICAgIGlmKHRoaXMub3BlbmVkID09IHRydWUpXG4gICAge1xuICAgICAgdGhpcy5sYWJlbC50ZXh0ID0gXCJDTElDSyBUTyBPUEVOIFBBTkVMXCI7XG4gICAgICB0aGlzLm9wZW5lZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fcGFuZWxNYW5hZ2VyLmNsb3NlKFwic2FtcGxlX3BhbmVsXCIpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgdGhpcy5sYWJlbC50ZXh0ID0gXCJDTElDSyBUTyBDTE9TRSBQQU5FTFwiO1xuICAgICAgdGhpcy5vcGVuZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fcGFuZWxNYW5hZ2VyLm9wZW4oXCJzYW1wbGVfcGFuZWxcIiwge2N1c3RvbURhdGE6IFwiQmxhIGJsYSBibGFcIn0pO1xuICAgIH1cblxuICB9LFxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT0gVXBkYXRlID09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgfSxcblxuICBvblJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgLy8gV2UgbmVlZCB0byBjYWxsIHRoaXMgdHdpY2UuLi5cbiAgfSxcblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09IEJ1dHRvbiBFdmVudCA9PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgc3RhcnRHYW1lU2NlbmU6IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIC8vIENsZWFyIHRoaXMgc3RhdGUgYW5kIHN3aXRjaCB0byBuZXcgb25lXG4gICAgdGhpcy5kZXN0cm95KCk7XG4gICAgdGhpcy5nYW1lLnN0YXRlLmNsZWFyQ3VycmVudFN0YXRlKCk7XG4gICAgdGhpcy5nYW1lLnN0YXRlLnN0YXJ0KCdHYW1lJyk7XG4gIH0sXG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PSBEZXN0cnVjdGlvbiA9PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHRoaXMuZ2FtZS5zY2FsZS5vblNpemVDaGFuZ2UucmVtb3ZlKHRoaXMub25SZXNpemUsIHRoaXMpO1xuICAgIHRoaXMucGxheUJ1dHRvbi5kZXN0cm95KCk7XG4gIH1cbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT0gRXhwb3J0cyA9PT09PT09PT09PT09PT09PT09PT09PT09XG5tb2R1bGUuZXhwb3J0cyA9IE1lbnU7IiwiXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09IFJlcXVpcmVtZW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09XG52YXIgeG1sID0gcmVxdWlyZSgnWE1MJyk7XG52YXIgR2FtZVNldHRpbmdzID0gcmVxdWlyZShcIi4uL0dhbWVTZXR0aW5nc1wiKTtcbnZhciB4bWxzZXJpYWxpemVyID0gcmVxdWlyZSgneG1sc2VyaWFsaXplcicpO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09IENvbnN0cnVjdGlvbiA9PT09PT09PT09PT09PT09PT09PT09PT09XG52YXIgUHJlbG9hZGVyID0gZnVuY3Rpb24gKGdhbWUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB0aGlzLmFzc2V0ID0gbnVsbDtcbiAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5wcmVsb2FkQmFyID0gbnVsbDtcbiAgICB0aGlzLnByZWxvYWRhbmltYXRpb25Db21wbGV0ZSA9IGZhbHNlO1xuICAgIHRoaXMuYWxsUHJlbG9hZGluZ0NvbXBsZXRlID0gZmFsc2U7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBQcmVsb2FkZXI7XG5cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PSBQcm90b3R5cGUgPT09PT09PT09PT09PT09PT09PT09PT09PVxuUHJlbG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICAgIC8vIHJlZ2lvbiA9PT09PT09PT09PT09PT09PT09PT09PT09IFByZWxvYWRpbmcgPT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIHByZWxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdmFyaWFibGVzXG4gICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSB0aGlzO1xuICAgICAgICB0aGlzLnByZWxvYWRhbmltYXRpb25Db21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFsbFByZWxvYWRpbmdDb21wbGV0ZSA9IGZhbHNlO1xuXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnYW1lX3ByZWxvYWRlcicpLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcbiAgICAgICAgR2FtZVNldHRpbmdzLnNldEFzc2V0U2l6ZU11bHRpcGxpZXIodGhpcy5nYW1lKTtcblxuICAgICAgICAvLyBMb2FkIHRoZSBhc3NldHMgdXNlZCBpbiB0aGUgZ2FtZVxuICAgICAgICB0aGlzLmxvYWQuaW1hZ2UoJ2dhbWVTY3JpbScsICdhc3NldHMvaW1hZ2VzL2dhbWVTY3JpbS5wbmcnKTtcbiAgICAgICAgdGhpcy5sb2FkLmltYWdlKCdnYW1lQmFja2dyb3VuZCcsICdhc3NldHMvaW1hZ2VzL2dhbWVCYWNrZ3JvdW5kLmpwZycpO1xuICAgICAgICB0aGlzLmxvYWQuYXRsYXMoR2FtZVNldHRpbmdzLmdhbWVBdGxhcywgJ2Fzc2V0cy9pbWFnZXMvJytHYW1lU2V0dGluZ3MuYXNzZXRTY2FsZSsneC8nK0dhbWVTZXR0aW5ncy5nYW1lQXRsYXMrJy5wbmcnLCAnYXNzZXRzL2ltYWdlcy8nK0dhbWVTZXR0aW5ncy5hc3NldFNjYWxlKyd4LycrR2FtZVNldHRpbmdzLmdhbWVBdGxhcysnLmpzb24nKTtcbiAgICAgICAgdGhpcy5sb2FkLmF0bGFzKEdhbWVTZXR0aW5ncy51aUF0bGFzLCAnYXNzZXRzL2ltYWdlcy8nK0dhbWVTZXR0aW5ncy5hc3NldFNjYWxlKyd4LycrR2FtZVNldHRpbmdzLnVpQXRsYXMrJy5wbmcnLCAnYXNzZXRzL2ltYWdlcy8nK0dhbWVTZXR0aW5ncy5hc3NldFNjYWxlKyd4LycrR2FtZVNldHRpbmdzLnVpQXRsYXMrJy5qc29uJyk7XG4gICAgICAgIHRoaXMubG9hZC54bWwoR2FtZVNldHRpbmdzLmxpZ2h0Rm9udCArIFwiLmZudFwiLCAnYXNzZXRzL2ZvbnRzLycrR2FtZVNldHRpbmdzLmxpZ2h0Rm9udCsnLmZudCcpO1xuICAgICAgICB0aGlzLmxvYWQueG1sKEdhbWVTZXR0aW5ncy5tZWRpdW1Gb250ICsgXCIuZm50XCIsICdhc3NldHMvZm9udHMvJytHYW1lU2V0dGluZ3MubWVkaXVtRm9udCsnLmZudCcpO1xuXG4gICAgICAgIC8vIEFuYWx5dGljc1xuICAgICAgICBKU0dhbWVBZGFwdC5UcmFjay5CZWdpblNlc3Npb24oKTtcbiAgICAgICAgSlNHYW1lQWRhcHQuVHJhY2suUGFnZVZpZXcoSlNHYW1lQWRhcHQuUEFHRVZJRVdfQkVHSU5fTE9BRElORyk7XG5cbiAgICAgICAgLy8gREVCVUc6IFRoZXNlIG5leHQgMyBsaW5lcyBhcmUgZm9yIGRlYnVnZ2luZywgdHVybiB0aGlzIG9uIGlmIHlvdSB3YW50IHRvIHJlbW92ZSB0aGUgYW5pbWF0ZWQgbG9nb1xuICAgICAgICBpZiAoR2FtZVNldHRpbmdzLkRFQlVHKSB7XG4gICAgICAgICAgICBBUktfZ2FtZUpRKCcjc3dpZmZ5Y29udGFpbmVyJykucmVtb3ZlQ2xhc3MoJ3Zpc2libGUnKTtcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZS5wcmVsb2FkYW5pbWF0aW9uQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIFN3aWZmeSBhbmltYXRpb25cbiAgICAgICAgdmFyIHN3aWZmeW9iamVjdCA9IHRoaXMuZ2V0U3dpZmZ5RGF0YSgpO1xuICAgICAgICB0aGlzLnN0YWdlID0gbmV3IHN3aWZmeS5TdGFnZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3dpZmZ5Y29udGFpbmVyJyksIHN3aWZmeW9iamVjdCk7XG4gICAgICAgIHRoaXMuc3RhZ2Uuc3RhcnQoKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZS5wcmVsb2FkYW5pbWF0aW9uQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgQVJLX2dhbWVKUSgnI3N3aWZmeWNvbnRhaW5lcicpLnJlbW92ZUNsYXNzKCd2aXNpYmxlJyk7XG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2FtZV9wcmVsb2FkZXInKS5zdHlsZS52aXNpYmlsaXR5PVwidmlzaWJsZVwiO1xuICAgICAgICAgICAgY3VycmVudFN0YXRlLnN0YWdlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGlmKGN1cnJlbnRTdGF0ZS5hbGxQcmVsb2FkaW5nQ29tcGxldGUgPT09IHRydWUpe1xuICAgICAgICAgICAgICAgY3VycmVudFN0YXRlLmZpbmlzaGVkUHJlbG9hZGluZ0FuZFByZWxvYWRlckFuaW1hdGlvbigpO1xuICAgICAgICAgICAgfX0sNTAwMCApO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2FtZV9wcmVsb2FkZXInKS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICB9LFxuICAgIC8vIGVuZHJlZ2lvblxuXG4gICAgLy8gcmVnaW9uID09PT09PT09PT09PT09PT09PT09PT09PT0gQ3JlYXRpb24gPT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgQVJLX2dhbWVfYXJlbmFfY29ubmVjdG9yLmluaXQoKTsgLy8gSW5pdGlhbGl6ZSBhcmVuYSBjb25uZWN0aW9uXG4gICAgICAgIHRoaXMuZGV0ZXJtaW5lRGV2aWNlKCk7IC8vIERldGVybWluZSB0aGUgZGV2aWNlIHRoYXQgdGhlIHBsYXllciBpcyBwbGF5aW5nIG9uXG4gICAgICAgIHRoaXMuZGV0ZXJtaW5lQ2FwYWJpbGl0eSgpOyAvLyBEZXRlcm1pbmUgaWYgdGhlIGRldmljZSBjYW4gcnVuIGNlcnRhaW4gcHJvY2Vzc2VzXG4gICAgICAgIHRoaXMubG9hZEJpdG1hcEZvbnRzKCk7IC8vIExvYWQgYml0bWFwIGZvbnRzXG4gICAgICAgIEdhbWVTZXR0aW5ncy5sb2FkT3B0aW9ucygpOyAvLyBMb2FkIHNhdmVkIGdhbWUgb3B0aW9uc1xuICAgIH0sXG5cbiAgICBkZXRlcm1pbmVEZXZpY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgLy8gRmlyc3QsIGNoZWNrIGlmIHRoZSBnYW1lIGlzIHJ1bm5pbmcgb24gZGVza3RvcFxuICAgICAgICAvLyBcImRldmljZS5kZXNrdG9wXCIgcmVwb3J0cyBpbmFjY3VyYXRlbHkgb24gSW50ZXJuZXQgRXhwbG9yZXIsIHNvIHdlJ2xsIGFzc3VtZSBhbnlvbmUgdXNpbmcgSUUgYW5kIG5vdCBXaW5kb3dzIFBob25lIGlzIG9uIGEgZGVza3RvcFxuICAgICAgICBpZiAodGhpcy5nYW1lLmRldmljZS5kZXNrdG9wIHx8ICh0aGlzLmdhbWUuZGV2aWNlLmllICYmICF0aGlzLmdhbWUuZGV2aWNlLndpbmRvd3NQaG9uZSkpIHtcbiAgICAgICAgICAgIEdhbWVTZXR0aW5ncy5jdXJyZW50RGV2aWNlID0gR2FtZVNldHRpbmdzLkRldmljZXMuRGVza3RvcDtcbiAgICAgICAgICAgIEdhbWVTZXR0aW5ncy5tYXhHcmlkU2NhbGUgPSAwLjk0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBvbmx5IHRhYmxldCB3ZSBjYW4gZGV0ZWN0IGFjY3VyYXRlbHkgaXMgdGhlIGlQYWRcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBsb29rIGF0IHRoZSB3aW5kb3cgc2l6ZSBhbmQgaWYgaXQncyBncmVhdGVyIHRoYW4gODAwLCB0aGVuIGNvbnNpZGVyIGl0IGEgdGFibGV0XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZ2FtZS5kZXZpY2UuaVBhZCB8fCBNYXRoLm1pbih3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KSA+IDgwMCkge1xuICAgICAgICAgICAgR2FtZVNldHRpbmdzLmN1cnJlbnREZXZpY2UgPSBHYW1lU2V0dGluZ3MuRGV2aWNlcy5UYWJsZXQ7XG4gICAgICAgICAgICBHYW1lU2V0dGluZ3MuYWxsb3dDbHVlTGlzdFRvZ2dsaW5nID0gdHJ1ZTsgLy8gQWxsb3cgcGxheWVycyB0byBtYW51YWxseSBzd2l0Y2ggYmV0d2VlbiB0YWJsZXQvcGhvbmUgbGF5b3V0c1xuICAgICAgICAgICAgR2FtZVNldHRpbmdzLk9wdGlvbnMuc2hvd0NsdWVMaXN0cyA9IHRydWU7IC8vIEJ1dCBzaG93IGNsdWUgbGlzdHMgYnkgZGVmYXVsdFxuICAgICAgICB9XG4gICAgICAgIC8vIFdlIHdpbGwgYXNzdW1lIGV2ZXJ5dGhpbmcgZWxzZSBpcyBhIHBob25lXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgR2FtZVNldHRpbmdzLmN1cnJlbnREZXZpY2UgPSBHYW1lU2V0dGluZ3MuRGV2aWNlcy5QaG9uZTtcbiAgICAgICAgICAgIEdhbWVTZXR0aW5ncy5hbGxvd0NsdWVMaXN0VG9nZ2xpbmcgPSB0cnVlOyAvLyBBbGxvdyBwbGF5ZXJzIHRvIG1hbnVhbGx5IHN3aXRjaCBiZXR3ZWVuIHRhYmxldC9waG9uZSBsYXlvdXRzXG4gICAgICAgICAgICBHYW1lU2V0dGluZ3MuT3B0aW9ucy5zaG93Q2x1ZUxpc3RzID0gZmFsc2U7IC8vIEJ1dCBvIG5vdCBzaG93IGNsdWUgbGlzdHMgYnkgZGVmYXVsdFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRldGVybWluZUNhcGFiaWxpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgaWYgKCF0aGlzLmdhbWUuZGV2aWNlLndlYkdMIHx8ICh0aGlzLmdhbWUucmVuZGVyZXIgaW5zdGFuY2VvZiBQSVhJLkNhbnZhc1JlbmRlcmVyKSkge1xuICAgICAgICAgICAgLy9UT0RPOiBhZGQgZmVhdHVyZXMgaGVyZSB0aGF0IHdlIHdvdWxkIGxpa2UgdG8gdHVybiBvZmYgaW4gbG93IHF1YWxpdHkgZW52aXJvbm1lbnRzXG4gICAgICAgIH1cbiAgICAgICAgLy8gI2ZpeDogV2UgbmVlZCB0byBtYW51YWxseSBjdWxsIGxpc3QgaXRlbXMgaWYgdGhlIGRldmljZSBkb2VzIG5vdCBzdXBwb3J0IG1hc2tzXG4gICAgICAgIC8vIFRoaXMgc3BlY2lmaWNhbGx5IGZpeGVzIFNhbXN1bmcgR2FsYXh5IHN0b2NrIGJyb3dzZXJzLCB3aGljaCByZXBvcnQgYXMgU2FmYXJpXG4gICAgICAgIGlmICh0aGlzLmdhbWUuZGV2aWNlLnNhZmFyaSkge1xuICAgICAgICAgICAgR2FtZVNldHRpbmdzLmN1bGxMaXN0SXRlbXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIGVuZHJlZ2lvblxuXG4gICAgLy8gcmVnaW9uID09PT09PT09PT09PT09PT09PT09PT09PT0gRm9udHMgPT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIGxvYWRCaXRtYXBGb250czogZnVuY3Rpb24gKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdGhpcy5udW1Gb250c1RvTG9hZCA9IDI7XG4gICAgICAgIHRoaXMubG9hZEJpdG1hcEZvbnRGcm9tU2hhcmVkQXRsYXMoR2FtZVNldHRpbmdzLmdhbWVBdGxhcywgR2FtZVNldHRpbmdzLm1lZGl1bUZvbnQrXCIucG5nXCIsIEdhbWVTZXR0aW5ncy5tZWRpdW1Gb250KTtcbiAgICAgICAgdGhpcy5sb2FkQml0bWFwRm9udEZyb21TaGFyZWRBdGxhcyhHYW1lU2V0dGluZ3MuZ2FtZUF0bGFzLCBHYW1lU2V0dGluZ3MubGlnaHRGb250K1wiLnBuZ1wiLCBHYW1lU2V0dGluZ3MubGlnaHRGb250KTtcbiAgICB9LFxuXG4gICAgbG9hZEJpdG1hcEZvbnRGcm9tU2hhcmVkQXRsYXM6IGZ1bmN0aW9uKGF0bGFzTmFtZSwgdGV4dHVyZUZyYW1lTmFtZSwgZm9udE5hbWUpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIC8vIEdldCB0aGUgLmZudCBmaWxlXG4gICAgICAgIHZhciB0ZXh0dXJlRGF0YSA9IHRoaXMuZ2FtZS5jYWNoZS5nZXRGcmFtZUJ5TmFtZShhdGxhc05hbWUsIHRleHR1cmVGcmFtZU5hbWUpO1xuICAgICAgICB2YXIgZm9udFhNTCA9IHRoaXMuZ2FtZS5jYWNoZS5nZXRYTUwoZm9udE5hbWUgKyBcIi5mbnRcIik7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBmaXJzdCBjaGlsZCBub2RlLlxuICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCB3ZSBuZWVkIHRvIGRvIHRoaXMgc2V2ZXJhbCBkaWZmZXJlbnQgd2F5cyB0byBzdXBwb3J0IGRpZmZlcmVudCBicm93c2VyIEFQSXNcbiAgICAgICAgdmFyIGZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChmb250WE1MLmNoaWxkcmVuKSB7IGZpcnN0Q2hpbGQgPSBmb250WE1MLmNoaWxkcmVuWzBdOyB9XG4gICAgICAgIGVsc2UgaWYgKGZvbnRYTUwuY2hpbGROb2RlcykgeyBmaXJzdENoaWxkID0gZm9udFhNTC5jaGlsZE5vZGVzWzBdOyB9XG4gICAgICAgIGVsc2UgaWYgKGZvbnRYTUwuZmlyc3RFbGVtZW50Q2hpbGQpIHsgZmlyc3RDaGlsZCA9IGZvbnRYTUwuZmlyc3RFbGVtZW50Q2hpbGQ7IH1cblxuICAgICAgICAvLyBBZGQgdGhlIHRleHR1cmUgb2Zmc2V0IHRvIGFsbCBjaGFyYWN0ZXJzXG4gICAgICAgIHZhciBjaGFycyA9IGZpcnN0Q2hpbGQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjaGFyc1wiKTtcbiAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gY2hhcnNbMF0uZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgIHZhciBpbmZvID0gZmlyc3RDaGlsZC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImluZm9cIilbMF07XG4gICAgICAgIHZhciBwYWRkaW5nID0gaW5mby5hdHRyaWJ1dGVzLnBhZGRpbmcudmFsdWUuc3BsaXQoXCIsXCIpWzBdO1xuXG4gICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZS5uZXh0RWxlbWVudFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLmF0dHJpYnV0ZXMueC52YWx1ZSA9IHRleHR1cmVEYXRhLnggKyBNYXRoLmNlaWwoKHBhcnNlSW50KGN1cnJlbnROb2RlLmF0dHJpYnV0ZXMueC52YWx1ZSkgLSBwYWRkaW5nKSAqIEdhbWVTZXR0aW5ncy5hc3NldFNjYWxlKTtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLmF0dHJpYnV0ZXMueS52YWx1ZSA9IHRleHR1cmVEYXRhLnkgKyBNYXRoLmNlaWwoKHBhcnNlSW50KGN1cnJlbnROb2RlLmF0dHJpYnV0ZXMueS52YWx1ZSkgLSBwYWRkaW5nKSAqIEdhbWVTZXR0aW5ncy5hc3NldFNjYWxlKTtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLmF0dHJpYnV0ZXMud2lkdGgudmFsdWUgPSBNYXRoLmNlaWwocGFyc2VJbnQoY3VycmVudE5vZGUuYXR0cmlidXRlcy53aWR0aC52YWx1ZSkgKiBHYW1lU2V0dGluZ3MuYXNzZXRTY2FsZSk7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZS5hdHRyaWJ1dGVzLmhlaWdodC52YWx1ZSA9IE1hdGguY2VpbChwYXJzZUludChjdXJyZW50Tm9kZS5hdHRyaWJ1dGVzLmhlaWdodC52YWx1ZSkgKiBHYW1lU2V0dGluZ3MuYXNzZXRTY2FsZSk7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZS5hdHRyaWJ1dGVzLnhvZmZzZXQudmFsdWUgPSBNYXRoLmNlaWwocGFyc2VJbnQoY3VycmVudE5vZGUuYXR0cmlidXRlcy54b2Zmc2V0LnZhbHVlKSAqIEdhbWVTZXR0aW5ncy5hc3NldFNjYWxlKTtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLmF0dHJpYnV0ZXMueW9mZnNldC52YWx1ZSA9IE1hdGgucm91bmQocGFyc2VJbnQoY3VycmVudE5vZGUuYXR0cmlidXRlcy55b2Zmc2V0LnZhbHVlKSAqIEdhbWVTZXR0aW5ncy5hc3NldFNjYWxlKTtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLmF0dHJpYnV0ZXMueGFkdmFuY2UudmFsdWUgPSBNYXRoLmNlaWwocGFyc2VJbnQoY3VycmVudE5vZGUuYXR0cmlidXRlcy54YWR2YW5jZS52YWx1ZSkgKiBHYW1lU2V0dGluZ3MuYXNzZXRTY2FsZSk7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY29tbW9uIGVsZW1lbnRzIGFzIHdlbGxcbiAgICAgICAgdmFyIGNvbW1vbiA9IGZpcnN0Q2hpbGQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjb21tb25cIilbMF07XG4gICAgICAgIGNvbW1vbi5hdHRyaWJ1dGVzLmJhc2UudmFsdWUgPSBNYXRoLmNlaWwocGFyc2VJbnQoY29tbW9uLmF0dHJpYnV0ZXMuYmFzZS52YWx1ZSkgKiBHYW1lU2V0dGluZ3MuYXNzZXRTY2FsZSk7XG4gICAgICAgIGNvbW1vbi5hdHRyaWJ1dGVzLmxpbmVIZWlnaHQudmFsdWUgPSBNYXRoLmNlaWwocGFyc2VJbnQoY29tbW9uLmF0dHJpYnV0ZXMubGluZUhlaWdodC52YWx1ZSkgKiBHYW1lU2V0dGluZ3MuYXNzZXRTY2FsZSk7XG4gICAgICAgIGNvbW1vbi5hdHRyaWJ1dGVzLnNjYWxlVy52YWx1ZSA9IE1hdGguY2VpbChwYXJzZUludChjb21tb24uYXR0cmlidXRlcy5zY2FsZVcudmFsdWUpICogR2FtZVNldHRpbmdzLmFzc2V0U2NhbGUpO1xuICAgICAgICBjb21tb24uYXR0cmlidXRlcy5zY2FsZUgudmFsdWUgPSBNYXRoLmNlaWwocGFyc2VJbnQoY29tbW9uLmF0dHJpYnV0ZXMuc2NhbGVILnZhbHVlKSAqIEdhbWVTZXR0aW5ncy5hc3NldFNjYWxlKTtcblxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBYTUwgdG8gYSBzdHJpbmcgdG8gYmUgcGFzc2VkIGludG8gUGhhc2VyJ3MgbG9hZGluZyBmdW5jdGlvblxuICAgICAgICB2YXIgZm9udFhNTFN0cmluZyA9IHhtbHNlcmlhbGl6ZXIuc2VyaWFsaXplVG9TdHJpbmcoZm9udFhNTCk7XG5cbiAgICAgICAgLy8gTG9hZCB0aGUgYml0bWFwIGZvbnQgd2l0aCB0aGUgdXBkYXRlZCAuZm50IGZpbGVcbiAgICAgICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgbmVlZCB0byBsb2FkIHRoZSBlbnRpcmUgZ2lhbnQgYXRsYXMsIGFzIHdlJ3ZlIGFscmVhZHkgbG9hZGVkIGl0IGJlZm9yZS4gUGx1cyB3ZSdyZSBnb2luZyB0byBvdmVycmlkZSBpdCBhbnl3YXlzLlxuICAgICAgICAvLyBJbnN0ZWFkLCBsb2FkIGEgZHVtbXkgYXRsYXMgdG8gc3BlZWQgdXAgbG9hZGluZyB0aW1lLiBNdXN0IGJlIHRoZSBzYW1lIHNpemUsIGJ1dCBpdCdzIGp1c3QgYSBzaW5nbGUgY29sb3Igc28gaXQncyBjb21wcmVzc2VkXG4gICAgICAgIHZhciBsb2FkZXIgPSBuZXcgUGhhc2VyLkxvYWRlcih0aGlzLmdhbWUpO1xuICAgICAgICBsb2FkZXIuYml0bWFwRm9udChmb250TmFtZSwgJ2Fzc2V0cy9pbWFnZXMvJytHYW1lU2V0dGluZ3MuYXNzZXRTY2FsZSsneC9kdW1teUF0bGFzLmpwZycsIG51bGwsIGZvbnRYTUxTdHJpbmcpO1xuICAgICAgICBsb2FkZXIub25Mb2FkQ29tcGxldGUuYWRkT25jZSh0aGlzLm9uQ29tcGxldGVMb2FkRm9udCwge2N1cnJlbnRTdGF0ZTp0aGlzLCBhdGxhc05hbWU6R2FtZVNldHRpbmdzLmdhbWVBdGxhcywgZm9udE5hbWU6Zm9udE5hbWV9KTtcbiAgICAgICAgbG9hZGVyLnN0YXJ0KCk7XG4gICAgfSxcblxuICAgIG9uQ29tcGxldGVMb2FkRm9udDogZnVuY3Rpb24oKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAvLyBPdmVycmlkZSB0aGUgY2FjaGVkIGZvbnQgaW1hZ2Ugd2l0aCBvdXIgZ2lhbnQgYXRsYXMgdGhhdCBpbmNsdWRlcyB0aGUgZm9udHNcbiAgICAgICAgdmFyIGRhdGEgPSBQSVhJLkJpdG1hcFRleHQuZm9udHNbdGhpcy5mb250TmFtZV07XG4gICAgICAgIHZhciB0ZXh0dXJlID0gUElYSS5UZXh0dXJlQ2FjaGVbdGhpcy5hdGxhc05hbWVdO1xuICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGRhdGEuY2hhcnMpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmNoYXJzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5jaGFyc1twcm9wXS50ZXh0dXJlLmJhc2VUZXh0dXJlID0gYmFzZVRleHR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGVhciB0aGUgZHVtbXkgYXRsYXMgYW5kIFhNTHMgZnJvbSBtZW1vcnlcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUuZ2FtZS5jYWNoZS5yZW1vdmVJbWFnZSh0aGlzLmZvbnROYW1lKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUuZ2FtZS5jYWNoZS5yZW1vdmVYTUwodGhpcy5mb250TmFtZStcIi5mbnRcIik7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgYWxsIGZvbnRzIGhhdmUgYmVlbiBsb2FkZWRcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUubnVtRm9udHNUb0xvYWQtLTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRlLm51bUZvbnRzVG9Mb2FkIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRlLmFsbFByZWxvYWRpbmdDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhbGwgbG9hZGluZyBpcyBkb25lLCB0aGVuIG1vdmUgb250byB0aGUgZ2FtZVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUucHJlbG9hZGFuaW1hdGlvbkNvbXBsZXRlID09PSB0cnVlKXtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFN0YXRlLmZpbmlzaGVkUHJlbG9hZGluZ0FuZFByZWxvYWRlckFuaW1hdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvLyBlbmRyZWdpb25cbiAgICBmaW5pc2hlZFByZWxvYWRpbmdBbmRQcmVsb2FkZXJBbmltYXRpb246IGZ1bmN0aW9uKCl7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB0aGlzLmdhbWUuc3RhdGUuc3RhcnQoJ01lbnUnKTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB9LFxuXG4gICAgLy8gcmVnaW9uID09PT09PT09PT09PT09PT09PT09PT09PT0gU3dpZmZ5IEFuaW1hdGlvbiA9PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgZ2V0U3dpZmZ5RGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIGRhdGEgPSBcIlwiO1xuICAgICAgICAvKlxuICAgICAgICAvLyBSZW1vdmVkIHNvdW5kcyBmcm9tIHRoZSBhbmltYXRpb25cbiAgICAgICAgaWYgKCFXZWJVdGlscy5pc0lPUygpICYmICFXZWJVdGlscy5pc0FuZHJvaWQoKSkge1xuICAgICAgICAgICAgdmFyIGJyb3dzZXJOYW1lID0gV2ViVXRpbHMuZ2V0QnJvd3Nlck5hbWUoKTtcbiAgICAgICAgICAgIGlmICgobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdHZWNrbycpID4gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdLSFRNTCcpID09PSAtMSAmJiBicm93c2VyTmFtZSAhPT0gXCJtc2llXCIpXG4gICAgICAgICAgICAgICAgfHwgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cub3BlcmEpID09PSAnW29iamVjdCBPcGVyYV0nKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBcImRhdGE6YXVkaW8vb2dnO2Jhc2U2NCxUMmRuVXdBQ0FBQUFBQUFBQUFETnZiWDlBQUFBQUFaNmVBb0JIZ0YyYjNKaWFYTUFBQUFBQWtTc0FBRC8vLy8vQVBRQkFQLy8vLys0QVU5bloxTUFBQUFBQUFBQUFBQUF6YjIxL1FFQUFBQUoxVkx5RWpULy8vLy8vLy8vLy8vLy8vLy8vLy8vUEFOMmIzSmlhWE1NQUFBQVRHRjJaalUxTGpBdU1UQXdBUUFBQUJRQUFBQmxibU52WkdWeVBVeGhkbVkxTlM0d0xqRXdNQUVGZG05eVltbHpLVUpEVmdFQUNBQUFnQ0pNR01TQTBKQlZBQUFRQUFDZ3JEZVdlOGk5OTk1N2dhaEhGSHVJdmZmZWUrT3NSOUI2aUxuMzNudnV2YWNhZTh1OTk5NXpJRFJrRlFBQUJBQ0FLUWlhY3VCQzZyMzNIaG5tRVZFYUtzZTk5eDRaaFlrd2xCbUZQWlhhV3VzaGs5eEM2ajNuSGdnTldRVUFBQUlBUUFnaGhCUlNTQ0dGRkZKSUlZVVVVa2dwcFpoaWlpbW1tR0xLS2FjY2M4d3h4eUNERGpyb3BKTlFRZ2twcEZCS0txbWtsRkpLTGRaYWMrNjlCOTF6NzBINElJUVFRZ2doaEJCQ0NDR0VFRUlJUWtOV0FRQWdBQUFFUWdnaFpCQkNDQ0dFRkZKSUlhYVlZc29wcDREUWtGVUFBQ0FBZ0FBQUFBQkprUlRMc1J6TjBSek44UnpQRVNWUkVpWFJNaTNUVWpWVE16MVZWRVhWVkZWWFZWMWRkMjNWZG0zVmxtM1hWbTNWZG0zVlZtMVp0bTNidG0zYnRtM2J0bTNidG0zYnRtMGdOR1FWQUNBQkFLQWpPWklqS1pJaUtaTGpPSklFaElhc0FnQmtBQUFFQUtBb2l1TTRqdVJJamlWcGttWjVsbWVKbXFpWm11aXBuZ3FFaHF3Q0FBQUJBQVFBQUFBQUFPQjRpdWQ0am1kNWt1ZDRqbWQ1bXFkcG1xWnBtcVpwbXFacG1xWnBtcVpwbXFacG1xWnBtcVpwbXFacG1xWnBtcVpwbXFacG1xWnBtcVpwUUdqSUtnQkFBZ0JBeDNFY3gzRWN4M0VjUjNJa0J3Z05XUVVBeUFBQUNBQkFVaVRIY2l4SGN6VEhjenhIZEVUSGRFekpsRlRKdFZ3TENBMVpCUUFBQWdBSUFBQUFBQUJBRXl4RlV6ekhrenpQRXpYUDB6VE5FMDFSTkUzVE5FM1RORTNUTkUzVE5FM1RORTNUTkUzVE5FM1RORTNUTkUzVE5FM1RORTNUTkUxVEZJSFFrRlVBQUFRQUFDR2RacFpxZ0FnemtHRWdOR1FWQUlBQUFBQVlvUWhEREFnTldRVUFBQVFBQUlpaDVDQ2EwSnJ6elRrT211V2dxUlNiMDhHSlZKc251YW1ZbTNQT09lZWNiTTRaNDV4enppbkttY1dnbWRDYWM4NUpESnFsb0puUW1uUE9lUktiQjYycDBwcHp6aG5ubkE3R0dXR2NjODVwMHBvSHFkbFltM1BPV2RDYTVxaTVGSnR6em9tVW15ZTF1VlNiYzg0NTU1eHp6am5ubkhQT3FWNmN6c0U1NFp4enpvbmFtMnU1Q1YyY2M4NzVaSnp1elFuaG5IUE9PZWVjYzg0NTU1eHp6Z2xDUTFZQkFFQUFBQVJoMkJqR25ZSWdmWTRHWWhRaHBpR1RIblNQRHBPZ01jZ3BwQjZOamtaS3FZTlFVaGtucFhTQzBKQlZBQUFnQUFDRUVGSklJWVVVVWtnaGhSUlNTQ0dHR0dLSUlhZWNjZ29xcUtTU2lpcktLTFBNTXNzc3M4d3l5NnpEempycnNNTVFRd3d4dE5KS0xEWFZWbU9OdGVhZWM2NDVTR3VsdGRaYUs2V1VVa29wcFNBMFpCVUFBQUlBUUNCa2tFRUdHWVVVVWtnaGhwaHl5aW1ub0lJS0NBMVpCUUFBQWdBSUFBQUE4Q1RQRVIzUkVSM1JFUjNSRVIzUkVSM1A4UnhSRWlWUkVpWFJNaTFUTXoxVlZGVlhkbTFabDNYYnQ0VmQySFhmMTMzZjE0MWZGNFpsV1pabFdaWmxXWlpsV1pabFdaWmxDVUpEVmdFQUlBQUFBRUlJSVlRVVVrZ2hoWlJpakRISG5JTk9RZ21CMEpCVkFBQWdBSUFBQUFBQVIzRVV4NUVjeVpFa1M3SWtUZElzemZJMFQvTTAwUk5GVVRSTlV4VmQwUlYxMHhabFV6WmQwelZsMDFWbDFYWmwyYlpsVzdkOVdiWjkzL2Q5My9kOTMvZDkzL2Q5MzlkMUlEUmtGUUFnQVFDZ0l6bVNJaW1TSWptTzQwaVNCSVNHckFJQVpBQUFCQUNnS0k3aU9JNGpTWklrV1pJbWVaWm5pWnFwbVo3cHFhSUtoSWFzQWdBQUFRQUVBQUFBQUFDZ2FJcW5tSXFuaUlybmlJNG9pWlpwaVpxcXVhSnN5cTdydXE3cnVxN3J1cTdydXE3cnVxN3J1cTdydXE3cnVxN3J1cTdydXE3cnVxN3J1a0JveUNvQVFBSUFRRWR5SkVkeUpFVlNKRVZ5SkFjSURWa0ZBTWdBQUFnQXdERWNRMUlreDdJc1RmTTBUL00wMFJNOTBUTTlWWFJGRndnTldRVUFBQUlBQ0FBQUFBQUF3SkFNUzdFY3pkRWtVVkl0MVZJMTFWSXRWVlE5VlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlYxVFJOMHpTQjBKQ1ZBQUFaQUFERHRPVFNjcytOb0VncVI3WFdrbEhsSk1VY0dvcWdnbFp6RFJVMGlFbUxJV0lLSVNZeGxnNDZwcHpVR2xNcEdYTlVjMndoVkloSkRUcW1VaWtHTFFoQ1ExWUlBS0VaQUE3SEFTVExBaVJMQXdBQUFBQUFBQUJKMHdETjh3REw4d0FBQUFBQUFBQkEwalRBOGpSQTh6d0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUNSTkF6VFBBelRQQXdBQUFBQUFBQUROOHdCUEZBRlBGQUVBQUFBQUFBREE4anpBRXozQUUwVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJ4TkF6VFBBelRQQXdBQUFBQUFBQURMOHdCUEZBSFBFd0VBQUFBQUFBQkE4enpBRTBYQUUwVUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBQkRnQUFBUlpDb1NFckFvQTRBUUNISkVHU0lFblFOSUJrV2RBMGFCcE1FeUJaRmpRTm1nYlRCQUFBQUFBQUFBQUFBRUR5TkdnYU5BMmlDSkEwRDVvR1RZTW9BZ0FBQUFBQUFBQUFBQ0JwR2pRTm1nWlJCRWlhQmsyRHBrRVVBUUFBQUFBQUFBQUFBTkJNRTZJSVVZUnBBanpUaENoQ0ZHR2FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUlBQUFJQUJCd0NBQUJQS1FLRWhLd0tBT0FFQWg2SllGZ0FBT0pKaldRQUE0RGlTWlFFQWdHVlpvZ2dBQUphbGlTSUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFnQUFBZ0FFSEFJQUFFOHBBb1NFckFZQW9BQUNIb2xnV2NCekxBbzVqV1VDU0xBdGdXUUROQTJnYVFCUUJnQUFBZ0FJSEFJQUFHelFsRmdjb05HUWxBQkFGQU9CUUZNdlNORkhrT0phbGFhTElrU3hMMDBTUlpXbWE1NWttTk0zelRCR2k1M21tQ2MvelBOT0VhWXFpcWdKUk5FMEJBQUFGRGdBQUFUWm9TaXdPVUdqSVNnQWdKQURBNFRpVzVYbWk2SG1pYUpxcXluRXN5L05FVVJSTlUxVlZsZU5vbHVlSm9paWFwcXFxS3N2U05NOFRSVkUwVFZWVlhXaWE1NG1pS0pxbXFyb3VQTS96UkZFVVRWTlZYUmVlNTNtaUtJcW1xYXF1QzFFVVJkTTBUVlZWVmRjRm9taWFwcW1xcXVxNlFCUkYwelJWVlZWZEY0aWlLSnFtcXFxdTZ3TFRORTFWVlZYWGxWMkFhYXFxcXJxdTZ3SlVWVlZkMTNWbEdhQ3FxdXE2cml2TEFOZDFYZGVWWlZrRzRMcXU2OHF5TEFBQTRNQUJBQ0RBQ0RySnFMSUlHMDI0OEFBVUdySWlBSWdDQUFDTVlVb3hwUXhqRWtJS29XRk1Ra2doWkZKU0tpbWxDa0lxSlpWU1FVaWxwRkl5U2kybGxsSUZJWldTU3FrZ3BGSlNLUVVBZ0IwNEFJQWRXQWlGaHF3RUFQSUFBQWhqbEdLTU1lY2tRa294NXB4ekVpR2xHSFBPT2FrVVk4NDU1NXlVa2pIbm5ITk9TdW1ZYzg0NUo2Vmt6RG5ubkpOU091ZWNjODVKS2FWMHpqbm5wSlJTUXVnY2RGSktLWjF6RGtJQkFFQUZEZ0FBQVRhS2JFNHdFbFJveUVvQUlCVUF3T0E0bHFWcG5pZUtwbWxKa3FaNW51ZUpwcXBxa3FScG5pZUtwcW1xUE0velJGRVVUVk5WZVo3bmlhSW9tcWFxY2wxUkZFWFRORTFWSmN1aWFJcW1xYXFxQzlNMFRkTlVWZGVGYVpxbWFhcXE2OEsyVlZWVlhkZDFZZHVxcXFxdTY4ckFkVjNYZFdVWnlLN3J1cTRzQ3dBQVQzQUFBQ3F3WVhXRWs2S3h3RUpEVmdJQUdRQUFoREVJS1lRUVVzZ2dwQkJDU0NtRmtBQUFnQUVIQUlBQUU4cEFvU0VyQVlCVUFBQ0FFR3V0dGRaYWF3MWoxbHBycmJYV0V1ZXN0ZFphYTYyMTFscHJyYlhXV211dHRkWmFhNjIxMWxwcnJiWFdXbXV0dGRaYWE2MjExbHBycmJYV1dtdXR0ZFphYTYyMTFscHJyYlhXV211dHRkWmFhNjIxMWxwcnJiWFdXbXV0dGRaYWE2MjExbHBycmJWV0FDQjJoUVBBVG9RTnF5T2NGSTBGRmhxeUVnQUlCd0FBakVHSU1lZ2tsRkpLaFJCajBFbElwYlVZSzRRWWcxQktTcTIxbUR6bkhJUlNXbW90eHVRNTV5Q2sxRnFNTVNiWFFrZ3BwWlppaTdHNEZrSXFLYlhXWXF6SkdKVlNhaTIyR0d2dHhhaVVTa3N4eGhock1NYm0xRnFNTWRaYWl6RTZ0eEpMakRIR1dvUVJ4c1VXWTZ5MTF5S01FYkxGMGxxdHRRWmpqTEc1dGRocXpia1lJNHl1TGJWV2E4MEZBSmc4T0FCQUpkZzR3MHJTV2VGb2NLRWhLd0dBM0FBQUFpR2xHR1BNT2VlY2N3NUNDS2xTakRubkhJUVFRZ2lobEZKU3BSaHp6amtJSVlSUVFpbWxwSXd4NWh5RUVFSUlwWlJTU21rcFpjdzVDQ0dFVUVvcHBaVFNVdXVjY3hCQ0NLV1VVa29wSmFYVU9lY2doRkJLS2FXVVVrcEtMWVFRUWlpaGxGSktLYVdVbEZKS0lZUlFTaW1sbEZKS0thbWxsRUlJcFpSU1NpbWxsRkpTU2ltRkVFSXBwWlJTU2ltbHBKUmFLNldVVWtvcHBaUlNTa2t0dFpSU0tLV1VVa29wcFpTU1drb3BwVkpLS2FXVVVrb3BKYVhVVWtxbGxGSktLYVdVVWtwTHFhV1VTaW1sbEZKS0thV1VsRkpLS2FWVVNpbWxsRkpLS1NtbDFGcEtLYVdVU2ltbGxGSmFheW1sbGxJcXBaUlNTaW1sdE5SYWF5MjFsRW9wcFpSU1NtbXR0WlJTU2ltVlVrb3BwWlJTQUFEUWdRTUFRSUFSbFJaaXB4bFhIb0VqQ2hrbW9FSkRWZ0lBWkFBQURLT1VVa2t0UllJaXBSaWtsa0lsRlhOUVVvb29jdzVTcktsQ3ppRG1KSldLTVlTVWcxUXlCNVZTekVFS0lXVk1LUWF0bFJnNnhwaWptR29xb1dNTUFBQUFRUUFBZ1pBSkJBcWd3RUFHQUJ3Z0pFZ0JBSVVGaGc0UklrQ01BZ1BqNHRJR0FDQUlrUmtpRWJFWUpDWlVBMFhGZEFDd3VNQ1FEd0FaR2h0cEZ4ZlFaWUFMdXJqclFBaEJDRUlRaXdNb0lBRUhKOXp3eEJ1ZWNJTVRkSXBLSFFnQUFBQUFnQU1BUEFBQUpCdEFSRVEwY3h3ZEhoOGdJU0lqSkNVbUp5Z0NBQUFBQU9BR0FCOEFBRWtLRUJFUnpSeEhoOGNIU0lqSUNFbUp5UWxLQUFBZ2dBQUFBQUFBQ0NBQUFRRUJBQUFBQUlBQUFBQUFBUUZQWjJkVEFBREFyZ0FBQUFBQUFNMjl0ZjBDQUFBQXRvaEkzV0EzLzFML1BmOUsvMHYvUlA5Wi8wLy9VdjlPLzBmL1N2OUUvMHIvVHY5TS8wdi9Qdjg5LzByL1RQOU0vMGovVGY5Ry8wai9TZjlDLzFUL1RQOUcvMEQvU1A5Si8xbzZRME5RVGtOTFEwZi9PUDhpL3lUL01QOUEvMGYvUHY5Qy8wVU1DUW1BblRFYTFWQVFNMUxwZ1Vuam1BdXpWR2puWngwYzQ2cldvdjNKYmszMTY3dVlIbzV6ZUNkelhKMmZqMGo2WXJSeVErQXdPbmFNUjVKd0FBTEFIVHZHSlVvNEFBSGdQcmhQLzEzMXNEakdPcXorNHU0TDUrWnJIODV6ZklCQ1VKWFlWTVZXTXFpUnFpcEF5ZXh0WTQzeEwxNzYwdUw4dVVCU2hlZG1IUkp4dm1PakhmbVpPdnh3THY2LzhiK3ZtcnZ0d2tzOW1ybi83VjgrSDlsSkxhbThpbE9Uc0w3blhmSzU2eVZ6OXU1UDdlcThaODRVSjhnNWsyMm03eWVQdk5rUExnK3NWSGM5UCszSXJuUHA2dHowWDFWTjkxVVpqMVhuQm1OdEtodVJ4ZEJQWTZUK2ZzYXIwRmRuWjJlV1FjN2Rub1I3U0t1VldUbFZhUEtMNFpDbjNkc1U1bjJwbWJUNXBYV0w1THgwa2t6OVJNOW5ZSzZFemh4U2c2aE01bUY2cHArcDNuV3lhUkxDeXMzSWNreFlORlBpeG03R2VkQXU1Zis3TDNIRHIwY01XU1hScm02ZkhiL1J1cDdYZXRJL0RZaVFiWXd0YkY5RVd3NlI2R0NiL21YK2Jvd3I5UUo1aEVsb01aS3RkUERYdHJPTTFvNEMxN2JQU3o2cmlVYjhrRkVJQUI1MmpDWHl3UThBTCt6b3B2aEZDUlRnWHZoOG9XR3JWRGt4TE10RXFxcXFpZ0YvTVpuU2pZMmpkdkRneHpnYzNGbjk1L3ZQM1B1VnhYcm9zNVh4eU5Pakp5ZExtKy8rL3JJM1p0N3dNek9uYXdYcjRncHVkM0RWZWJwTmNOVzNaUjErZlY5N3hkRy9yeWxvUkR5R3cxTmxZSWlOcVIyTy9SRWVtNmsrMTlQd2xXYkdRTUNsVHQzVW9aMWZjR3AyMXo3NHJlV2p6bFhuek9USjU4d1BETVdCKyszc1UraVhKZzM5S0Z5ejIrOS8yeUdNTTd6VnQvSFMzODZHZ3NJMVFIeHJSTDE3bURwMzFadlRKR2Y5MFdPR1dMMUxXbi9XMmM0TWE3NGRja3htK3VUUU54NCtMNVZPc3RxUitQM2YzUkszVVl6Y1l6aFlXOXVTeUV3bFBjZUs3dFRVczdmNmwvd2I5ZzlpN2I0Y01sMHh3OXo4dE5aVytSb09pZWl5QWY2Ni9uVVhMVFgwOFYxZXBUNHpYY0dyTmY5WnROWXNNRWdqY3dDZWRpeEwrcUlJRUJZMzdkZ21kd2NFQ0I5M09RcTQ3VlhGVmxWaUdUUXlVbFZWRFBNZkIvcVVlQjhaOS9zNU95Ky9xeFozTDkrNjBvdU1YMysvSFUvLzhlSzJ3NitueTUvZm0xOStzakNTalZISk0wZGZ6WHQzSnpZR0R5K08xdFRWMytJNUtjSGxtcTkvcXZrd2Y4ajJRREZmdDBzaWNqWC9xb0xDdHpvNUpkN2RVd2xXN3FyNXZueWNMOFhnMlNNRy8renhwYzdweXZ5NGN1cXJpcTdPS3ZxZDlUZDU4NnV1TEE2QXZRK1R2T25PbkhxTXNyTnBYczNVNUxPOWJqUFQvUjhYUER2N1NGQlYzVkF6ZTBPV1hEdldUR2NXNEhPNGg4MmVvVk5MUUxzMEwrNHh6YW5HMk9uMm5KS2J1YTdRM2t5M1pCT0IrVnNnTU1KR1dJOXRMM2RGWGR0dmJseFhrSXhCQUF4VFZrcitsYnlrdDI2NFdLVktZMlNyL1o5blVHb1Y2MGRralBkNTF2NlN0VExvYkFhVHI5R3pqZlMxdU9iKzk2Y1VuM05aT011QUExQUFBdDUxZEMxeUVqOEZ3TnM2bXVSUGxFRENFSGY1clVQOUZPMWJzVlZWYktXZ2xLcXFDbzBPZXdmZmg4blgxcXRoKzBlM0VpZU9aLytIRDhaZmxyOS85THQxOGRkSEg3b3VPVDJrNTA4MjBBOGZKV1ovN0hTNWVFNGYzaTZPYXVxaE51OUxhb0hQTFJTMW4vc1B3Z3R6L0V1TzV0SEFER2NxdG5NNm15cWozQS9aNkcrN2Y2Y2gyeGRkbFUzV3Bxb3lBbzZMb3B1VFgwZW5HbzFWTlFNdDVHeDY4c3d5K2JiOWNLWktZcStLVDFPeDNYUkgzaWVwcStlWFBBRFpOZjExZHBsNklTNjYrRUNUQStjejI5TVM2OFdVWGRuZHZ3WG9NenQ3T2xmMmFlSjF4bGt6bkFOOFVlVWFHNXFUMDF4MXRvN0xQRXNCNmZ4aXhuMVY5c3pMdWtPYmljNC9HbE9PTS8rU1pEOGtFbGhJbHZnV3p0QS9nQSt4U1RPZVBJdjZaaHI5eVJNc1BZaitiSVkwNmxsOTJkM255YlZwM1BZR3JQRTVqSzgzU1B3WnBEbkZnSS9HUnpPQUg1NTJqRXY1NEFnS29lS21IY3VjUGdsSUE2RmkzMEJkM0FjOGViakM4YXlBSjZOU1ZURk1sWkdxcWlvQUhjbjd1K2oxNmFRMlhiOTQvL2k4M3ZpM1ByTFgvVHc4WFAva1BEOVptMi80WEpibDU5VGt3MW44Wlc1elpMbitidmZpT3ZJcGYzc3V1Q3I3UTlNRTlHZmZVODZUblpVNXNIMUc0NWg2K3RNOVo0YmZJWUtxeHFPejZlS2UyUy9zcFBiZnNpdXJIM0thbXF6RVY4SzAwZnk2eU4yVWFxdHk4NWVycDhGK2FySmdZMko0WVZlY0VUVkFUcy9rVE0wYnY5YjRQVHI2bzBLbHFYdHNuK1o3NFhtK0dUcUd5UGF1NmE0TjUxSHZ4T0NzNURDbjRoNUsvMmFHTk1YeGdmcURiWU5zMUl1YjB0V0xkY0l5TVJnYmNGS1NwSmVwUVJKaXM1bitKU3VHelA3b2lLcjA2N1h4bDNibElTTWZQRzJyOTk4YjM3L1BzNlZvMHNSK2VwMGVoYk1hck5wVGpIRWE4bGRuNTJyQjhkTXFuSXFpQnRBRVBuWTBVL25USUVqQTdUcTZrdDRBUWNURXZTaDhxaTdhWnhWYlZibVNocUNxS3NhQUQ5dC8xVkExM2I2NSs2ait4NnovK1UvWC9PemdyLy93TC82bk56Nk1PdWZpM3M3Yk81ZWJYTjRtMDI2L2Z2VjZ1RjVPUjdIZGRhOUwrMjg5VHM3MWRtMWZNa2Z4ZUoxNm5wZHZSM0ZsdEk3WFBBdVk3R214cEdyeVMxVm1DeUlXZjB2Mms5MVQwN3Z2NnROUFRvMEx2amlvNjcydFIwR3NvcCtCenA2YVA0L3BwdldaZXVERW5KbGVZQmxsdlFENTlJbm5ZZko2cy9NTTQvekZHZzdWTHRhdW51Mzk3dGx6M2k4NnlaOE9LMlFPZFpiYlYxRk1MM1BIVU5lY25JS2ZNN3NQVDF1a1U1TmZQWm5URFRWRGMvcmlkOWpRYjlGWkRqS1paSkFHTzA5dGV2VTF0dmZLWHpPOTdoRjk0a1ZOanF6M3JYck4yZTFvNWMvUTRzU25uYWxjbnVzWGFTdHZmcXRxSmk0K2VlK3NwNGdiOWkxYVB1bUJ2VDVYa0hhV3BDSnJUQ0Q5ZzNlZkVGR3JCRXUyYWtObzRBQWVkalN0ZkhCSW93QXY3VmhuL3dFRUNCWHZSdE5saWhwSEd2WmkyU3EycXNrWXFhcW9DZ0RBS2RjMlZ2NDJSb1lQUHczM2Q2K0JwOEc5cytPM3I5MlYvZGMvUGViRzBUM2p6b2NQUGJNWjBzdmxtMnNtOGo5c3B2R2pjWXNwNGZCL210M2NxdTcza3pzcmVoOTZpcU91MC9vbnhsOGJQYU9TWHNuTTg3TDdaTVg0ZjI5YVNOcmtyK2V0ZG4xby91Zk52dWtwNW1HZ3Jwc3prTk16MVJTbjMvNTViV3FXazJhbUxlWXozZlRock1iazMrVGpOdVlaYzBpMHBVUU1uczE3eUhNT295YjNrM05vOGd3a25Nd3ZXbGs5aDZMcFlaNk0yZXVlSTVuTGJNUEkzMVBydTl1NjZVNFB2ZWhaQng4K2lpQW5jQ09Md21KVDd3WEJINFJzaEpsSmxReDE3ZmZQZHNjOU9tTEUvOW5TVFd2UWZkWnExOW9OL1dLVnpiYmxTcFJLSlZuNSttY0huNVFMZXlGdSt5UkYyajJEcVdaaGJGNFpZVnVXK2Rxb01ySFZRL2Z5enBHRFFQQUNIbmFNTlg0QUFlQ2xIZE9jZUlUK0lCQjI0YnRRLzhiNWppM0F5RlZWeFZZcFFWR0RrYW9BT1VUOTl1eVQzU0RmZjAxVXE4bi95LytudjgzWGFWdjI2TjIvZWo1WFBITE9NOXZxWDF4KzU5cXlUczc3WTFueHg5ZGptdGZYbzUzN01IQk5YdTducnZNMkhQemdNM1ErV3lZcjdteWFuNndaT0t1bktmQmhjc1B1aGNuKzZrTU9CYVJ6M2hvNEgwUGxaT1VlNEl0VDUyUmxHWVpheXMrUWpZcERjVGZnQkxpVmlSSlh6Z0Y0cXYvRW56bzAvZWJRTUZERjBmbDlacDlEOTg3alBrbFNrZlB4ZXRqZWpITUNNMStlYkNZalZJWnZPMDNXeXpBdlovZko1S1VoNlFoM2pqbDdOenVQQ1l5RmtORHVtTG9ydnpadVkrN3dWMnIzNllyTm54R1RyVHU0eXJjNFlOc09aSXdYN0RxajN6d0lDMHRDWUd2SlRsS1pGdWZFNWFhbnRicDUvem9MTFZiamtKQUZHUHlxNjFWemFoaG9zOU1CSXMram9kWDh2dTRkMTBzN2Z2azB3NUVSQUo1MmpGTjZFd2dLNGVPbEhkTlMzZ0JCSTN5OEcvTDI4QlIvN3RnSHAwWlZzWlZzVmFLcWlpSDQ4R2cvZDdkemZUZHgyVjdkdEtmZnRzc1ZmMTB4NmRYZC8wWVBsMzNxaDMvOHVJaEhobTU3ZVhsWU9ja3hjeHpUMGZSQUZ6OGY1SFo5VkZPa0hwK1FPYVZZTlVYQnBhNjhyMUpqOVBBcFpzMlJMWWkvVGVWTDN6MGZaK2FQMDJJcW5yMnZVczNNZ25wTHJTRmZPWmJpS1I2QUpubjJiRzFHaE5sVTk0cWhmU1lwNHRuOVNsVTVYWEYyRjFCdnAyb096UzhIR2xUQU5OZHMxNURIdlA5S1ZXWVR3NnVMR2dCWFE2dmQ3MVQxSHB2cStlWEt6cWxjKytnVUhFNXhUek1BMUt6Wk0wSW1uM3plZXdZaGIzY2w2eDBzQTRpVWFhdjk2UHJGM3pkYXMvOS9EL2Zad1Mzd21YSXVkR3IvYTFkT0xuMjZDNW44TzE1bi9WM2xTMzBXL2FlcU16SHd2Y1drMDBkS1RNeE91dElWOTRtWnpMSXJkMUs5Zk1jQXNGWnBsaWdaQUo1MkxGTmloeDhnZkh4ZngxamQyd0JKQUw3YnkvRzZyOHFQb24xVVZTVW1wWXBVb3BHcVlpaEJQNnJtTUo3KzE1dTFKaDgrT3A4ZGI1ZlhWdmY2SXc4Tis3Ny95OHBiT1lsa2QvdDlOc2xHNi9Dbm1EYkQ0ZlhoY285c0h2WHQ3Nm1QcWJYbU0xM0hKL3M5YUs2VGZmcnNianhjVURuZDdTa3FwdHBzT2dsM1ZEaTZHa3BvUHVaTUl1NU43YUpqSDRvNmYxRFdHWElnZmtsUktHbjNOTm5NWkg3Nmdvdk9KMmYzY0pGOU8yR2N6SEFsY09oL1Y4OXJPbTNHa2ZYcmVBUlZkTzI2RGxxYk81UE9kMVRuNXhzMXVLd1pwdERsbkdJRnZiM0dkbnk4TCtBdER0azJNRmlnd1B5Rk1VTHlJeXhqZXlnU2pRei9YaTJxV2lpdlhxL3o0MFg4RjNYclpmUnlNZDRiYlA3MEtDbTdyYkUxalMvQ2RvRitYMEVKQUYvR01pQ3ZXQzNYbHM4UDZyWlhHanhYckdBZTZYY2p6UHhVcjZ6V3hQTWMwZ2dBQmd3QW5uWXNTK0pCL0NBUUtyNnZvNi8raDBLUWdPL3lWUEY4WHVvQ0hOZXFTcU5ZSmtXcXFxb2lvSFJUSDcrcHcycXZmLzNwdkRsNGZaWThjTmIwWVM3TkE5OXEzejg4TG4weXZtZk4zWCsvLzlGaUdOTERtNHhJemo2OWtZanl0S0xDazZ2NVhzMXNucWFieVBHK056V0hrM1Y2M24xbFZBM0owQWZxZWYvT2l2MlpKdk9UWEcvTHg3bUhvbW02Sm11cUQ3eGttcSs4c3lnNmxleko1Q2JKWG5kdER2dFE2VmhUZVZ4NVpJdjlSTzBmZ3J0K1pxalJWYlZPbHRXbmJsVVh2QVZieWV4dmZ4SnFkcEY1VFUrenEyWm51MnVaZnVZaUI2NHZ5Q1A2SGEyc2YyNzU4bmUvWDdMTytyUmgySjBGSEJ3S0F0eWM5UVpKUXJJZ01ycjNYVHU2RjQraFpyckM0S2MydnRwL3lnK3hkZkNHd2s1KzhtamZYeVhYN25mTnRHSzRML25ybTdQMDFwaG82WDVJS1F3Y3k2QzNTV3prOHQzR09xOTFCMEV3R2xMZzNHV2duUUFlZG96ZGZ3RUN3RXM3MWpGeUczNEdDQlh2ZHRTaHE1RHFBalQyVVZWc1ZhcVNSS3FxS2tCdStidHZyemZIOWovL3IrTDg1dWJ2cDZ5UDJKZi9keGV4eGVIOWI5ZWMybnpoVDcvNWJPTHE3bjliZkhzbDlaN1c4S01WYzllNXlEaDgvL2kvbWdkdzFZL09GdXhyOXQ3UkpOQVg2WE5kM01VTU01dXBIbmZYbzg2ZDVmL01rRU1XYSsrNmNvcWVBV3pZVTdtL1Zkc2pnSWFYTTVOT09pTHJ3alh6Q1pNc2d1cFpLN09iUFhWVlVRazZQRVZWMHBQM1NmYzExZFBaMlFEblRWejc2cjBadkhjMTVtbHFPQmc0UGZwRGp2WU9xS3BrZUVsRDZxdnBlcU1xRUM1M1VqWGRwUnIrMUpHUkxVbTZaY1lya2RIZnYzdWQyTWxVWGZKa3laS0ZEU0Jmc1MxdTlXTzR3YTJUOHAvbHp3c3gvZTVlaGp4YnZqNzhzc2dQWnc4dk9QOGl1elZoMmFLNGs3elFRM2kyS3JXMDZRcU9RYzY1aytDZ2dXVUFHcDUyTEZONkF3UUlIemZ0V0NmL1FVQVFDQlhmRFMvWHkvRXZjRjJqQUtPcWNtSVp0b3hVVlltS2dSSk4vd3dzdCtPRTVyWmJtdmFTTkxWb3NkU2YwN2UvdEpmL3B1THo3Y2REUHNnM2p6eU1IM3RWUE5DdmxrZUw2WlI3SGI1TzBINTczSTlEN2ZQSFdFSC95Y09Cc20rWkpNNFI0NW1UUFJzOC9kRVp0cUhxMlR6U2t6T1o4VjJsbytueWlkSk5rbjE1SFA2SDNmSHVTc3F3NE54a3ZUaUhMbWlTWGp4UUxxKzFEcWpmYXgyMTZNeCtaM1ozVnVIdUQ5TnptVi9lM25yem9WczVERHQ1ck1vcVZLdlVadCtreHFNc3gzTVhRK3FYdHJOdFdnY21uWDV6MmxTRGdiTlo1eWxxazdJbDM4S1lTUEtydTNURDk5KzNlVUFXWUtnTUJ2dTVYUFVsdzJ5SCsxTzE2dFptTDVieFo2Wnc4VzdIMy92U245UlBWaW5NMDlla3ZzNXNORmZ0bTNyWExocmxjTnZiSXc5aEppSmJnOVczcTN1dGlUcmtNUWFrVldnQW5uYXNZK1JWL1FCQ0hmSFNqbTEybnh3SUVCYnZobHFoQXhxSHhqNnFxcXFxR0ZRdFZWVXhlTzlPM3UrSDdxM2ZsODMvZm43K1B6OWNQZ3h2ODlUdXNaN0dxck5HVGxjaVhjL0x5YmdjdFdCcytqZ2o0MFBPZDYvdngwVnRuajZQYzN0SmtPdGpEVi96MlM5VXBaeHozbXFLeksvTnhOcWRVWksrdDM0VUdYUFhqb3Q2anVZNG00c1MxWno5NVA0NDEweHVQOXM5azlYTitBdE5Nbm1kRzE2ZzFCTlAzS2ZwbWpvdlZHK293eXhJcWtJVW00RzNabmJVRFUxVDQ3NExTTWhTVnFOaWt0UEFxWVkzU3FwSnp0eUNTYnI3QWErVktMdGdHdnJVeS9Ua3hNek9tNm5Kbm5HMTdwOWYzM1JBN1ZMS1NIazI2Tk1CWUxBbDRnOWdyZDJxODJyUlJqci95djFESzVoa2ZPanB6SURCZkJtRGhTVmttNzl0SWJZYWQ5cGpmN0FVL3hEZFJ6NVdsclZCMklWcDNVUDFQYVRPNTJHOHh5WFd5cGgyZ3c1ZjBZRkI0RUJhQkljekhuYjBZK0pCZndCNFgwZmR5Z2VIb0FEM3huL0lnOGR2RHpWRlNyWmlxNnBTSmNaSVZWVVZBejVNd3VPUDdmMzRvOWsvSnp2OCsyOC92dGtiWDh0MFFsRldhaGYvZHorVloxLzBtODNJL3g1a2p2ejNmbDNPMTh0Mzlldi9pTUs4dXQ5WjM2M3I2NzgvYncrblRqOUppWHVQUysrVjgyTjBGRHE5TzVtZlhMbEMvYU05N3MzWFpIUkQ3VTZ5RDl2MzU5d2szdEIySGJaSDgrejI1OERzVTV5QnBMbys5VlN6b1haMXdwemVyOTcrcXBxRm5PcnVKc0ZyMjMybTZPYXVtVUYwYjVKYWVEbW41dWNmWXZvcndiazV1SE4rbnRiYldXWTNGTlh0RjJaeVozTEhvaVlYVHVkSmd4OFZPL2xXZ3BReWNaL0Z1L2wxdVpRYmpBQUUwbS9uL0pYdjVlKzNkQkZkcVB6UFllbDJld3pGMHAzWSsrc1IrMTFxQitOVzBiOVo2a2h2dE42MUdUWCtFSkg5SEhaY0VRdWp0Q0s2NDh5eWxRZHNjM09IdXJDbGdxcEZOaEFpQUo1MlRITzY0eEFFUWlXNlcwY1RJenY4V0VDWmQxTndmQXlIZnVGQ0FVYXRsVm0ybUNpb3Fxb0tBSXQvQiszMmZycnA4Mk43TGJxeVRjNjd1ZFdSL3UvOVl1LzFFdWZ3Smoydk4vWWZmeTUrKzI3WitpY2RGbmtubHg0WDhXUzdXTlNzUExZWHg4eldJeDdSK2VjVXVVZUYreEFUaWE4ZWo0ODNkZFptTjBXbEo4ZEY2ZEorN1JRTyt4dytURmZOVEIxRytiYitzNTM1bzV0K296ck5USnhYWmFTMStEWlpiSEtQcGs3L3FHQXQraGxXYi9MMTBCNGJtNDN5ZnBnVWRGMzhDZmY1YkUxQ3ZiQ2grYm1oWDk3eFRNNWtRN0hNaWNpZXJNcWNONThQN1dwMjArTzVjZnpsbEc0UHVZZjQxSUdybVAya01rOHJuVHM4M1RIcFNtZW1GVlBjc2xkL0QzKy9RMlRxekh6NmlyMjVveEUyRTU4eUhQMUlmR2Myc2twbldiNGFwK2IzVE5mUDRaUE1zUGZVSC9wejVXUE5mMXFXdGhHV0xoMXhkak9EcUZVWDBBd09NcDUyTEdQOEFBS0VqeHQyTksxOFVBaGc0ZDRvVnM2anF3TFlxNHF0VkN5YlZGVlZGVU1oOU1QOFNOLzVjcnlkZmhvUDlwWk5yLzhiLzg5N1o5ZXp0YWlxTDVjaWZ6Mnh2UHl2NzJ6N3hqM2M4T1k0L2ZCczd1VXJaVnViWGNzT2s0cWIwNXhDYjliQTlOTk9zdi9NMWVxT3E0YmFpVi9vekozTlBVeFVDSjhhaW9FaHU4bEtZRjZHVys5NTM5SHVPcnM0KzVyZTJmUTdYMWtmVHMxOWkwNmFtb0lMWU9aSFQ1UkRaanZPbVZHWTZxVER1WUczNjFCOVRYTjRTUVNaUlNaSkVRL0dPbmxxZEZYbkFQUDliNFhTalZFOUtycVpyMHdYYm1ySkdhNkN1bmRQcHl6ektYaGVOUWFmZXZEaVd2azVxUTFwZW44bUVybkhWY1Y5aGU2eHUzSDlsZDJ6MnNWVXRtWTR2N2pKV0VMemJ3NStSamh0K3dxeFZrUUxLK21ZbFhaZGplUm1zdjlUOUVKL00zYm9EZW8xOVk5MkpFUGtIQTBxbm5hTVMrRkJmekFKZGVKOUhWMkt2UGdQQUcvcHFnTDJVYU1xc1N5YlZGVlZGY043ekdIMjM5UmZ5K0RqcWVYMXRtcHB2VkZiaTNYL1l0SHNYYTZZUG4vOTBHSE9TdXZkOFMzai9lY0g1d2NaK2l2M21QSThiWTVyM2ZRdmNaL3I2bk5Scmp1N3lSNzJxYnk3TmJBcy9MMHVROEZWT0tuYzAyS1d2STQ1NXpocit6bEduaWVIY1dVTjFPV2lHQmY3elY4K2VhTzdtOU85bzd2U1UreGNQMU5weEdmSmdITnk5ME55cWZFdyt4VFRYOW1KRG5kVVAwd2ZnNS9uYkpHWE9pL2NWQzU2d09uODFTQnFheGZ0dmV0TzZGSC8xUElCV3JxdDJSclRWNTNNdW5iT1ZMMU1aa0dGSStRazZYM1RxbG1wV0RlZlh4YXRUUlAvWnJrNTl5LzlYYWF5ai9BdDd2Y0dzejh5MWZkSURlVDdpaTZUWHNlOUp0ZVhPeEdvZjg3OTlDRFVHTkp2TzNkRVhlRzBkU00xSWVjS3REVGdET0F3S0o1MnJHTzhBd1FJRlRmc1dLcDdoMFRhS21MQXZXQ2Z5cTJxcXFvU20xU05WRlV4OUNqUDI4Z2FabjRYTjdPM2J2NzlwZkZRK3ZDYlpBdytmUE1EOXRkeWZNN1RPYm0zTzR6ZnZseEpON20vN2YxZmUvNExidmJWZnVvYk5SV0xlNTJ1cXVuRk5VbDc4ak83c3BvaUdsRU1IL2puL3VlZFRsZDJEOHhVY2gxNGRTdVpIT2pwSW1ZbStURDNIYWQvVzBTdXBCcW9oSTd3U1Z5cW5Ka2EvOG1hZGViWERFbm5ZYnFZU1Q0QVgrMGxMejJuazM3SFlFN0M3NTJUV1RQTVU2MHYzOGxtSnFyMzZuS3l1NU9CK0lCRy9aZUtwdTM5ZGREOFp0ZFJYVXdsQXlTVnhZSGNlK0FVWEdBSk1qZkp6UG9iTjNOL2R1dS85bU0vdzNOazl5LzVlL3VWVEU5Y21QeWxQUmRkN2U1YVZaMlFnTEFsMzhnVytxU2l5OTR5bGpIMWZMeCtUaXl0akZ3d3BDSWhrcXo5cnI3dlE5WkxwM2NONTg0ekpyQVI5UTA2UzVnT2tNY0EzblhVUGQ1eEJBVzRYVWZkRWd0K0FIZzMvbXBJamVPeGVkZythckpzVHNVa2pWUlZGV01nY3FldkdwcVNFeS9PLzFzbXU4UEJxMjdwdlA4L1llVkhEOTdmWHQ5Y1ovcFhwcnZmTEU3OUZpUDlhWlZlK2ovZiszbzU3NFplaHNiS2NKeHIrNncvOVRoejhpVmZtczFjNU41Uko5dUNuam1jZ3BuNGVTZDlhR3A2cHRxWXQ3VlcxUnBjbjdrOGZMc0djaTFPL3Q1L3MxdC96N01TdXF1SE9iODU3RWZEYWRyYjF0bzE2czE0ekJiUDdtd1gxVjNjMHcyc1d0OFhIaVJ3L1BYcnRhdFo5OHk0MVdOdmw0QTVPZE5Gbk5CZG1RVm9OTTl5YUIrL2RUd2FlK2VZdFZRdlpvOTR6b0VzQ3ByT2FuaHk2Y0o0NjU3OVJNWkhibncrQzZVYjFrcXZzYkJ0WS92VnE1K1p0QnY5TkZNdVJuT2UrN2ZvLzNjUzBWN3EzK3hNRW5rT1NudmlEUmtyYTVqRU1JbkNOaCt4VHU2Y2I4SjllaVgvLzFKZTgyZTJMbGZhR2h3NEFKNTI5SFA5VWhBZ1ZOeTBZK3J4Z3lJb2hEL2lMazJKZ3IycXFtb3cxVlJWVlZVTTM1OVA4L09uM2ZYVTRlSFE0V3IxMmlITnZ4cDUrNlYrTWZmWWgxNys4MmtmR09yenc2MVI0NXVMcTRyREI3ZHJMM3Q3bE1pOEtWOVpyNCtLTzJzb3Z6MTF6cTRpZStnVlFkOTU0ZWt0WmQzRlRLdjNKTjJjeXU2NWx1bWlEakNsUFp1NTl6VlFYK2d3K1NaWG5ydXY0WUl6VTNrLzNYWE83SnljVlRIbjZqZHo2K29aVHRhZG0xVlZTWUtMUDBmaS9jNUxGY3c3blZYQXJDcjlPNVYzam1LMldpYS9xamxadS9wbFpjYU9qdjh2WXVSUUxLSkRrYlc2ZCtiTWRBNDlXYStteVBFeG5IQ2U1TG5lc3gyVlNVaFNaTDZ2OXErOTEzUFN2eHN6K1pyL2Q0dE53MExhVGY3SGRCYWwva2RUUS9QeWlQMDFIRkd0SE1zUDFrWnBVTlBmbG1iaGZ3bnV6Snp4Wmcyc1VSYlN2dVErenQvTEY4SFZkbGk3ampsZlNlY0RnZzhhTGdQZWRaUXRQVGlrVUlDWGRxeHovQUFFQ0JWM3YrNm5BcXcxcXFxWVNwR3FxcW9ZenViMlBtNXNjOGNQazM0ZldZYVF1SDd1UCs0c3QwOFB6ZGZQNnZuYi8vbm8zblAvODlLamU0aytXT1EvTWoyWWhqbUdtZGR4ZmNydnZ6cDgvWlNPT0d6UE1VK3B6enZEcXQ1c2F0UTdhNms4cnNKbnQraTh5UmdtWjVQUk0yc09GdlVnLzZJamxVcXlCNklxRGRNRlpWWG5KTC9xL2tOTkowVmpCbDlpeVNRcHozUmx6bVRXdXNrNk1DZG5EcG0xdTM5REZnY3VTaDdPeTUrb0ozZVpJY20zY2ZYZ29XYW1yNW1oMytYSXk5bGhoTFhWOWVyTXJFbC9RWjJtNm1UdFNqRWs4K3Z1Sk5rRG90NXpPcWs4SVRPd2tXMXNTeEZXcFRNejFqSlBlV3ZzNGM3cnptZm9ldXU2cWU4UU82cFZMeE5kbWphRGlCbUtEaGVSOWU2MlJyMlowaER0L2JRZmVVS05KamVGenZySW5ueTEwcWl1Mm1Vdk1IcTA3S0NEb0FnQjRKYmVkVFFwM1FFQ3dBMDcrbGE0NFFjSmVEZU9KOFI5d0ZOWk9kZEY3eEdqaXExS3haYWxxTVEycUJpQThXUVNCaFBtam03dmR0Zit2RjFzM0J6dTlQNzl6RDdVUFV3ZDhHbThYYmE5Z2FUd3I5enZ1NmYycC9Pck9IbjhPTmkyK3pyV055dVN1YkllOVRKWmJ1MzVmT095Vk9STzRCRlVKcVpyVnhhSDhYeVBHZ0NmOGo2ZGZYMkpncXJrNUNmTytzeStRSTE0Vm9Tc08wK1NjR1puelFFVzVzbGhkU1hnbVdUWHhYMW1vSUdHTHJoSGsxV055STk3OG9qeG9icitQYzJyWjcxQkd2Ym4zSnM3SWFuclJNd1ZuUjRZUHRRbTNzK1Jmdi9ISzR4WnFEb0oyVXlTekFkU25aeHN3WU9GQVlIVWtmeldXOGMrQXRub0FyQU1BRmhZL0V3di9BMHFiL0h4UmJxek5HMjBlMjVYWER4R0VOa2drS1ArVDNZU2tTb2R6UFlycHFhbis1MGNTV2xhOEdaQVlHUk0xM0xmdHgzRmRGeDhoTXBHSUtockJwUDFKMm9BR2swVkJ4NTJqQzErQUFMQUhUdTZsaVJFSVdqQXZkRGcya2NWcDBZeGlTRWFWRlZWb09SU3JhZHVyeHc1YnB3Yi8vWDA1dFQvZnZPZC8vWXZKQzlWSTlOeThlenA2L3JaZmMvLytUQ2Rmcy94bFhndll6SSsrdFlYNlU0OGhldVk3U3MvajBkNTlQRzZtZWxUbjJUb3FaN3UzRU1wazQ3dnZCNU9VNVZiWjNmWDE4Nzg4eU9aTFBKOFp4YzA1d0ZselZ5ZHh0R04vS25MNUtWSndXU3RmVGdIaUpvcU5nRFEyWk9uZVFiUEhIL1N5VnFWbDBXeTNjMHB1QWNPYXFnNW1RbkRTdFltYS84T1AzZmxUTlhqdkduc0ViMWFuRDk2aDh0WFJFRm5RdWJEM3A0dFJpcGhwTkc4bWV0QWVCRzQyeGRyVlJGbmZuMzErMzJrN3p0aVBtN09WY1ZzbEVKNnp1cWVPejc4OU0zZFlLaXo3ZmQ5VW1WNytSZDNNcHVMWHQ4YmRxRXBPMi82d3M1c1czY3FKb3RFYjQ0K2lVbFlFTFBuMzhrVFB0T3h3bUdnQW1wQUNBQ2Vka3hMZXFNUU5DS2N1R0hIV1B4WGdqUUE5K0x3d3JPOE92aUJVVldKSFpVWTFhQ3FxdUR4dlkrbkt6NytmdExqZDd2ejkrYTNiUmVzL1RkcGZwQnV4WGcxZi9iMU9hdlhkV3JFMDRmK2UrWHU4L2pPbS9PeWVMcU03YjNwdW1UQjMxZXQrbmV0L1hNbE0vdXByVG9EcTUxSnhyT2hKdG1iY3pienkvY3ljK1ZtTytFd3RUYy84cTJlT2JPL3VBYTVraDQ2ejcrYjdCWlF2UG4yTzkxazA1bHMwK1l0S25PS1kzanozbUsvdnU1OTkvWmFzUVh6YXhnR1l4YkR3RnRSOERYUS9lUlgwTHd6d0hCUDVxazhQYlJ5QnZoNjhXdWdxdDFWVXk5VVpZNDJ4cmM2bjUwYmgreXZweG42WTVOTTBvdEtyZFNVTFkvdXhaVDVHamJyb2E1RmJTV0xxNnVKekliNjhkYVNIV0pHSDcvVGRjM09ZL2p1Nm56N1dpUTlScjBudHJQMDdKWEdYZEdHR2FXTWQ5RUppWDdlMGk0VjhBWjRzblRCaEdDQU9nSGdpQUllZG5ROWZRRUN3QTA3K2g0L0JBSWd1RGVlYzhaZHBIQjBkNml3VlZWVkZWT3NVYVNxcWdnTVFodFVISzVQYit5UHAwK1h2ZkNieXUvTnY3Ly9hczY5bmY4MXI0eTN1YnI0OVVTZi90ZktNOGx2UHdadHYvTFgxOWY2OS9XeDV1dmw1blRsUC9mYWM5SEYrLy9rN0gxcDZHMGJvTVhrOUxtS3JGMkZORlY3Y2g2cThtdHFSRkhRVFRPek9YTnpHMjdNdGcvVHhYRmZTVlVkazhDUVJhOW5xbUN5T3JuWTlHbjhsVlRUZjI1SXFpdlZGZGRVWGdkMjFVeC9mem1RekJUVEg1UkZSSk5ib2d0bUJ1OWJwZnBkWEhMU1gyZzF6bFNMeUdSRG1wb0xNVWtuZFZDcDBhbzdQUlIxQzhreXduajlWaS8vZHArZlZ3aURzSkRReXMyRE1lZ0JaRm5HNGlNKyt0dU9KSkpxMCs3Y1RsN3dsM0tmYi90VzhYN3NYcm0yM3ZBdm4xVkh5NWovU1ovZWN1b1NxL1ZyaVMxMVVnT3JldUQzYlpoY00xeXJCQmNnMHdvQW5uWXNTN3huRUFPRWlwdDExQ1ZlQUFIZzNteWpuRS84QlpUMlVabXRZbGsycWFxcUtnWkE0dGVKVS9jY1Y0dU90NjJyNVc3d0wvL3EzZDlwLy9qK09tSHoyWW9QcC84eTd4MG0rMSswTDQ2NHpISHY1TlczNDhkUnJYSlQwM2grV1h4bW5lYnMyVjlVLy9SVFZxSCt5cTZaWWhEbllkN2EwNWpFVlpxY0ZNV1FwQWlmT3VHRU9wZ2ozNmp2V3AvcCs3TnU3dmtOYzBnS3dQczhXY0NCSzhuK3M3azdwMEZrclgxVndWWE1ERTZLTG5nZ29WRXFaKzEvUjA4UG9LRXovMWNOcDhTZnI0L3MzTm05MGk1cWhxeDYwa09aWUxKT01Lcm8wREc5OTlkaHN2ZS95QnpPdERwNGtXV3U4TnM5ZmFzWDQ5MmYwcHhKRHo0YXd2cG44T0IvL0l2a2x0TFlXNjZIMytkR0pTeXVydlNOKzhXTlR5YW10R2ZnbWtkYWZKRVpIeU1EUnVQaVV1dHVxYWUyNDFzbEVqK0hHdGFXQ0VySUFaeHJHQUVBSG5aMFBYMElDQUMzNitoNnZBTUVnSHVqNkhPT0h0NnIrcXQ5VmxWVnNaVlVvaXBSUlVEV3hkV3B6NCtiOVAranc5bmYydS9EMmZEYjdXKzdhV1V2c1hGakxodVdwMnkrK2p5TzYvZnFXNDdtVjZmMnFsOHU3eDNkOTIwczVmS3pmZm1ndVRiaTZGL3YrL0NYKzJVZ2g4WGlmcC9wbW4wUlQxTnZVNmN1RHREZGZGVjcrcGVWekxEelpsZzBUSGZSQU5YYVVCVWRCbENYWi9hTzRidzY4M3IvNzY0aGFldzVkYlV6U1JpbU5qUFQxZW0zVks0cmgzLzJEODd6VDNvUHUvYlQrMjAvZy8xb0t1dlFuYTNwdWI0czI5bFlwUzhQTXAyYkk2cXlpOE8vYTRXWGZUeFFDMzNOVXdjeU5VMWxqNkxwUGFrektibEpDSjlMOUhjbkVOODNOTnJuL3NmRy9QTHZoWHJzNS9WbncreVhLLzlFeXVtbFV2OFgxYXAxVjZ4dlpualhwU2NydE1yZmdPOTZNalkrbGJ6WTM2ck0vbVZyMExzQkRHWnBqY2VYYXVRcUZOa2ZjcFRiY1FJR01BQUlubllzYy9rQUJBZ1ZOK3pvV3VIQmY1Q0FkMk91bzRKQ1NUSHZmWXhLeFZaS2lVU1JvcXFxQVBpOWU4TjhPN3Q2OW5Edy9lYnZic1kydC9Kb09XdHU3RjlPbnRvM2MyLzJMTDVpMzlWbnkwcWVEdFBKS1krdm41VGNUN1dkSEgxVUVON1hORTJlZjJlZHpEM0VWYlhSdUpsaGZjL3c4Y0RsWGxPWmh4RjFzdmJ0azAzT0NuQUdUdGZ3T0NzUFBsMGNUVDVkOWNVMGlhbG10M21PQjdzMzVIQWFvaW5tK01jWnNwTi9uZHlRTDlVYURjNW15RDIzQVlZbU9abVRYTjBQM1VDdjEwYWN2Y0x1ZlRNMWFFWSsxSXc5eE5wODlibzkwelZka1BsUUdmdlkxL2o2WXJ1NXM4RkRRdXBySWZNeThINlo2bFkxT1dRVU1yb3dzckMxUEIwSnJ3Q01FZGJXTGY2WlRkdWRxdlRjTnMxK2xmNy9tclk1NUswQVdjTENyMW5QcEx3UU5iMTU2Mk9iR1QzamNicnc0NmY3VXBqOWMzcU5CRGZXOXN4VGFjZ0ZQeEZoaFFrREFCNTJqQzErQVFMQTdUcTY2dStBQUhBdjdrZkxwL09qcVg4S280cXBWRXd1VkRWU1ZRWElyVVRwa2NQSFlheXhINzFYRzIvZmQzZmVZcS9IQnFPMlB2Q295N3pWbTJldW56OTQrNXlsNy9uNXYvenIyMGNmaHl0eGMvNzdKczdsVjh3bi9Ga25kYnd5TTh4T1BidWFxNDVtS2tPcGJnOXZTMDNPM3ZEU242dG4rdTlXTmZQeWR1M2RVR29nK3l4UFovM1pxbUZmVEYrOTd6c1RMVU1OWFpuLzErM3owSHNlbXF2ZEhwckh6VlExNGs0ZVQ2bzlYTjNvbzhvWHVsRU5ZMHhkQTUwVWgxS05LMCtmV3FCUlpYSTQ5dERKWEhUbTVCUzVoZ0xneG5CaUN1QWw1L3ovbjJyOEFDQ1F6ZWlnM00rRlpSc0RTTVMzV25WZWhzZlZ2QnZVUit6NkpXVjA2TXVzWXNmZHYxcmRObUM0QUtQUndjcE1YZXlhaFlvZDhmK2RrVGZaVnNVMVlWWDlIN3ZyazJOL1NvYUlsYzQ2SGJkN096V1lEQTFuQldsQUdoVGVkWFExY3VBSGdEZDJqRDN5d1E4QTc4WmJmTmlyZ29wdDFLakVKclk0cXFxcWlyRXZMV3ZieGFHUi9ZT1B3N2hySE8xbVplcjdZbXdleiswMjh0U1p6aVAvdHJ4LzVoRmQvSGg0c3F6MC9IdnYvdkt2K09pb0tVV1htMk9kYitlUm10OUpRaWdhNnFFQlhRbjZjbk9tVk9kcFQzWGRhN1duNXROOTFKRW5ERS9tOCt2TU0yU1IxWGYyemt5bXA2YTZIdnFxNmlpZXAyYWdwUmROOW5RZTJGQ0hjM1djTlA2MG5LYnhGUGYxeEp3QnNRSE9UUFBWeWJyVVp2SUFlZDJXMERXNkJtS00xN1kyVHBlVmltWnk4bERBaGhic2VISTZ0YUU4T3ZtVWliNXlhcWs5dmUrMVFDQkF4cnZIRFM5clpYbi90VmxQN3k5SEJLYXlVZGVaVzl0ekpocmREbnJiRmZoZmIyemxXZjRabjcyY2pldjFTVnVxVnRxbW4wdjEwc3VwT0ZOMy9XZWZ5allzMHByRHhEbWx4c2xuUUZoNUJzQUdjYUFBUG5aMFkvb0JCSUFiZG93dGZoRUVJckRlQ0t0d04rNm5najFYMWFncUp0bEdTbFJWTVVCNzErUC82YTdXY0ZwaTM1Ly8veVVxMDZuRDh1MzQ2WGR4YjNYOVozSS8vL0crZFZKUEYrazMvdCtuY2hlUEd0ZDNwN2kvdUR6eXFmTDRlb3l2QXhOQmZyMlBrdExTWGI0WDAzZXllZk13bGNNbVp6TXduNjdKY1JaUnhwMEZ4ZDFrYllpbVVHZGxNY2M3WDJDTXFYcVpMSXFDVVZZRHgxc0pvK09zbkY5dWl2cU1tRWtxTHJvNFFEc1J3RDNKVHVSRHREZlRtUTJaQnE2aEVOM3NFNTZVb1FDbWp1RGkxQys3QzdJR2xIQ080YkxXby9QUStDd21qN29PNUhRbDQydWtpdVRDU3psSzZ0K3EyUDJ5alRHMjdXOHg0c2Nrc29TTUFYL1FhckF4czFzM1pWVG12dTFzZDU1bjQ2Zm5JbGlGblo5ZFZLMzMyVlptWEdLKzhvSTVyazZlaVZrbEgxVDNjOW8rWTlzbG5VcFM1UzdsSC90WHlleHQ1Y1FCWUFJQW5uWXNjM29EQkFnVk4rMFlsL1FoRUNUQ3p0d2I1VnZnRGdVVis2aGkyVkdwR0ZWVlZjVkE1eWQ3ZzAxVE5CeXVyVTZ1dW9iZjJiVGkzOTE0bk9nWFZ4ODNkNndQZStYSnZidTV2OHptdDBmVDRYYXIyN29sVHk0U2N2ZlY1MzY5RmNkOVhmaWNtZUxzc0d1R25WLy9vK2F3RDNQOEJaMlRjemVIbnU1MzZvMlpiQTQ3T3llbjh0MW5nM1FkcGp5bWJLOXVXK1hOMmZXVnZTdHhUUFdWdzR3WjdjOTk0OTZvSmxHSmlPMnNXc1BNbndQRGFuS3FjNnFkWXRsUTA5NXp0NnVyK0xDYnByT3VYZVFCRW9yOFZ6TmdlNXFDTldVb3RhTHB5cmVueVNScGlvcEpLQzkvN2JpczNTcWZaQzZTcitvdXJUL1ZMNi9XdFE5NzViK1Y2WGVtTDg5dStsZW0xejMrUnNYcDNIUmMvOFRHVE9sb3RaSGxic3RNa2MrSHQ5UTZ1UGw2MHRVaVJTdnZqa2dXUEhzMG1oSWliZDBKMTJiTVg3QUdqWThUZkdjeUlaTnBBRFoyOUhzU0FPSS9BTnl4b3p1S2hBQUI0SDVJbC8zclZtdi9wZndwcnZyOWU4VTJmSGlWTDI3MzN0ZEIzMGhVTVZYRlZDVlZWU05WZ1dtNGYwL0Y4VmNoZld5dWtrNk4wZVl4TXJWMk0vVGxlM0x6MDhkaHd2VkJlWE44ZE9Ob2VMVk1GN21MeGJSemZCVHkrWXFzYURyOFJORThuK0w2ZEozQi9LaWVHZnJMbTV3K002QyttanhnVGwveHQ2TDR0dHAyNWg4Nmt6cVpyMG1kVXptQS8vOU5OdlRoN1FFaVUyVHl6K0xOMHBCZXpFejAvdUVzQnhZMjVNUDhpK2w2cU1QcDA1R3ErdjExNjZYa3pLVk5ldTN1Njc2K1RqYXo2ZjZkUEo1aDAvVTMzVXVmUHYrc3BwdGgzMFBKVXlQeWVic25vczVjdzQrRS80ZXFSb2VTZEtWUDdwZXZSTDQvT29hUlEvL2VQb1d2TnAveTBzODEzOHkxbDFxMzJXeGRQelB0V3k3eU1hWFdpM2hwMXREcEgvTlQ2VFBXeXR4bm4wTFdZcml3d1FhQWRIY1FWOG5GeHo4T3dkNWVaTHR4alFBdXdUbVFxSE5BQXdRQkUwcmd3YUVhK3NtQVNMNW1hQWVlUEt4UnJDTG9sYitUNTVLanV2c1Q0MzduNWFUcW9WQjFmYlhBK2RJMDl4RStUN2JWVWdTL3BBQ2NBVHNjYWs2VTlUZE1DY2dnOFFGVXFUNWJPN2o4M01WbjJLeHkrWkJJNTl4Kzl4VXQ1NDY5cjBBVmgwYUxzSTBrS2c0OS9EZjBWZC93V1ZVeGY0UFAwTElPdkc0REhjeGVmam4xSVZUZnRPVUhtSm5xelExMFA2bjFRMXZrejVTK2JwcnpmcW5tZVR1OGYxeTFXbXVuZzNFVTB0WW1PL3BOcnh4WGZwdDl4bGZkbTE0NXlmUzZlWmk3MkZlUGRVZjhRK1RLOWdMUEEvQWJteDlUa1hHQTl3em9CSmxrVFg0ZGpMdGhNUlN4dWxWMzMwUFAvaSs4aS9ZNmw3TDkrOU1NM2V3OStQa0huKzlVa3ZldlZVUVZWZm5hRUZVYjNLWVA4ck91d3NJU3dkL2JIdXpicVpVbFAvRS9XQUJzM3pPMk5zWUI3aEpXTU1WTFlLYjRURFgxcXVkSW96YlAvMkZhM3p2VkNMeXNPNHZQeVdhQ2tKM3JKNkxHLys1OVdQUnJWRlJRM0pwbmRkaFNkSGZYbTNpejYvdnF1Z09NemNiSGhlY2hZS3RGSDdzMGZmalF3WXVnTGo2RVU1MzdjSnpIaEo1M3I5MlFyWTZ2SktDR212OHNnTDVXUUFpa0FMeWVZNTc2TTdvbGF0V3JmY2pMQzhpU1NOd0JqdnlPTGxJSXJ3OEpDbWJ6MWRlWGs1S1R2OHlsOE1WdEg3eFJITFpMek9qSjAvZnVVSEZSbFlydm5kYmg2aWVsNkhqWTYrVXJBaVNyYXpycno5Q2xJenpZN2ZTb1AyTkhnK0gxM1krbmtibmR1d1RmeVQzNW5OUFdiOStvWmRXNnY5MnFrYnhLbmF3UkhhTHBaM3RSNWdPUUpYcDV6R29LeXpva3R5ZSs2TC92Mnk2TVhYWGtXLzM3THAzbzEzRml4b3VJZlExZGlLTXNEVDE3SVdhSmtBTXV4RjlPZFQxejcxbG43Q0JEWVU2MzMydEErMFloOWdtS1lCdlpidkRaeUJvcjV0ekxDY1poRHMvODU5Nlg4MEFybVl2YmFkZUg3UTcvZklGSDF6OEFBQURBRFM1d2w2aFVaK0RRRlROUzVVaFZWY1VBQUpMc1RaQ2xXVW92SkNBeFVSMHZ1b2ZzaDhQWlhneXFZbzBHeHAybXU4RjRMaUJaS0VxV1VQclAveFpTSSsvVnQvdEtlWjBqOTlqYkhWbzY5QmNuWDNQV0ZrNVJqdFdDQlZ6YXVHWk5NUTRHZ1pGd2pDSlJEc053TmFRazRUVU1qWVJkV2xLUUJVbG9RU0t6em1yUEdFKzRoaTdvVG14enMwcWpIbW5BdGx5dXliMmJTRElTeDdOWkFXRTEyWEY4ZFdnY2F3VXFpQmNhR3hhRVlPVWxGd0RqQ29BQlNZb2l3WGdHQURCTHNEaGNTOExRU29jbVNuY3FpTFByMUN5WEFLWnNPaE10Z0xRVVJHTk9qYlBxQ0JVTFROU08xWDBFR2hvUUJwMTAzMlE2OWY1eXhXOHg5bnZlWHR3WVpNbHFYdnhIeGRXM3IvZWV0eFpjRmlBb2NJY0FYdHJONnMvbTUzS3lIMTlidE5OdUtOL3A4ckdESDE5Tk4vd0FBTXFhY1hvS0VNbGVWVHZLTW9rdGJsV2lxZ0FBQWIwRW9LWldKNmgwVGR2Uk1GTnBvSGxLVC8zR0ZkaGk4RVFuNnYwNWRxL3NWeTlHNzRqbG5xZWJuaFdMK3k5OWpBaWhDQ3FMdldUWVdxVlZoTXRZMW9DRGNMSGNsZ1d5REtvQWhMRWh3S2hWcENQb3dRSUhscTAyUVlpTVFBVmtNRkQ3b1RqOUE0K3hNRVVGQVNnZ3lNQnYyNmxJMkVaTTBTUkV1eWIzWWl3endtbzJTVWg4VUNiczVZV25SZ005NEdVRTNNcWxZaEpsZkdCU25TeXpVSXJiUWdheUVKVWhpU3V5YkJRTGpHZDJSQXhaYkNOTEZxQnpIWWU0cHVLQU9JQWxIbDB0RXR4dStlVlNWNU9DWWR0eW5iSXV2US9CWmp6VWxycDFqOHpZVnVPdFMxdlJJbmJTVVFTcnpZSndBRjY2WmVXV2VYVzVHZmNUNU5Jc2JHZlpMa2J1YWQ5dlFlZyt4MmNPcTAvMHNDSHNRN1dlMmlDUjlFTUFBRlZzcWtwTXNhb1NWUVVBV01NS1ZqVUZmenluVHlmazZQMFVJN3BiKzY1NUR3QitzUjFwdjdCeU1waVJLd2FKNGRYRzdxcFhjQVhDbG9Ba0RTR1dpd1R0S0lIVEdabzZ6NWlzWGlhcnZReWp5aGlGQ2h2Y29VSGdYU1hjbEVRQ2hIWktxdGlLRkljRWFZdk44T1ZNQUJnQVpNWHlFZ0tEZWhXQUFWb3NsUkRSWStJQkc4QzRrVklLcURBR0JXa2ltVFIyMExSTDZhSm42TFV3YVU2dmdHaWJnTlZFYWJOa0xBQ05Gd1ZmckFtbHdjSWdoNUpyWnN0U1JCR2JPaG5hZnFuT0hpMnV1dDk1VGxQN2dzNWVYRVFXWndKQnhrcnRCaW0zN2ZUTk5XRngxMDRNOHRVUUwwZUlEbmxZM0JlMlhWYnJFalhjQVg2NjFlZDdtbW5CMHlUblUydXo2WGFMekM3ZnB4TzJ4TzFBNVU5K3VtUjdSQ0lmenRORERqUWdyLzV3dEFRQUFPU3FZb290cGxSVlZRRUFYakxkU1U2bjY0clR1N2pSUnN6UGM4MDUrQzA3M3ZkTHppWDNqUGp5Y1hWK0hCMEE3SHFWOHgrWlNCU0NqQWp0VUdRTlBkZmFkUHhXMWo1M1pUMW1CYXRmNXpxMFh1VVlORjNVQzkzQnpUaWlrTWNwUklhTkVBQ3lRaUd6c29RSWVTRnVFWFNzbkxRaE1RckJFWTFrVVV3K2xaVVVJRkVHRHVVNHdvRUJBRUNXcnpnd1ZRZWRSeE1lR0dob3Zvb09MME9yVU5GWkk0cEtVejBNRlZTajJNVTJPSTFtUlZlbFJhbHdwd3NVVks5bGd3Q3RRc1llVDU1YUxraXNlTGUvSmxSbTh3Q2UxWmRZNjBuN0I3N2RKQjBkdU9LY0dXVGQwL3ArT2hJVzkvRmh1VUVBQkttSFQ3ZUJoOURTTkFsWTRJQVZBWDZKeGVOUGU0dGk4Z2FZdFk3blowUmVuT2tHK1B6NS9ZUFYxby93OTVmUi91S2N6VUx1R0VjQk53REFuRlhWcEdmWTJhcXFxZ0FBMHd4aDcvTzdycDZKdCtUbmZjeTZ6SzhzY3JwK2VMdlJQcFFLM2VsWVBycnZBUUQvR0daVDl1UzYweUlJQVNkOENoL2tXNjJpc0dlNE4yYXFidUMreXRkYXJ6cXZwdyt5NEkvMS9HS1VLU3BIS2pFTU5hTXdweGczbGUya0IwTHlDalU5RTRWZTJKQ0lWVFNtQUdBQVJTWFdORDNMckhsQzRZVlVXQ0JIZzIzUHRsMnlsTWJXTG5PWjhUQTMybjBkWk5zRmQ1M2FUOUkvQ2hRMXV4V2RHTWZ6VWtRMTVYM3IzQjluQ0VzbXV6ZTZCNHlxNkZjZHRaSXFUU2RZcElNYkNSa0xZOTNJc3BBbE03Zm5kM1NiUkdVeHZ1Qk9UTVlqcjlvUjNqcVdQNHlEbjVwT3VkdTM2cE8wQy83d0VmeDQ0czlERCszR1hGMjJEODNtdU8zd0podXIyMzZTbmdQZWFpM2JuNFFueitNSG9KVTY3bzljbU9UZjJ6TU5PZU5jOE00aWpEVkcyK2FuaThON1Bqamh3ZVh2YzR3Y0FKcVZSeFVYVU1KV1VsVWpWUXdBN2U3dFBxTDlSWHRPR0wxOTVsOC9UQmd6MXJsZDAralppdWI1emdvaEFPUXVWeFJ5bHNsbnY4c3EyZktiQjQycm5udWoyejc4blh6TTRKNzhyc3crOTF1NWY4eWM2VGdILzVSZmUxcDZ5ZHFicUpUVE5YVGVpWHJjbTd3QTBOMklyUGsySkoxZ3RiSSs0cmhmcnJyNXpHbXk0d1FBYTlveUNUMUxac0hKRzgwSUdIWFJiWWg4eFo0YzNWV1QwRk16OUdjNHF4NVVQM1JxZnR2SFloNmpSM0VxanVQYk5iTW4yYUJocFlFK3pPemt6WDFuUVVMWFZBN0RkTGlkZFlDRUpNVkl6UDYrdUg2dm9pdW5yZFpxL2w2ZUtpUXlxT24xWDM0bGg5UytzbC84OG5SUGxSQ1Zxa1Vsai9VRkFnd0FCZW1xZFJDNzhFaWRzbTY5TUozV1gyYVZISzVTSk5lQUFONXFyZHZIek5jeWVackFxclZjNzdPcnVaenQ3cllvYXNPOWNSdjdiVnpBa284VGF1UW11eFo5azQ2cXFpb0dBS3VEWTVHVGg2cmFVQWkxbHh1ZDU5MTZGYktHMXNQaDM4Qy9jVnF1Wm0vVzdzL2ZYdllJY0hUK2g4TGROR1AwZ1c5WGlmQ2t1MmNHeVBLNXMrUGJRNVIrY2s0cWRYOGtSVXZOMTF5L2p6Z3NkR2NXQ0dwU2lybzNGQXRGdFpTWHZzODFEN0p5eHFGOTV6ZmJWZnd5dnZLeXFTbGZsWi95dDVnMmZkZXVqV3VxNHlLM3FGZE51Qy9wU1FtVG51N3VXYWMwODFhK1hYMm1VTS9kOVBDMlBJT0dtcjE5di9aSzdvVTQrNDh2WXVQYmJkcnFVU1pWN3gvYzFFb1NwblYrcFUvVzd0eSt2SWZZYUxRUFp3YTVJb0phdWxVQmZFYlI3SHFwbjBqRjNjcFYycW83eWIvdC9tcHRVM1RqTzJkbk4veXYwdFl6Nlk3TCt4by9iYVczNWNkdnA1VGllcERGZkhMeG9BY0tIam8xKzJ1MnJ5YnhCdWlzNnZVNXkxb3hrbThZNGlQa3hEdXFlUE5XTzFxalgrM0RWUUlQRjVFWUVQMzUzd0Z5MWN4VnRkSlJWVlhGQUdDOXpKWWpkWGYzai9NZTJjNzI5cWRWY3NqYXJUOUc0NE5IMXN0ZHQySC9IN1pCQ2svazUrNjUrL0hrNm1ZQTU5bzlhNTc4WTRCa2VsNnVhOVgwMVhWQ1duRncvU0s4ekluNXlrbVlHcE1oRk5WVjhPYXFqZ3VORUZGcFUza2NRNmdzTkc5UDYxK1MvcHdGWjg0Q2l1bUJKTDl3cjh3bHp2bHp3VmxWejlwVTNoZjNKei9aWERSdDdqenVQRE5NNTgyZnd6a3pOTlBUVU5iaWVRYmVyUHd0aGo3OWRpZmpobmRnUXcvNGtLdjZUOTk1aUthcGVTZy9MOXE4ZEpVMXJPL2o4YmFkWWlJTiszRW1lNU11SVpwZzlucm9CZG9odlpkSFEvWjNtMkFrZWVQRmxCb2ZyYXRKdytKSzZpSG5DOHN3MjFaUHJmVVkzQnAzbmNhczFpT2ViMU5kZXc0Y1hxa1UvVGsvblptOGdWM3FqUHN6ZEtVbDcyU2QrK2hpZXR1YksxMjVtc3ZqMXdPNFBJcVlSREEzV20rK0FlUStud0JsTlptMHNxcXFxZ0pBQzNORzMxdmNRMC81MlR4Ly9GRHB0Z1hHMTQ2dlQ5L2RONE45d3BGMTFPU0NMeDFIL1BHWG8zZzVRQW10dGwxUDNkWnQ4K0kwMDB4MU1wbW12eWlZOC9MalpiNlVkVG1BMG1NZHhldkwxYTJ2aS9zeUZ3MlVVS1Q2M1FXbmFheDc1emoxQ2pPazRicmtLclA4cXRnQURBUHMzdm04MDRXYTR0eFoxREMxemxsb1RsMnUxK3hjc0YrWFZSOWhvRWxNenBqakpxV2VvOW9IQTlQVDA3di9USzFXZVRlZWJkVlJRanowaC8veCs4ZUh1bHdrYlpaZFZES2c2aVphd0Z0bmQ5c0E0a0dpUTNSMjFQbmQwUjJpYXdhNmRNSlN5SlZsYzg1L0Y1YllRaGFBbGF2bjJkY3JUc3daVlZaNUY5cml5cXFoVzMwQ3ZvRVRSMWo1MXk2M2F2OXlQRWo0VUZjY1QyZG5Vd0FBUUYwQkFBQUFBQUROdmJYOUF3QUFBQ2E2QVdoLy8wbi9RdjlOLzFEL1MvOVIvMUgvU1A5SS8wUC9QdjlOLzF3NE9EbzdPanhMU1ZWTlBWWlhUa1EvUUQ1Q1RFNU5VRTFQVS85TC96Yi9PLzgzLzByL1FQOC8vMGYvV3Y5UC8xRC9WUDlILzBuL1FmOVcvMGovU3Y5VS8wNy9UenM4UEZKWFNENDhVbFJSUnowK1JVNVFUZjlaLzA0L1NrbElQVHc0UmtQL05mNTRoTk83dlJzRVB3UGN5Nk9jbnJNS3lKT2ZBUmZ2NWhob1R3WDN0VlJTWXN6cXE1bVlTcXBHcXFvWXBwTHJmdjU3dis4dXh0dStZelV3bmpmTzd0enZIRXFoZmZnZVdybjgzeFY5azYwZjcxSHhtYmZ6cnFZNnJFVmxXZGx1Sm5jbTExclBEQU9QV3FxQnpiUjFNcHI3OVBsZDY3aVFuTmZyK1pqMzlQM3R6S1NZZXdKa0t3MUowamRkUDhNREhQYncrdTllT2o3ZzgyMm92UFQxV3FOY0FBZ3ZvS3VTb1RiNTBFL1dkQjhQd0F2VWtRZTFydkZyZTRxeTF2NmJPcld0YVgzT2hyZWl5WWY2aEwvMzJ0WVpwN0ZZeXdSVWRzNG16KzdjWHlDeWh3TjFkOVkwNWFiM1N1WWc0R2NXeVFlZVlOQzFuNlYvc1dWWGVxK3JSNVJsNTgxZjYwN251SzZ3YUtyM1drNFd4bjhlQ1lJTStBZEd5RzNmbDN2SjBua1JyK2NHdTBIM01lNjNFWUs3YmZRUGQrc3IydFd2SG01Wk1Va09JUkFObko1UmdHeU1PQnIrZU1UenM5azdNdmczd1E0ODh1NDVWYUg2VGY0UzdyMlpwVVBmbFExVXUxZlZZSnZGcEtTcXFxb0FtOE5HUGYyMGZ6TmQ2bGYvSGQrdVg5KzJ0dHJUQXY1M3F0a2ZQWDJiSzY4bjF6OGwzanZqbFp3OGVuSEVTK1ZWL21HN2c4K1RwM1l5bmV4clhMUnpmc201T2RsTmVQeTZDaGoveHpYZjNmWDlmQjJHU2pxcG1sOTNROVl1bWxZeWJJYXVtNnpNUHY4OC9ic1gxei8rV3M1T09Uc0JZQ1VJTmVJUFo3TEJ3OENyVGE2bXZWUjdYZm9iM211OW5VQlBWbHEvRFFMZmt4VGRNNk44eHBEUXBDZjlSbFZmYVB3YnRkbDJ3UmFtcXU2YTBWOCtmMzdTZWxZY21uWE5JcXJjVkJTQ2xCRGozV01YTlBWcld0OXFMeDFyZTd1RHFvSDRobi9WV3BiNDdndFJ2N2Z0NEtJNXVoOFdyWUl3Y2xYeEQ3S2JNUEZKZjNVdzNVWE9XNmY3dVgxVzlWaTI3dXV5WDFsM0lPZ2Rza3V2QXJpN0l3dStlSVRUczMwbWdwOEpSN2Z5S01jbnhQeDVObmVqNU9HOXBSSHZ6NWM1SHYvRHNYMEVIZmVjT0lOWkU4T21TRlZWVlFCYUdNL1pNUjEyaUhPNDdjejltWnlSQnNyeS9jeE1Hbm4zU1o1VC9lU1FuMDVXZWxNdlBmSjUvS3QvdTUvR1BGT2JnbE9meWVrbXFwNUpaaWEvbWorWlpkWjBxL3N0ZEFmamkvSTV4dHZoOEZMampoaFhodVdnT1k5OC9BeXoydU9jaE1WKzgrL244M1AvdkZicGx6V2VoNkhnK05RbTJPbmFxTy9QcS9Wc3pjcXJJcDIzY3kvMDdsU3pQdG5KZnc1akFPaVh2TEhQRjJBYjN6VFBCOVRJWk9iOENyMEtZYjF0NmVyTnk3R2o3Mm9xTGs0eXZGVk43cnU3S1dkRDFTUkI1TWtHMmJhQUZUZEd2dFZTcm5SbTFBMDlMNTFwUDR6VlVydUVYVGU3TkVQRy8xZThlT3RJM3VSdnV2Q0NEbGRWcjE2blMvdU0vMkYrVmQxZkozbTltc25PZnRWTFhhMUF0UGJCbmtKVTdLMGhGNWdsNEM0akFUNTQ1TkpyZW5mSTREdkFuVVRLOVpYV0lJZFR3SDNITWxyOXQzZEhuL2l3TkZDVmQ2bjJ2OXlvVUxrRzIxME15d1ExVWxVVkFkOS85MVBPclcrNjNab3krRDdqbGw1YUZudjVZTUF1QTJlVUs4bVQ1VWI5dzAvNlBXb2x2Vm81dVA0WFFnSENIbWorVk9MeVVObGpUdEdmb21wKzEzbzR2eUNyb0QzSC91VmZuWFdjTEs0SEFBZDJ2a1AxOUs0L0Y4NjFkdE16NUx5a3FHTzc5d2R2czJvZkN0WlRDZlI1SENaNjhLMEJwNmlvNG0rZFhlSXdqZWxWTkY1K1R6U1l2K2VhNXE4WHVzazNhVExwTVp2WDB5Q2c0R2UvbjR6SnI1V2src1VuaHg5ZURUUCtCdytmVHYreWs2bTM5Ylh2TDNhb1BNRE44NFdJNHpFWW80UGUvRlZHeGc2VmJCY05mbmNXeHArUlR2TTJ2dkliWXl5US8wanVLNUpvL0k1ZDNVbG5OOGNucFgwakI3a0l4dUViSXlhOHZSU0tiNlB4ZUIzcjJkcGFXMmZXc2FvazliMUJWR0k2UUVQQm80RUNIbmdrMnQwV2R3VGZBVzdoRVpiN0ZCTnljemNFa3ZkT1hYRGF4OS9Wb0xDUFhKTWR4YWFrcXFxcUdCckQwZFRiejZZcmxZUGlSUFBweFdmeWk1TmNHYmtyWFh6eDh2K1I4WFZzUC9YMEpIZXhlL2lkZTArZTZyMmR5N2ZTVlhINm1BbTZCOWI1djlhajVuRncyTk9HM1p5bzBrZnBmVTVyUFowK3krY3F2ZW42bXBQVXpBQXd1ek1jNk5uRjlCL1hGSWtiVGc3cmp2N01MLzFiTmIvbTkxcHdtVlhubVRYTXpaaDVOS2oycVR1ZklxRzcrVDVLMjVtK1FEcXJyZzJvMlpReWdhNHNlcEl4OHhad2N4cm1CYWFMZjFUYmw3b2FtcHVzWnZvNmFwVEF2b2NOa0x1NnYxL1ZuMGZUamYrTnMwbnVyeWwzYzBtMnJPcDA0cThUWlRZYUV6WEVocXJ5T3Fhdmx2cC9mRVlzem9OUUxuWjhiWGRTNDN4aEJQclZHbDg5dngxMW9TbzI5Z2JFOFRUTFlTVGllcnZXQXRxTlpkeFc5N3l5bkpnSVZoVDdRNGFHR0JvWi9vY2t5bU82SHdUUHdEQXY4QWpHMjZ3S0dUd251SitzalJ3WHdtcEc2OVNmVDNyVm0yM053YmhzTDZGRWZJeFJxVkpLUnFnYXFhb1ltbnRkcHBJbHRYYisydUdrdjVQdXZHZTlPQjdYamFwTEdVZitJM2NpUHYrSHUwZUhsRy96NXI5OTNSSDUweE1NbXNwMmN4NElLSWdMNU5YUnNvZlBZeGE4VTZoOVNYZHdpejFUdW9kR3dGbHJQVEVVTmZQREFOR0JudFE2Ri82WjQ3anJPclFubkd6bXJkME5ETGhJR3JxK1RIM0lFOWJ0UEUwLzAxbGMvMDBTUHJNdysyYzZ4TjhmR2tQdHVza3FPb3NwR05va3hhODQzT3dFcWdESTI4YXNnOTFsdjlVTlNySVRtc1NiZGgvanZqTVBuUlMwYnRqcm5FQUlINU80L3EzSGpCSG10WTBCTTdrNlZaVWxzakVZR2ZGV1pORTVocGFubGNFNnZ0dldkSWtyc2JaMXk0QnNBOFM2VHR4YTg5ZWc1SDg3UDRQOWZpOHlNeXFSWEMrSnJCeUY2NVVrVitpSHNNVkU3aHp3c1d2QTRYb0FYbmpFL2RFK0M0SS80QlllWmJtUXFuNXV2bzBkN3lGYmNPYlhQYzQzYzlqMitWNDFScTZVRWtNVnFocXBLa0JqUW0zL2pUMXJGS0xjOERINnlhMkNNWk9qdGZJK1p6dzZ4VldiczhUWGRibDhtaXQrczVHVkVZZmZXYnlGQURKdmFXcUpzOGR6NnJPemNkNzZMTmVlVEp6TCs1K25oeDJGNVdVUDk2Wm9GYnVvMVFKZm5NOEZWVG56N3hZV3ArWmI0ejZMZWY2Nm1kendpVDRMaDZtM2FTWkJXVFFGWExQVFZnM3pOc21hZ2dVc1VjYlVGV2NkSUs5TXFJNlNVeVFYb3lwSXBrbDZoMXF4NEtDNy9WWERWbloydjMzVTVJenpRK0drQUw1SXF0YTNLR3ZlTzhmK05kbks2T3lFOEc0dXZtTVgxU1VqeWZoWnhpREwySHlYWld5QldXWGp3TmpaNmNPWE1GcXhoTmg1Ui91L1N2djlqbFNyajRmNEtiWHFXaHVyNWg4M09aQkdRamJTYXNDZWMzdXAvZjUvbFdsdVQ2dWVFa2I4b1hRTmNLdnBhRFRXWGsyZ3NBaWlLQTBBbm5oa3kzMytIUWorQnJpUnh6aGZFZzF5SisvR2p2dHl5T2publRseGZQL0RWZU9KcWhxcGlxbWtxcXFxQ0pEVTZycUc4aWRWVjlkZTdhMzBsMjA2THNPTVkxUENNejh1Ly9BdlIwOWphai9weStmZVd0cVBjejMrMEtxSEhpMnQ2c0tNWmlZN0svS2Z3NlNOaHZXRStUdFlXZjMycDNhcnYvYXk2ZW5LSHd3MVRIZXlGd2ltK3pDLy8zeTkwSFgxZEg1MUtiUDVUT1YxdDJYTGxhNFpIbmRSWkVMblFBTkZVRjhqNlhzd3NubVdxdVRPM0hQZFJMVTFNSERVN3d6d0oydm8zTkIxNWo4OXRVa1BxWEdlRnpPMVoxWXpjdndobWIxZCt3ZWRQZE42K2FlaE92T1FRM1ZwczZrODJSdHVwY2hGNXZxWm1kTGM1WG5pM1BaZlk2VFZhbC9mLy9KcTQ3UHNtVnhKeFhHVjNGZHVUM3VxemQyL09jdmdTeURWZnZ2aWhpc2g2UTBWZ2UraExOQTVINlBadERuZVVMSmV4bzZqeTRPSDREMEd4ZFVJQWc0QUhuaWtmVHQvZGdUZkFlNGlVaXozeGhma09Yd2JRYng3V3VETDJkTkF0Yk5WZzAycHFsUlZWUlhEOVBIUHgrcnI5ZXhQcDhmdDAwa0xmODU5OWY5Wmd2ZmFqZk5FM3Z6M09ibmRqN1huNW1mbmQ0YUNldlBidTdLU0lmZS9HNEVVN2FpelhyeHp0bDZnbWN6RnZTZEgwZTlYUjNQbSs4MWN6Vmk3bjZHcU05R0JZWndMZFZmTjZmbzdoM3FmN2pya1FkYkdhM3ZiKy9TUE91dHJDL1ZqdFdubVlvS1pUSkxOa2k3Ung1MzB0UC8yemgxN09YSjFhenNiby8wWDRpcUFLWDZkZDY5VzkxYTd0dXhoZ1o2cWxhWlNzT0hrNUM1K0Q4TkZrNlhVWGxOTDlwTlFhR1p6SnJ1bXM0Q1l6V2xLQ0NFSEV1WmZ3ZmhNejdMcWNYMGxjYlgyWFhmOXZzaHY5OVRhOVlyRUxhVmRmYkQxTGJNLzhwMHVXQWNOOVpqeDc5S3RiMURxbXY3SDlEeDFaNDcwMjVwdHJMOTNxNkIxVGErbXdzNmlnQUFWNStBd3pZQUQvbmJrOUdYNkRnUnY0QjRlNVh3QmJ6ODNiK0I5ZU5TdGNSWGtDRCt2NHU1SGdOMjk3R3RVczFKaVVvcFVWVlhGOEwrOTE5WmowWmJsV09mYnRmTXJmRll6cUhtK3YzTS83dC9oNWIremIrYjQvcXVZWHozSW5lSm9wcHBtNDJjT3pRWjRxVDRKNmUrZE1IamRxS3B5anJQWTh2TXFYL3JlSkpXVE05azU2aWpKa3hxVzgweE9nVjZteHZmeS9kSTBqM3cvZTYzMWFHWTBmNW9zcGxrTjZTR0U2YXg2bURGVVR3OU1VUjB6N24xMnF0UFpqWmxILzVLTUVKUGU2KzF3ZE4zK0s1TisrSXgrai9xNmxNcGJ4cGFDS1pwcDFxR0lKNy9yK1BNYnFPUmpEMnhxL3BSazRMUGNnNUd3NUJkTXNzM3J0MHBjMTFKRDVTZDJicjNVRjliMW4wdDZ2VS90NjBXcmdpR1hKVnJ1WlplWTRaMFF2SXVaL1VRZjM5ekg4OXg2MThWTTIwR2xsU3ZSVlQ1S1psWEhWTnI2akVQMXRnTmZaQjBFQVJBUUF0NTNST1hhZmhQQlR3TDM3MGpIeTZ3RnRIeDU0bDBNOXMxZm9hczlQTEN6b3hKbnBGU3NxcXFxR0VNZ2xZU2FuK2x2OTNQcStEemp2SGY3ejltN0Mya3VkMzJKN1h2c01ibDd6Y2VYTHcrWHVteWovcHJMSFQrWXYxMTA5N1pvOGRVeHZsVHJ2cHFwbGZrd2twTDAybGJSOS8zeXM2VlpXemtKTkNrRUlqcjlsRnpyYnZxU1drTTg2MUJLWlFIOE1zdnI1TnV3cDVDWGNpSUNxYTZ6MFQ0aHFVYk5GbTExaTlwTy9KYXdjNGxYcXl4QlI5MWlLV2puamZNV3FqRU4wSENGblVFYXU4YXJFeUJCY2FvaGxXWnNHdTV1NWRpM2doekhONTZoaXVFNDlEaHZOSis3QUZ0WUZsQ2Q5V3Q2NlNvb2lUN1dYMlRhS3hiSFIrWi9ObFpYYkdmRHVyUFovdjlzVFhoUGY5bWZWdHBDeE1mZ3JVZTkvYjZJWXhsVHFjcnZxeXFRUEwwd0dBemkyOHk2MDhFczZ3SkxEWUZnSENCYkhvNE1Qb2RVMDVQc25UODcrd1B1NFpHZDk1UkREdDhKN2p1UGhxdlJMVTN1SDhJUGx5MVhqYXJFc0d4RnFrWkdxc0l6dmlYbWxMUDZLeXYvN3llSlo1TllRU2VyYjQ0ZmsxY3lQL2ZrNndtNWZjNUYyUlBuL2YzdGczZjZkMWhyMWxaTEdrMkpXT2xIUzFnRzd6c3c0R1gzOUVDVzNQSVVHYlZFSlpCT2V4bUtMbXFKbzNXOERMMnN0WUNSRWZTYjRpSDUzQTBEdkZqVEE0YnBCcUFoQ1ZKTEw2bllqa3NJcUp6T01rTURtUkU0MGFzU0JhcGJPVmRXMFpNVU02Um45SmkxemtwU2Y5akZKN2ZYKzlGL2V2YjNPUC9jQzdqVGJUaXNqWDE5bHVlRm45cG5RVGEyTFh3aExHNWhHMG5ZdG1UWkgwbllKdVJqQUlQOWMrcnA4dENZeXJqOC8zc2IvdmYzVnZsZS9EVm1mdmsvcjd2YVUvZE5DNlgrbnNudXNhYU1rSkFBSWtNZW16dWZRZjdMbzg4QkZ3QUl5YkIrN3V0VDgyaEpyZHhIY082djdkc0FOa0FEUXlCbkF3QTJkZ3ppTnEwaGFmaVo0S1lkMVhoRmx2N3M1TjhVTHB2bS9RRUFBQUN1SHhTTnlvUGhwRW9NVVJWVlZURUUxb2Rud0llOTh5c0FlRWpzcFFQdWxUbXdOL243K1BrZWVFT3lxMVc3WWZaVHFyWjk5Q2JEazVtM256di85WTNWRjRkY09iaXhQR3dWc2R0WGtlYjN4bWVHUVRhdlZtTEdaNmF2d3dYMVhiM1h1YTZiWXE1M3ZKOVQ1S0hIcmo2WGNxLy9JcXFsZHRjOVp3WkttbXJ2UEtLWkgxVWNSV3FWTzdVVmZVUGVoTzczV1VzVTNTRkJQRXNOTkZCbWhUZWNack82bC8ybzE3eGlQUDk4N1EwNWxUeTd5RndqVHVXbDZSNTdBK3Z5ZlllZVdsbFZzTGFTWmdNblZkV1ZDVDRYOVhabHc2Nm5tSDVyYTgxdWZPSjJZM1d2blpReFBoQmVTTGZ3V2JFeEpuK3YxTUZOQ3hFV1VmOC9NaWNsOVdtYlhkSG52OXFudVpmTjNpcEJCN3YxMVlCSXJRSUlkSU5Bb0ttTmxpN1drWk14MDVQbWZLVnBMdDAwMFB5R1ovZHNndStjR3NINDZEVm9FVEEwYUt3QlViQmtyQXdVZTBCWVpCbEpUTjd4bVgrZGEwVEdWQUk5OWtpdnN6M081ek9ySk1NNDBpdlBad1Z2WCtaOVZBNzk1RnFPZFkwWXBBR2hZRlN1UEN5cURrZ0NUTWFpcmsrdi90VUN5MVFwdlpPY0p1Yy9rUWxhZjlaL3RZMGQxZUlZdmFWL2h2QmJxdzNTUmh6TkdRSFVBV0UwdGRjQ3cvbjZKWkVSM2k2QXVPcSsveUpIYWhwVEJmRXlqZm1QL3hjNmU1U3ZQV2xPMnZmcnVEZFY1bitaKytmUG1Ldm5JK3dBbkFHaGxwV3F2Qm5VR05DTFVQRW50Zm9BV0ZhRjI1MGc0U2xhSnpPblN3YVRKNENUWXVmUnJLNG9lajBSNTk5QVBXbnRqYWlOTWFKVGd4V2tBYmxpbExlcklkcDZ4TUhVTlVqWHRmLyt2ZEFWcTBUOWxuZUg4S2UvbmowbmQ3bWoyUjd1ZFpuZDVoRlBVTlVydHRQTG5UV0pmeUlEeFAxNEZOM3JPSVRuZmp6TFFsVTdiYmtEVktiQzdtMnd4dnB2R01GNm9uUmM3cjNlT3ZUdS84N0RlSjNubDdpSHFUdFh1RTA5a21KSmpBZ0p0QWxCVm11dHpRZDRGK1ExWWgrRWNEL0FxTVlEMDJVTnNQOTJpMVZXc1QwRFB2Lzk2ZFhQY1dtUC8xV2E2dWpNZUJrN3VFcWJUMzJTL0FXb2NLWEsxMjArWTV2bFBwbnoyOTBwOUc2NXdwcnRvcWZnclNwRXFzQzV6YXdVRVZqYkxuYktuTXMwVEhQb3ZuejY0ZmZsT0ZLRXV5Vk5qYnkzbDYrK3VYdTVMeEhIRmpaNHQvcy9OUGJmeHN2WS8vMTE3NE1SQWdTUDFjUjRMQ2UvWSs4WGIzVHdITHpFYnVNZnpwYUI3WVY5L3VYR2JSY2szRzl6SGF0ZVlXWDNNbXY1cUNvcWlONFd5cjJuSCthSms4V1ExT2o5YllDczZ4WUtBd01ma20wK05kanMveXBhLy80YUxBQTB1OWZyUjAzNTBrck1hUGZsY1J3NlpGUk0zcDdXVk51cGNhUjBkUHl1T0lTUWZqUlpHaitkOTZPT1Excm92bWRuTHR1V0EwWlF2QmVjdGFZZ3N6TzBIWWFXdTA4RHZIdlB0VXphQmh5Nzc4OW5MTHc5Ui9veSsrbGw5bFovVHVuWGM1N2NrTFlEcVRDc0JOY2N6Q0lHRDB5Snp6aFljZkI3cllDUnBkQ3FOV2t1UkRtWTBUMnBMaFFFcTJ2M2lWWWpDOUdXeit1Z3Q1cys1Z000VXRvM1RYUzVBcW5ydXJzY0tMSnJoMXRqdzlBVkJVR2dlMWxtWGQvM25abW13MjkrOTIrLysrYnhka2trQ2FDN2UvZmYyalZWVlhWUnpMKzV5bmkvZU5GRUJQeWVRN0Y4MXN2anVYeXVaeld0Y2txRGZ4NEEvOWlUdjJnelVIcDdBcWpVSzZtV2liUm5EdTl2V2pacy9tbEROUFlFKzRMZ0I1TXB0K244ai8wVDZtS3BvTEw3Z3IxZlBBOGd1bC93enpUYnR1V25VQjVQQUN5N0w4ZTNPYUZpci9GbjkrMjJLVHQ4K0N4NUJ6aVFiZzU1bEk2RnZBUzR4K1AwNVlBV3dtblM1bzE1MXZEV1Jra3BsNEcrb0h5RXVhQjgxOWlSU00xaVlqRCtIdHBZUEsvM3pxTTFBUHk2TDQrblZYaTczT1BYZmU4WHc2bHpYdUkvd0lGY0RrUlBoYVd4RXp6NGk0VzhEd1hhcVluejljYy9lZXRvUk1yVWx1NHcxekRTMjdNY3BOM1NmUDZ5NjJRQUJMdS9HWTdGYS85SDlPSDE1M2pZWi8yZkF1SWZ3SUhjRGtTcVlGbUNER0ZrYklRT2NvNHREZDRMcDlNcnRteE9hQXQ3MlcxK1VaZ0JMcExkUkpFQkhMdS84a1pNemQ5c2x1eit4TTNXZGQ0OS9BYzRrRytNVmVFYUNUTGV5K3ZOOHBsOVVucnEzYTdBbzRvb0FBNDBMY2xCTTdlUDQ4NjM5ZWFkdDVFa0RoeTNQK3E3OGRCOXY2VjcxV2ZjVTlmLy82cTh6cXh6S0xKeklLZkpxM0NQWjczZlBZVGd2MWowTFFXUnhZSkJuOTNZZHNhV0NybEpwNG9sd1VJY0hMdmYxTjlYaDI2OGhJOWs5M040eWpWMHc1SmMzRTU3YnFXSHhvR2NaMWVoYTNEMXZVQW92aW5lcVJoa1NhUXdCaHl4enB4UUF4ZlNzUzhkcExRa3NPVUF4S2JiK1RyWCtuK2Vmb3VPdy9uY2VwOTc1Z2M0T01EU2dMZlpBWERQVGJlN0pLTHpDQUlxZGlRSUFvZDI0TXh6cFp5Y0lMN3RqVG40NjZKTGR5Nm5QRHJueThYTVhmUTcxRnUxQXhTdk05M09xdVIycGNkckZXWmx3ODdNVzZVbWNwOTMyL3lZSHI0Z2hKT3J1ZmYzNXY3VnlNR1A2bTZUZVhyNmlsUlJ5OGZ4NUFlY3Fyc1RiblAvUE9IL2ZxNGZYbzBicU5uMTk0RVNjQnk3czkyWDEzR2J3ZUt4V3d6VC9iV05BbStmcTEyUE5RODJ0NXNCTUs0MXp6TTRJOWJNVjM3a3ZSUHZYc3FyZWhDNGMzREtNOTN6OVBuYXNPSDFoNStwSW1MS2h6Ky9FdURGNjZNQjNKcGhPM2UyUm4rN2FMVE5PNzg3engzZ2FNNjBQUWpualdQSVc0RGdIaS8wT3JlaTNLa09PYi8vZXUwVXNZZW5IU1R6dWZvd3g0YWlMcTFUUTJ4akFxNDZIL2xsMnFMbWJ4VkZucjZmYkVpMHNvM0w0bHBlUmkzc3UyU3d2YjZuSHQ2YWQ0QWIxdGVqbStNUjhJcytNRW1uWk9ieHZselhHTDFLRFdqbWRTeFl0azQwUWEzWk5iVUJ5cm4zMmJLaG9oam1WOSsyNjZuZU5qYUZCc3lhelJuL3ZiSzNhM2Z0SDR0TElXbFB4UGZkejRpODY4WnVEem04UU1EMnFiZkJRV0F2NlE4aGpCSG9kbjk2ZFAvbGoyZjlhMnMvOVZGWGV2VVIrdXZycXdEemcvenpQNlBnRjVYMnN3YWtocjBCMzkxdU0wQ0djaGNyL3RjcjMza0F3WW5MUEhRb2xQSUtZUGFSdXFsTDM1VzkrVTlFZnVhdWtPbEw2allvTTVDOTNPSDgrSFBsKzBKYnNENThyUDJWMENBclAvdjBDaFdaVXphK1g1MC9CUnBiRnY1aitHek53NTEyT2Y1R1lLRVVlOGIxTVR5bTREZmZzV3N6WFVqay9BY0FBQURZbTVuNUNnQ1FtVkhGS3FxcWlnRUFRbFhiLzVDWkFQM2VJTUVBQU9qUmo3emlTVzlZMXMvRGZsZFVyNmpzVmp0UFBxbzFuYzV3M2lBcXdsRjNMUnFmY3NqT21POTBOemNZbmJ3NlRyMWZmM1h2N2p3ZERRK21CUUNBZ2tCYlRFZVdBemRPSmdtQkwzWm9uRVExUkFXQlo4TURhMXd0dHpZS1hOZE5Vc2pNK0doMEFVRVl5SmRtdDhqTDNQTFNEM08vYzd4d2R3Y29jbEowQXdQQWVEVnF4T1pBN0N3RDJUQllYYTdhcDNLZjR0RE5obHd1QTRGbEdaTWRSNnpLaWRFSU9obkVBRDNRMDJzQW5rNXdablM5VlNCY0xBMVQ5Q0tBc05BMSthUnhnMjVabGpIdVNYaEx2RTZYK3NQN3RRTTNhdmxMQ3NOdjN6L2ZQOEhINzJNVURvcE5jbDB6S0dyc1p4dXphSkgxWW5KeFdra1ZCUStlUzVJNGFVVFg2b0dIQTJqZ0VONUxUdnRuSHE4S1crKzlsZUxIcmxqV2o0U2NkY0MvTThYYW9STi80clRNZGJhZEFFWWYrOUZ4cFN4UzJNYllYb0RYL3pUNzBLOWF4YVlhcFVSVkZRQUEzRk5QREtzWkNyem1udE5zZjNpNVBTUEpBajZ2bE1mY1g2eVFmT2ZoWk9SVE5wdnh6VGRhdGNrbUhyLzlWaTBBMU8rSmtUSDNiTnEwbG5LeERNS3VEREc0bUZWZGJBbjFhNmN1Z1JrQWlLaU16MFRTWmc2RktBQURzd0NlR1JiLytQZjlBRzBhYXNCWkJ0TjRXYUVBR1Zsa3FhSTRVYjNORkdab0RZZEtaRGtLS1l4Zmh1TUVUUlRlR1NQV3RkTUlWbURBN2xFNitTSWplcEtobGQ4amU1dHRMdWJZS3VObkQyUlc1cVJYSnd3TTFBd1hYM2xrQUFSQWcyaFhiR3BnVGZONG5VL3gxbE55WUlNbGJmTWtMRm00eVc3cjY1aUx4NnBoVVF5dEhQSGtQNDltbmo0L1NaRStsampuR3F4TVRSMFpBSDQ3cnR1UE5LMmFXLy9uMWlYcTg2TTJITGV2V0R1cm1mOW42cG5HajA5WktZeDRLMGpRcjhaWEt4ZjBsVjRlaUc4Z004ZlFVNjUweGwyQ0xjN0tycWlxcWdnQUFMamU2enFrOVh6VzhwN0tWenkzbzJqb0pocVQ3QTJhOXA3OTltK2RTbk9LN3ZiTUR3Kzl3TTgvN2pzWitXRDh4ajFYMyszcUVka2gxYlFCek5tVVBKUERLcUlhU0JTeVlDeml3QUNRSTZ5d3hVcEhZSVprcEloczlPbDByNWZYdUlFeHVFZFdJc0xJMGk3R2pBZWpVTVZ1U3NPVFBYU25NMlVVazBYNWFjeGVOL1YzTDdscWVNYXNjVm1MN3dldGJTU0xETE1jT2gweFdVR1lhVEtLbGdyajMvejB6ZW1JUnMwVVU2MTQ0NXFqSVNyK28vUWdZNUFBRm04TVZnTGJzWTBFNkxNczArYzZBTGtlR1g5eEpLOFlSR3EvV2xNdDZmM2VXV1IvYldQLzR1NmFjV2gyZ1JVbDdhMkxrNG9OMG8zWUNnWUFQdXVkcnRkbU9HdU9ENnRkYVM5Q3hITGJlVFlYN1hBdVN6cHlSZ0xHTzA5bVU3dE5XcUFzNGVQbCtZQnF6bHlWQjdzR1ZWVVJBQUJnMGhLeFlaV0VUUS92b1I2M0hScXRUcndXYzNoZzllU0Z6djhaODFPb2hDck5QcnpqUytUZjIrQWFyb0dlNVNhdGx5b012bWlaVjB4YmFDV3pMbE1YYXZyZC9XeDhVZFFHckdXSFlkZ1NSQnBIMnlCdUI0UUJBSmFGZ1hSbVVVVkZSQmt6SmNZOFprRTZyWFoyS2VPTTZONG9hOGl6Vk42cHdaRGtEQ2c3MXczalg4TThkTHVySk4xY2g3NmVTVnRqWHY0cXl6cTMvV3V6WmcxY2o0S2hETEF3TnlmaGpmNTFVKzJFYW5paHdWUStTMVZWdENvUW9TZHZaeUVRQmtraENWVTkyNktFSk5GYzBiU21kRTEyTGJSbVFpc2xSR1FqNnpycFgzZWJiVjYydDVsTk9tbm15OG03REFiMkZCSzZhNXREcy81azR4c05JYlYyQVA1S25TOXJzbjB5ZjZHQXZIb3R5OVFPNTNBK0dRZTBtK2drY0ZqQXR3ZmZmRVdFRGVpem1xTlpzYUFpNVZKUkZSVlZEQUFPczg3TGtQTnQ4M28vMjY5V2wxemU5dk5TZm54WURMU0REM2MyKzB6cnYwK1JFRFZYOVNoMGdVSWhBc0xEZWZjUFQrYXVrTU5FODU1Ky9PQzZyYU5xTFQ2ZFJYR3VBK1k1Uyt0d2lheW81VTkzWlpkZ1lOS3lyREFLbHpBSTVSV0VRWWc2MGhZRU5UQ1FEWXZGeXFKdDlHNUU1L1RrdElaNVZKbVpMSmVmK21iYjFzdE1qeGNQb29lR1lyRjJ5OVF3VHZaTFJTZ3ArcnJmTVd0Nm0xbWJuZ0tyYU5UVkUyTmxkd05RUmRRS2duaEQ1OWE2NVphYnRxRnl5d3lETlVXVGsvUnViekFQQUpZWXNySUJBV2puQ3JvbHRXQnRmcXpLOTJvRFpHQVJDSkRaSGJFYjNWbFVYMzhvZnpXcFZ4WTc2L3ZHNTVXb1lOdGd3THJSbDMvUlA1MHgxZUxQYWNBQ3dCRVdLQVlLQjUwT0IzMEF2b3FkTHVkazFxeU5Ca0R1ZGRuTzJlNlA5OHNJMDlxbjNSazIyN2poQktjL1dOL0tNUWFBTmFWbVZad3RkcUdxcWhnRHdGUDFtSzZmWFYwdjZMZzNPNVZHckt3L3pJUTMvbEJ6K1h2L09YaXl4anI1bWRNMUE0UzlsK21lbDJmZGx1ZWVQVXd1ZjRqTDk5NnJNVWdMMVRWSmRlMCt5ZEZEZW1xcG5HdHFNbWN0ZEljN2VGSkpodUtjVlZWbWlYa3ZLMkpWUHEvQzVDem5aRk9ObEx4N09yMWJGU2tzWmpLb1d0THJXbDBTbmV3cmxRa2xWYWFtQi9SM1ovZVVYMXdKdGVrRzVxTDM2emZQaWlUelJwdnRVaCs4ZWF1RDBoam5nY2pLbmZ2NlhMblJKQXpUT2U0S1hxMnMzUldST0x2d2tBeVkwbXZ2QWk4QUFCZ2paNzRMQUNnb0Y3L1UzU0F0bSs5K2QwQ254WENTcS90a2NJTEpOM2pOMm9vZEVPVGJFZlJqOVVLdFFtcm02WjVqNHlKL2JtV3F2YitvYjJ3Z1FMeW93UWtCQUY2cnZkelc1SE15ZnFFQnQ5bmpzazVYKzZ3RG1pYWJaSlRseDVJZkFueWx4OEtPRmZ2NkR3RXFqVFd6STFmM1FsVlZoQUFBMVlJMVRhMlgwd3UrUG5tZ3VlMTcxWDJmY0svSDJyZjArSmY0L21PZWhXQXRIbk0yeE1odFY3N3o4ZEdlcG9YMzRpR0pyM3NCSnRmbTdXZjJpUWsrRVNRN2R5bFZlNS9zOHRRaXVqT2U0RmlxQXNnT3FjU3Nhd2cxZEFxSVFRNzRvUGNqY1YvcHM4R2lnV0pFVmlaMHUyYzF5UFZtdVVwUTRQWTlWL2x5WDBSQ0pNckRPTjhXdWVhNnIza2RyaWFmK3JwbUxqWHZpUGFnZldvcXkyZDRaK2hsV05UKzB4OXhlQlhjWjJhMnV1THdya2w2b1F2eVhUcE45eEJGcWJZZnZZM1A1ZEhVZ2x3a1Y5ODhQTDRVUUVFQW95NkhWTHNGRTdsbU1zaWk2cDU4K1paa1l4SXFoSE1hTmpOOU41dHd5ODh5RVBoWDh3Vk8zcUV5My9mREhkOVRNUUFEV1ZFNkFCNkxQWjVIMGx6ODhwVkFicjMyNjIyMk9VMTYrVWxGOW56bUhabm14OXZaWXhhNDRnMTQvR24ydWhpQjJsZ0FlbzgzZWg5UVZTTm5OcTlKVllNcUJnQ3dOdXZXYUlhWDYyelh0OXBjUFlmWVNCRXZwNzMvNjgvaGh5U0tJeUdIdk5LUk9Ycy92WVl4YXE3VC9YYlZaRko5Y2p5WjMvZzNyMjRsbFRVMG5UMmc4Uk1EUTBNbE5zdld3UGM5UDF4Qk1qZ3JFeU5YcnRIa21wcXFmRDJyU2pmNkdiSUhBejFkMXp3TlRhdm9mVHFaSXBuUysrRTExanRWMm1lNm1wbFRyRFprNWYyblliWTV1dUxiZjBXZzBhYXoxMUxQOUZZWE5lc3l2ZTczcVRscVVmTzhadDBmcys3UTNodnFqL1U3dm5WLzY4U3dleFlLUkE2ZGszVlZydE5FQlp1b0R4SkNYc00vZGRFT1c4MFQxeXV0RGduTkZzZjFpRkFmVHdad2lRUy9HOVRxdFp1Q21YY3V0R2ZXS3o3R2ZmNjFVR3Z0S1ZlQ2J4Y25rK3dMTmhCcXVpOEFudm84dG52azhnS2V3SHo2YlB2VkJ1UWRQRGxkNURSY25NMGVoYjFHbllCYjFUWUhveW9SVmNVQVlDVFhTNVB0dmVIUFRDZjU4bjhwR1Vyb1NXNTlVSXdXZjdkZlh0dzcvVlNxcDkxL2Z2OW5TYk4vS0c5ZmpmSGNicm14V0N3T0Y5MS9iUEdHcytQVFluWkpYbmk1bHFoMnoydjFicGIwZkpXOWp5NUdESFBlNE9GNm5KL0hNelMwNXJLcmN3cmlYcWp3dldqeVVVL1YyM1QxMUpUbTZWR0Q1N2FjT1pCUTlLdnM2cjRYaHNwVHZkK25qNGFaT3RENzRjeFhGZlBQZnMwenJZRysyRTZsTmN6TDErbVIrdjY5dnVpLzZwTzE1cjRldy9kOXkyS1JNNm1qdUw3Y2YxMTEvRjJ6Wm1FNHVieS90VU9lNFFYcTdlbXNlWVpPenB3bmI1ckZ4N01nTTVGNThWVnNmbTVhNG1PYjNvTWxJZlE3MSttbXF1TjRXbHZNUmdldmUvMzIxYTB4MnhtMHZkd3Y4VDdmdXZOc0IyQ0lrSDhnNU8vdVg2OWVGbEtMdHQ2L1c1WVRiNkNHRHFTZ1prS29XQWdBdnJrczIxdmtJY3J2SnFocmFMUXRWMHZBbGFScVZCSmxIVzhIMFRvNHMreUFSNEhtL0FmT25mYWNWVnZsbGExU1ZWVVZBTEx6Zkl4bC9kZTFnNlJhTlBwd2YyKy9jOW03TUFjSDc2S0IrM3FLZWpkNk8yWGJmNzc4ZlJSNUxnNDQrM1ZjR2RsL0hlYjg1bTJtV1VlOXZLL1BjYjFOcmNKNUdqWlZ5VEtxb2xRNnU3M0VaRUxlbEJWUFdmU3JlSG9MbUM3YUd6cThhZnRsV3NvN0RqZHZQUXd3YThGWGtlb2VNbXQ2Mm4zUmxmaThzNnNuMStpUXNMemZvZithNW42c1dWQnI3ZittcnYyVzZxSkxlbDYrOVRDSFhmczU5RzdvS2JyWlA2K3BiZDZYWCsxZGw3dXFxYjJxS0lpVEtYck9temlCWFZneEppMUlWTmVkMEYvWGx3R0ViWnU0TVN6SHUweUhHM3BKamQ1czcrbTJtOHJRbWY3SHJiNGZzek1aUDJQeW02RmprN3lGNFNjeTJ3WWRRL0VlaDV1eFpXcnkyYjdWaUF6azZYZDJtbkVwaXBtUGtoWlIwK1BBQUw3SkxNY2o5VW8xOEFibVNxWWVuN0ZIbUIvdWd2Q3ROMS9PbG5BNVVzNzFjRFhIa3FxeFZweE5ESU8ycXFvcUFDUTROTTRjRHk0WGJDaTdRTDhWell2ek0vT0QzNmNoM0Zrbnh6ZlBONStFc2ovSmo1VHZSV1A2ZExyQlB4UmJ1ZGpHOWFHLzZJdDd3ME4yemV6ci9IWnV3S2JZL3RJQVNlWE9hZVovMkFEQVBtZTQwK1JjTmV2cmZGdmIrV2JPRE0wY1pyZWEwQ1kyano3Y2kxUHZtSmR6ZHpQVGsxUXpuV2N2UTA4UE5KMGwvdFhibVpPcHloUSt5ZVRkeE5QdFhuaFZjUExJZzJraVdwL25tYS9tdmxsVE5VMmlaUExRSkV5LzNBMTF1Tk9YUmFjWXFyVmZiTE91bi9mcVRybmlEeTlsZXBPaHNqd0puNWZHdmxRazJ3QVNlZ0NNWlRDOFcvcVkzV2RleTUydXZ2d1A2YW90anQwY3pGMXF4WlhHMjdGMVZHcEwrWFZvMG52bFVlVWplMXFjRjFQM1NxKytkMXRYYThsNUM1VnFOMFVXRDNibTlOckZoRkNKY0hFQW5xbHMyMnYwcFNyb2labWR1ZlR6SS9KbTlzc2JhOUg2RFFDZ2VnU2UzZmZaekU4d3A2UHhsVjVzc1luUnlFaWlLc1lBY082c0FNdWJqNW5weldVNDdmeS9pNnZHaWx4emUvK0R6NThXSExTYTFMWmZQOEFYOHcxMjNLNmdLNzNMeWZhSXF3MkhmL2d2TC92dnJoYkgvVG1UUDgwZFRvclBjbDI4enV1OS9MYXFYZ1pUTDVWUHZJSnlvSjA4ajJPK3VFRUhXenV1Unp1S3pVbGhWNWk1L1p2SzVwZldjeVhEQW1yNk9kOUpXSnozV1RRZXpxNms2WGsyVUx0SFRNVVVBQnFlOXprbTE1THZCaHBvTGs0eGROblE1MjdZcU5uUE5LY1ROczYydlV3bkJZM21TVUVPbVFCVlhDYVZsVTc5ZXFzN2NJNWZaVWJkZmk2ZVBIZjlyRld5WWN6MnEydEUzODdjNi9zQ0ljblkrQlY5eFlpME5kcFNPZXB2OEFIQUlGa3NkNy9HdzZibVpad3hMQTdwcENMTWJmV3ZxU3o5and2a3FOV0pocXFTM2V6cDBGbEdVZFNYZDhLb1JsMFNONkVBSG5sTTV6Ynl4YWFFYmlxNGtVcFhiMms3MVE3ZUJVN3JtOGkvdkg5VnJBQStlUWpVWjUraHBxcldWTG1ZcEtpcXFpSUFSSDRkYWNNYktqUGwvSDRtZHU2UHFXZWhPMXRadWZWNkdjNVgyM2FYODI3b3pldlY1ZVgxdmZqRkw5Zm5rWnl2Ni82WjRuZFcxOUZFOWFXZU0rcXVPVnNmaXB6M0hDbzNieW1CcjZ1bkIwWnpzWGs2NVlCS1FUTWY0TzlUVHhjSDhsL1NUY2VoQittbHZ6bHNOTU8vNTR3MnMwVkROZUMzNld2ZFVYeDgrOTlPcm9kOFRKMGFpb1ZKS016azdzYXNNMDFOVDlYNVgydkE3MHNIQ3g4SE05bmRPVlB1aHBlWGlwcjNibENSeXFFY2w2Y09OOVcvVlQ4N1V2czJFUmlZL1JZQUljUG0rRlozeHgyVlpVajgzK1AraFFFdnRtVUVHR2t0dzE3N1J5V24wZlNOaWM0bW5lQTN2N0VtLy9lUjk1Sk9QZGlGM0t3emd4WnVKMkJnSnVKSjh4bE1XT2JOSWFmTDJLSFdJYXpCd1JKK2VlenJGdHJ6VnpNMzhDcVZhYndrbHRReHo0MEF2Tjh5b3ZYVnF4MEMrcUU2Z1d1dnFzR21Tc1VHVlZWVk1kaW90K3RtVXZqWmg3Si9mN0wvOXJjWEJYZlMvYTZPbTE3K3Urdlk1SmYwNHMyYnV3LzJ4dnZhNlFYMzVpZTVpNTZYNDMyTy9OWnI1Um1jcjdLa3hKeUVmb1NmZkRqNlpFcllkU0pvbUdFT2Z6NDBIZjlPMmZ6L25ubXBUZEUwaCtvOEZtdU94cS92bC9yVjI2L1ZMTzd1aDM3NGszYXExMTRmT0d2UmpNZDFLM2pMdW1hOWw2V2NzdUNudEIxdngvNjFKSGtqTjN2d3A2QVlaMjJoYUU4bkRSMFZ6UHhJUnExajEzN3VLRDdaVTFCOUpZVjE0ZXplVUZOUHJlYjRlUi9UMGdDeU1NVEljeTFKZHZmNG45QlpmVkxiVmV2RlBmOHNUSHZxcS9xVFRxbk1SdGdWMjVrWkxmeE50MTFoK2tvOVFvL1BDL005ZWFrWFByT3NQNXV6ZzBzZ0l0VnNXeTJGTjhoa05XS0U2emhURUhBQ0lZTUNIb2xNMHpWbmgxV0NKL0EybWYyOHhSeGgvKzRBMDJQbkFjRFZWeGRMRHRoOWNtMVYxU3lXU1pXQ0dxbXFBZ0JmbVBzZlg0NThuSGVsZE4zVjZidUcwdithQk5WdDQzVi9lN2k3bkY0OU0xOGUyYWZ6dno3NzJGcFBQMzY3YVBITHA2Y25HcThmTVZ6NmR2aldidUpkK014d210ckp4RXhqN1d2ZkN3QUEycU9LM3RLSk5qN3pyODRybVdZU2ltUUV1UjdpTVIvTStQUDNlMkhtTWIwV1RaclQzWXN5cGFVVDZnK1FuZ0hsU2tqMW0wRVhKNXNjWmZHODlGYzZQODlNWEdsTi8ybXdZZW96QTlNTWUyME50MlZlT01PR0hycXkzYnl3UzVtYjdacko3cTZCZkhhYmtNaDhMb0taNmYyUnhvZjdyVi8xL043MWM5OWxOeHRXSTZ0SC9hMUYrLzlLMjBlU2hXeVE1QmI5clZjdlZ5WjlFOE5XSTJ0ZFNndi84TFJWVERDdXBXZlduWmZQM3BRYXFrbGUvbFY3emZiTi92T2xzQVVUa0F6K2lFenpKZTNCYXVZSjdFV21HVzhSUjJpL2V3NDR6VDhBQUc3emdzQUloeSszR3JXeVZVeVZLS29hcVNvQTlBTUFNL2QwTTlaWGRidUh5M3QrODdBNC8yY3FHcnd5T2VuTzJPZFBucms3K0tMbjZTOFBwM01RWE03UDJPdWhwTy81Slg4ekZxVmVUcEx6U3kyZldvcnFBVkpWL2N1RVhILzB1YVl5K1NjazBMbW4xQWYvMVorc1BsLzE1MmdubVFKZy9KODVseE5VOWFKT3RrZmpMMDlIUTFCa3VzbER6eDUxT1JxR0JMcHljblptOGxiT1hia0w3UnBWN3RiVmZKM09LaEwzczdPbWYvdDBNUDJubzBrQkZ2UWVNdDFoZlhIT1lvbmFmMlAyczNkWERZajNjTWlwKzhDdU9ic3E2Wm1OM0Jmc2JDbzdzZnhLMkNDcGhWUk0vZC8vbDcydlg0WUxKSDhNQXJHdzRSczFGZ2lRSGRualdad2wwYVQwYnRiZkYrM1Vpdkh4bFpjcVp2TThJMU00SXpEd2dqSDdKM1RpT3ZtWG52TSsxaG1taGI3MDlneTJsS3g5dXB0ajFlR2d0UVljQjk2STdNdWVlckFTMnNDTFZLYnBHcmtUOTRjblJ1eTNXVXp0eTBNa2NFR2h1RldOdFlxcFNocXBxaW9DQUVlMHVSZC9tdWl6ZlpkWFJ3dWNoYWt6U3VCWFBpZW5zMW41bjh2ejgrWnllei9aODdJcis2Q3YrOHZtajl1K3BvZjV6Tkcwb24vVjZWZDVUYy9wYUVTUjNZSXAxVG01MUUzLzh6Qm5zc2thbllNMWw0UTd1bDZlemlsbHowS1hZTG9MandoWXZqeVYrSkZTV2ZSNlpoRFhmeHFXTVkvMzlESUIvVFpjYVBhNHZRNlprMGs5RFExUWxFcFZ2TkFubjk4bFdjM3JxZGZQNG1oNzM2Mzd3S2cvVHlhQUtmWEx5Wm1IdGt2MFpuS21wdjVtbnRFd0ZIb2gwVlV2dUhZQm85SXBkM0Y5NW54OVk2cWpuWmhOeHNiT3ZPOGlZMnpya2dCS2IrN0xMZVRVcmZlN1ZxT3UvRGU3R2NPUVdLczVuY2I4SEdOUlRoZHQ4OXNSbDJ3NzhYL1dpei9pcXpzTHpHVmlzdnViM2lvOTdWbWRzalBZR1FKd0RyNTRyUE9ldUNIbE53TzRoMGZSYmhFMzVQbmhpYTMwZmpLS25SLy9zRmNIby9jWEtac05mZlZYZTFXdGxhcUtRUlZWVmFKaTRNeG92cC96cnBCM0V1Y3Z6L2p5bktMcHBQUDVkLzdoNGlySHZLdlAzdXNISEM3ZWZwcWNCSG1FM3gyV3pqLzlVZi9wLys1aW5xN2VIbjVEMWpDSGMxZVZEMThmWW4wMVJaSGRiT3FCVG5wZnpPTDVDRU9TblhTOTVHQ2lHVHJ3ZVhsNDZmM1NPSjRacHJ2MWFlWkgvWmo4c1Rmd2RoZmQ4NUtJaG03QTFQQktrSkQ1ZHovYS8wUkdHemFJcDd2b3BGckFUbDZnS0poNnlkb0dvTjZYN3RNOVU3QkJDQ2FDMWdCblppVUxBVkhPTmt6dHVmQmJuY25JZytTYXprLzdJQmtiYkJCbWYveHZiODdRSU8wOTFwR1NNZlZlQXpEd053TGp4WFhFcEx1SmF2eXVhNUdLcTRrcEZrVjh1MzcvWHZoOFRYNWpacnYrb3JlaUw0U0lOTUdLZ0RhSDRBcXJON0ZTeWx3QVFFbVJOVGNNbm5qMDh6YjdBeXVoTDdiY3c2T3MxL2dOK2Y3bUg3amV0ekwyM2FOOEUrQTZ0Q09IKzI2dkdxT3FLckdxcXFxS0laV0dybkZPaEJtUVpudHN6dHpwWHduYmkrdmpvVEwrdTI4V3p0UHB3Mll4SDY2NmIzNTl0OGc3dXJvZmRabktSVzQ0ZVZWWGRkVzhUVU14NVhXOXNobFJWSnlWSjdQeWNlSi8wZ3pVN2xQVFpsR3N6NStUMWE1ZTIyVjllbjR3ZEZ3QXBiVXhxM001WGk4TlBlN05URGI3SGM2VGUzSlBUczZjU0l4ckQrMmNPNmtjU21lU2Z3KzFONCtHcXlEZU5TdXg3NjlPUlZtSGxuVEtGR1F6blQxK2s4bGZOOE5NUW9FT25WVlVZcVhmN1YxN2RnMG4rNk1wL3JQM1UxLzdwN08rVnUvd0R0ZHJBYll4OEYwVlY5TDFLbFZsbHJIZkpkRW04L1ZQOWVEV1haMXBYZlVYNGpjV1JDWmZXSmpNeXN2dVpINTN3MS9LaGMyOTk2YVRiaEFvU1MwYXUvMGF5bjBMSTE5S2hDZGcxdG9iZVNFN2g1ODB5UnJxYm1BTTREQUVIbmpVOHpadHgwcm9EZHpEbzFtMkVRY3lmL2NGN3NlSmgvaXBQUzZBcnYvSmZiZFh3N2pUeHo1U3JxcEsxWXhVVlZVVmN2VFRIV2UrbGxKRU0zMWpBS2VIOG9jZmZ2NUMvbng1T2NpUXY1MlBwdVFyajduZlRHYWR6QXUvNE41MkJsYXhiWjNaOTNYZkZUbGFwOFFlcWpySENSREx6VEx0MWZSai9TZkdPZFdiU0JVZnYzNjcxdG9IdEI3bkZGUTY3eGxtUEhQZlZOVGVlZWlpSHBwZnY3Qmh2d3lGbWFhelZoekhXbnFtS1hBMThGUWVIcWd1dUNHSDZYYlBrNmh6WWNoVFU4TTdiR2EvUGdEVHRBNitrK2xPeXk0K28xbjdiTHFLL2tNUHRKZ3owVXpPQUJSckRRQjhRMllsSlZmNEJKYWxXSTR0N0tJcXZLcWFOR0xHamc3SERZMlpaUG56MDNtZXdlL1M2dTJRbGV1YnhWOTN1ZGRDVmZwY2RPR0pTdFNsV0hpR25yWk1Ydkp3WFBYcytjcHZIOXNyR1RXRkgvSkpPRkxSbHJFNjlhMW9CMWI1d0JnYU9GVUFOb2VVMHhLeHNPSmdBNi92S01ZVHhQNVhRVS9nZlFNQWRGVTltSldQRkxZNW1sVXBwV0pRVlZWVkFTUjM1K0haQ2h4dlgxeGM0TVhMemIzTmdlT0h5ZC9JL3NuTU5PblM5YTFwZnMyUGMxWXB1L3NhTWticG9CMXA3VnBrbkg0b0xvY1g2M1dWaXJyVTgrTktINmRWT05QWG1KeUZWOExOdWRhaEx6eHBSa2x4WHZWOVR3ZlozWk5OTjdUcTJOWjc1V1ZZczg0aTFqNjJKci9INmFFcFJ6U2R6aUk3SVZIa2RjdjF3NUFaWnBjVmE2SzNoM2UyaHozd21WRS9XYjk2RS90MzdnK0QrZTl2VVpSNEVwSDUyZll0RFYweXVrZXp3dERVY0pqTU9DeUhNNll6U3U3aFlEVU5mM1kyM1E5VldjVHJpejAzNmE2dkt2ZUpRSVRla0dYQXh2ZzJrdnpMdXErd0xmL3VTOXQ0M3FLN3VKKy9kdjVRSDVHYStuYWZuM0NUUzh2VGovaG9PMDhVM1VoNm1keENDdnNydldIcW5helByclNpT1FxWURaT052Y3dKQjRMaHhDdzVBTVFGamNGWkVhSHRFZGxEanJITVV0VVBNSmtxdkExZzA5TXYwaFU3MUZYNjNNKzBuMWpPV3RBcHV2bDFCLzVaZkZ1UG9qckhMOE5lZmpJQ3RBV3IxWGRuTXFzMVlETGhxaStwL0FBWlU0V3ZkOERpb3d4WlhuYmN3WGY3VWtOZVIwTmZ1ZFRmdjB1Ly9OK3E3VmNOU2tkWTY5WUdHQXNEelBsR0dka0ExUEVTQ3dDNC9uSjFVb3BRcFVwMm04eWtxN1ZFNlhBbENOS3JXUUljdXFNQWg1YUVWN2RVaWVuYkdQcUtWbUw2bGtOLzBZb0Y5SWFWUUowOW9vOWZMeDVBaE9nOEFJN2JJNWNseXFGSUlHa1VyOHAzVXduamp6Si8ydjM3MzgyTEdUb1IrYllzbURXWFcxbThkK2tyVHVKSVlFVHdGTDc0eUxLbHpwallnZThYQ3ZRZVdudXJBeVNmdDBqNXFuOWJ6WTRlM3dNNTltcFVCOTZlUHIwcDB0ellpK2Jpd3p0cGpOa0ZJWGVKZFlaMmdIWmR1NjBYL3c0RklLM0JsdGJodlIveCtNNzNOb3ZENFQrb3JMd0ZLaXJzdm9DbjdkTzhscWMzMmQ4L01pUzczeStMTm5XeVVyVFkvWHhlSGwwaXZ2RmI5Wk4yd1hZZzV6dVFSMGxCa0xkdWkvSGZiV0RzOURqeWREOUptN2xkWXRwT21ydk8rd3o5TXltL0o5N1J6ZmlQakp0L1VRUzc3Kys3VkIzd0ZzM3VKNis5ZUhvWC93QU81RVNaSXVDTkFCMHdtUTR5Mks4bEZkWTU1VEFpa0pPL2ViMjJ5ZW1lS09QeUllcFRYR2xqYUdrQUhMZmY1MmUzekc1K3pIN2VSbXNvaVBFREhNajU4a3JnR2dDMGxLOUtTRERMUTYvakdhTGtkVGRqRGw0bjQ0elBBdGQ0UkphU0d2NmNkYUVCN0s1RERYMVkxQzQrbHpzVjVvaGJZTzRBMngzRjB0c0xrTUpIejk4ODNzTXR6Y0ZNbC9mZVA5bmtrdVFIVGxWdVVXZm03R2s2dlB2VlgvNzdweCsvL3ZMTHAvMGZzSUtuSnduNVB2M3pmMWorQXd5UGUwRTJiMEFiMXZFM3IvUW9CcGo3RG5DNndJM2ovbUUxZ0RQV2l3SGVORUUvOVBxaTBKMStONVp0QVlGRmR2dDhuOUc0YUtlb1VkbXU1dnU1My9TNFd5K3JDeGkzeTNQS00wSE11TG42ZE05SEU4eXUxN2tXL0pWVVFYdWJ2c3h4d0hMMTF2b0J0dHc0RHZYaCt3MlFEVmpXNmNPdWcvYnNvTWtNMXdKa3h3Tkc3MlNyUWYyNnJEQjJzUEN2NzlieGFEMWNBTWlmclNyb25sczNUWTkvVFJ4eUFoeXIzejlQWWJWbTlXYjBtL3ZXK3JMa1NONE9qMjZLeEdzYTF1ZFRoVUtJelR2ODFmcnkraU9UaXRVc0ZHOE16UHRaL2krLy91V3o2MndGeXQxN3ZIdXZubktqdFdnWEZKKy8rcFdwMnNZQnozSDVrM0pvTEpXOC9QVE00WXpGaE5DTXpaVGd2T0R5NWIzNngwZ3hrL2xmWlduWnh5WXZxVnpsMEw3WEovNC9OM0RMQ2ZTcVg4ZENNb2VITm96K1pCQzJyN0FzZVNwL2dEMVBFbHdqd01Kblh6V2ZydExhOWpxNmtBYmhqejZKUndGWTUxeTMvQmJxRE0xeS9hYzd6bGNXM0tMZlZYUndSaC9aNy9sU05vLzE0Mkg4QUp0YnNYQzVFSEJPdm1tSlM5MWtQV0VJdW5Xa3dyZmprN1U3ZEkrMHZYWUoxWVE5czRaaDJPZWYrU1JiN3pjTC8ydHB0S3AxdmN1ZnNWUGtwbnUzYU8vaWJYMGVBTFBKTWFxTkVDNXZnVW1sSVl2ekltZ3AvYkVrZXNyeDZRa1ZxV24zN3VtN1J4Y0dOQnJyV2habHpod3hycTlWUHVvMDJaa2cvaC82Zi9zQTdJWUZQR242OWRzMVIveHVTNDN3M1c0MjAzSjNucVA4bU1kandiZ3diek50ZUh2NlFPZC9VSnh0ZmZqbXhDTE9ldjVwMXZ0ZkF5YmliTjdTYy84Ny9QeXZYZjBnNzA5QXdmeUcxeUlITndEa3NvdDRlTlRZOXNPejZCYkdaelFYTmltOEE0em1SZ2hmRWpwK2pSaVoybVBPSDBnenZZK1Z6SEhtdVdvL1A3L2dzTUpQdFY3cjIzbDhaVUU3VVBQcXFlanJIK3R2WnU2VG5sNm5DeHA3UG96c29hTmgrejM4QytVbHYyS1lORmQ5TlRCc1A0VCtkdE9Yei9LbnVoOEF3RHBtMFhheTl0cUg0M2puY1lHUFR5QnpBUUw3QnFDUGJ6N2ZnYXVGMlJrbXI2QWFWREVBQUxod2JWNEd3R1dXVmh4UG5Ba2I3dUc1M3h2bzVmUHQ2ZmZGdmNQUHpxV29HVStJWjRmRStvakhWaXBYcUZCdy9ISktLQjVBd2ZmZWZqN3Z4dFdxUExaSnhWNHAyTmtyejE1MzJFYkQ1Z3hxNlVLWXB4OXd2WnhiMy80OHV3S3hVa1dnWW5EN1UwMlFkODZYbzdhSzJKU2ZwQVNTZ1dFYXVhZlg5dFRoWUE5WUFQeVdYS09obXBHUmtXSmtHdnZnOFY2cG5HZGVMZmJuNUxGTVVsY0JRR3RpN3IxUHBlekNZaTRZQVRhNloxcmlEdVBWS0ZDdzZKdytDTlFIZlJQRTQva3dMVmVuWmF4Sk5HTnByR3JMWlpCMllCUUdCb0EyTy8rL3lsV3FQdlh1L3AxNmlQYittaS9mVHpBeDFiVWF2dE96Zlh1dldGSC9ybzljYWY3SVlOVnZ5TVpBWUpzL3JEVURTTDRBOWpxMnA3ZUQzb050bDZlZHZaOFl0ZGR4ZHR6RWVJMTR1L2ZUeFRUMjNwNW9md0FBQUlBdEpzNWM0RHJ0NXJERlpGYUphcVJHR0FBeUl0LzBld0tBbnNnQUVUUVhTbHRvcStqL3Y3L1hvWDB6dktiR0o2OWoyWmMvMWJLS3AwdUp0R3A1OHdicEI3cmk3YXlyS0lGbmFhbVIyM1BvOGJ5Y2R1VHErREozT1I4OTNWajd1NXZnOWFnNzY5N1QwaUsxSkVtS01jWVhMK0xZTFF4R0ZoV3BhS3NXSUtPU2thaVV0Z0JSa01uQXp2emVTS2ljL1psSDVQc0xXZW5HU1BBSXd3NVpjaGVXMVlBNGFubGp6VUFFUUFHTkZFbFJsRXE4cnJidFFnbGpWbXhwSVVYdTVyR2JMSnlPMWpoWU94MFlTbkhUVWRpMFFkc1Vza0xKb2xBUjZKTUVkcWdJQUdnWlVKRGVma3ZLMnR6ZTNieTBVY1pGOHpLWVBrMWFORkJwNFpKbDZILzFQZHVsTVY0Q1BtZUJEUURJVWY2STVJYUdHcTJMbVRNVlRNVHljYkxjZ2hRREJqRDBBQWNBbElLTi9CZmVtdk1OUThlTDR5cHVaUjg5N2dCamp4VlVlTThEZk9GcVJnanZtL1R2ckdrM01YQ0FKWW9oRHFULzNsdkJmZkFKVWtRcFRNdTNxWkVzZklxVDlXeWZhbndTcStYcXZJdW4rRVh6RHJBNU1nTGUwWFVCZjYvMTc2V1JvUUY2NE1nZU5TMXpBWWIrUVRvWFNzNFkvWDVtRGtwenhlNVZ6bzQ0YTBEcTNFN2NYN0ZlNGdHRW92Y3Y2OHVqTi9GU3g3dm5kSDlubVI5Z1g4aWh2N1FEUnZsb2I5dEFweEYwSXNpN3ZRcVk4ZDFOanhsMTFvYnk4ZndnVU9jNmtsSE4zejlTUmZBZDlCdXF1Sy9ZdGxRQUJMdTlZL3JYdW1iWTdlMk51dHpQcXlkalhpYmJNZDBnWXlFNnVrZFh0RjMwYzJjOW9CTTNZUXpubDNzZk1FMjUwRXZPT011amYzMzUxV0xCWWwwWkFrb2JxdUdZOVNjQXJKNFgyMk4rbnR2cjl0elpidWJPSjhRUGtOOVU0U0dCZnNkVGRncnJ0RUVUTmJCRkROVkhWdDM3MVZuRS9Kdk43cnpVMXpPQVNEd1U2cTIwQXBTZUYwL2UrU3hPcjlmeitINVI0OFgrQTR4ZEtzd2VVSzRsSWd4OUs2SWk0QUFKd1F0NTRDa3hwbzYvbHpPMzc5ZS96NFBacEZhbjBXK3dBYnlhRjgvajdaUzZSWGR2UjJ5KzhnUElseExjSjVMRGsra1RqWjBnVUNnVWpqT2grK0xsZ2VkMlBDY256dmY3RlEraThiUG1TVEFDbkthWFQyOUxWc3RlZFBwMGFpbUo1QTl3NUxWVStLMFRxSUtHNnFUK0dZdm1va2FLbnFoTTFEZGRlM0tZcUw5bm03ZC8zR25lZ3RlbVlHek0vMkdyYXNSbmFPUC9NT1M2alk5TFBXYk1ZYmY4WnZJNk9qRi9nRzB6aEdzQW80d1Y2OHBuWlNBdEU3YkVqbEJ1V1k3NkF3WmFGWFkwL1k4VjM3NmFjV0QxajgvRVpmbElSZlk2V3dIU09zYnpsdzN3dTdXUXlkK1VpdUhKckJnc1R5dXd1S0NFSjBZeHZnRUFqbDJkMXd1Y3dWSTlHazlWVlF4cFZWVUJBQUF1Y2FJM2s4aUF3K09IdHorMzlwSVczdElGUzl3dGFaU2F0WG90bm0xYmg3cm9Wc3V2R3VpcHBzTytOZng0LzhlbTI3UFBKTFZsYUd5Q1RtQ0VpaEdEMXJIc3doUlZhekJNbDhYbUs4VllsUkJUVEpSY0daYTVEdnMxMG1CTVNwS1VPQXhSWklON25QMDJNRkFVai83Um8vYkxhWjdVSTArdVdVQ1hCcFFlNGVrL1g2c3FZMHBFaFNOWDFhckdaQmtLVnBxQVNtZGtVSUlBc2NxVkRIUXMzSm9FMW9WWnZaYVhxSUpjWGNFS3lWUTBqYk1TTnpteUVzajRxT2dhMTNiMkVGdElFaUFUVWxyNit4MHFEZ0JJQnVNQjRhUTFIUkkvYm4ra3ZJNWt0dXNjS2VKYmVzVDk3NzI4YmZUMlIwU2MvQTltdlE1ZkdoWEZwQWdHVnN5ckEwOW5aMU1BQUFBS0FnQUFBQUFBemIyMS9RUUFBQUN6S2RaR2lqazdPejFHUS85VC8wLy9UZjlVLzB6L1IvOCsvem4vUHY4YS94WTZNVFU0T0VGQVRFZFJVanc3UEV4UVRFcE1TRVZJUzAxTFFUMUdTRTVOLzJjN1JrdE5UbEZMVTFSU1ZQOWovMUQvVS85WS8wci9VLzlQLzA4N09UMDhQRDg3U1VGQy95My9HdjhSL3pQL1AvOUwvMVgvU1A5SS96Ly9VUDlSLzEwOFBVcFJVLzk1U2tkSlJVWkhWblJ1dldPR0hGd2kxSnR1cyszSnozK0FzZm1Rb0ovQVM3L09GeXJ1UXVYTnlZNDc2RmpGRkRybmpyNXlNcjdxM3lzeElSeEorRFpqQjR4KzJUTm1wSkw1eVV4dk0wVUJyaXFNRDJBc015U29QZUFhdi9hS2JHaTlFY3RXRnlwMFJQWm9FYjVDUE5wNVRMcDBTbDhIZFBDOWtkUUJuSUpoSFRYZWpjVjhlMmsyNmFNQ3JmTHFCeGliVitHYVFBcm1ycVhtcXF2aVpyRmhnV1N4UkFQUmNqZG1jdjhDTmxUT0hXcGN2Zlg1TkFCOG9vMHpLdVFvczU0MGo0NG9rYk1vNVBvS3lPZFYrQXNKSmkrOU1PTWZyWlYxVHVBaDZZYTdGclJLMFZFM2MxOHRHUjQxc0QyVHp4OGt2Y29BbEtaNUc4RWVaZEtmWjNPTklQdjV2SDZBc1VlU0Nvc0hWb1JKZXhwWHRlSW5yK0ZNZkQ2WFBWV1AyejFnTVVhUGJDZldkWlBuaXBaSTJ2bnJqUml4K1g5NGhQVS9BM1NLMlhueGNFNzVxVFhEUE1UUFBvRFpWSGdiZ0JYdU1pVFBGVytkUFg2dk1MSzJZQmNKZ3pCd1Q2VzFQbk91T0lxRHNMdk5Hdm05Tm0rL3g4M1B2NDZiV3dhYTJuV1hYeXMvQlhUTkVMUnV4ZmJIRHZBMHBTbkxrQ2lDcFovRE96K3RuRDcxMWJ1bmpVWVBrZU9yWGU0WWR5ZVJCMzErLzArdUtDZ0JXNXpUc3hWUGJGSU5xaW9BZ0JOOGNpL3QxUjc5MUIvRWplRSs3Yjg3MmpEMzJWdi9JVHR6S2xyLy8vbDcxK3VmMkl1aUtGQUtFdnprTGxUaGhmeXZ5RUoxMkRZdlgweDdMMEtZVmNja3VYT3E0TWI3dnIycTdyKzhuR2Vwak9QTE5BR2dUZHFlbjM5OHpXTXFMMXdld3gzV09iRCtuK1AxUkJHSVAxWlhVcTJtZFI5clZ1c0hhVzRFVUpDVjBGQUFwNC9xS25mV3Y3NUdVMmZvQnBqcGwrNW1lZzVmdXR6ek9QemVkMldlQlBMNVVLT21xbnBtL1hKaWRpM3FmNFozRDM3b2MzMGcrVmVkYWI0bVZoM2x6czRvM210R3B1VEszTXZBZFhDUlFEbkdObFR5T0RFekxkbzE1L1ZNTFl0UFJ0SFp4eFFhRzBvNzBkakhpTEtWd2E0akJPdXRjMTdoblRMNVl4VWMwTTc1b1FZQ2tLWmxBTDZLVFpkWHhyc0EwNG9rc1ZaL2ZwYlhaM05JY1JEeHVDZi9Ec0JkYVhCUmRDMHp6MXhGSCtzNkViQkpWVlVWQUdEbTltKy9HWHRZZDVqdDRYYTBicTh5YkJZOVBaM3M1OGdOZzFMUDRYMUFmeDY3aDduZkVGYjhoRWNuSnJGbGNNVUgwdkhMYlgvNmo4K2EzVGhzUXZoMFVkL3plZWJQZXB5VHgvTmpNWFA2WkpZcWgveFVYbFJQL0V2V3FhenJaN09HWDUyZkNjQUNVRTJkbDV0UjF0N2ZMSHdNWS9vQURlUTVteFZnN0htck9iSmxGY01BQS9NYnhnbEZzMy9UWFVOaHhXa1B6bi9QM0EyOGU0a28rOGRKYTFxN0wxK1AvMi9yYW1pMjZmem0rNC9VeFFWUFhuMHFtcG84ZVYvRUh0YjViZjEzT0VuTjg1cEN1K3ZxWXE3anUrNytNQXZuR0lYRWxmaE0zeElqelRZNkMrR2NpSFBwZ1JOTFhYYU9IZ1pHUzVPdmJOdmQrV2VuTGZkZkluUDh0VXI5UjdmYXQ5MHlKcWJhSXZSeWJCRDhuelpyZDRKbXpXbGMyS0krYXBYOUViOG5TTFp4aU9YNjQ1M3RtV3hLdUFsUjNwNXcveWVYajNJMmV1L3dpQVkrWTQ5dXNmcGZMZ0haeC9uVm43U0JQazZmT1ZYNWhCc1lvcXFxWWdDb08rc1o3M3lGTmt0Wlk5dWJjRHppL1A0WTJsTGJydllsNXJ0Q3hUVkZ6NFQyOSthNCt3NWtxaXBUbXBlOTVTanJLN2tVMEx6N1RqQ2V6OGRuL2pUbnZCdUxEKzA1dWlacUVaUXBhb00rL1prbUpvaytZbHNMNCtwZlpvY0t0VHB2ek5QMng4MGw3UnQ4UHNvMUJtUkVzbFl2RXVydFNsM3pkV0RCd3FvU1FDSHlocUZLMTVyUVBTUmM5d0J6dXFmNE93dnplTThaMHQwV2xmSEdEOVVEZm1vd25vMjl0TE5xbWFWcmZyZkgrYkx0MDNubkFUeExWZGRtS2syNE5IWXpBOElHSWFVQUNyZFhlc0RzbStZcElVdUtRUXZBaVlPeHcvV1dMcW1ZNk92NTNHZjlHaHIrVzdDWUpQbno1N1ZhWWFXRHprZml0eXRkTEVLVU5IV25DL1VpTFN4UFhBRWVBSDRhZGU0VjhUdFBjaDB3bkZhcCtkWEdIWnplVEVWQmJ1Wk42RjhHTzhvandla2VVY0FOMXpsd240Z1I3emsxYXB4d2wyQlZOYWdxQUtpNTJQd3Z3M2xiMDVqY1hOZzR2QmhwUEwvdlNTcmhPeExjRUtYalVVYzd2Y3ZoTEZya1VaZXl3SXJ2eitVeGJHa0xsWXdyOFZKYVg5Yml3em52emlldDQrR1A2OXNlVG1zUVZQV29xZXdpOHhPYURpNW5uOUFPTHY3N2JBVUFKMURnbWM1VnZIMjRuQ2d1TDZiQUs3SjdpMFRHQXJucHp6cU9yRXFnNisyQnhKaUNvYXFtdXJKcjExTVhlNzBuVTF6MjUzWGRPVjBqZmVWbUluTlJUUDdvNnpoTFFOSnNTcUdtcHprZnhXUEcrVGorcmxsV3VtZlpBMmZMTDRNOVQ2enAzQ2ZuNjdWcmhya3pPMDRaR3dPSWRaamMvV1NtMkMxZDBaU0xvb2UxZEh1dFExOU1xS2hoV3dtenl5alg5RE5uZ3ZyU3VOTDliMGs5Qk5mblZhbzVYLzc2MkRmelZ0TGRVdW85U21QbTk5SzR2VGxwUXdJZ0FENXFkZUN6alR2VjV5STFLUEJwcGZRcmNrODJVaEVreklmUXhjRG4vN2hXLzlBMnh2bjUxMnNZNXB6QnhZaHpjc3JGOW94cXBKRXFCZ0JWLzIzT3BKM3RsUk9yNWt1NFF4Z1duRHpMMEd3YklqT00rOGxOZTNXNjQrZXR5ZjdTOXgvZC91cnZsanlMZm5qM2xUcHlWZDdSNGR2cmNlMHM1dEJua3hyZWY2RWJLdmZrMkgxcTNmM1Y1SWdHd05DdnZQOEx6dU5nWEdhMUIxbXdtMTBlN2p3RmlkNUp1RDZBcDJlYXpvRXpKTHRpY1hLSW9qeE5kMzhWeWVqQW1rb1NQcjg5NjA1MXRjbSswUTA4eVFOcVRRMjdoMW45RDZmUHk4elVYRlF4TURjbWZIbGZkYnhtSFVuOTZrYW16ZTZ2UEplckhOSDB4SjFCYlU0YU1XbEpFRWo4aXU1TGhndVhUYmFnbmorZHYrN29kOWFaMllyNUEyUEFCbjhoQVlOOGJzS3RkcHMxMGxZV3BrWTN5Rm9NQ0N4NGZRL090dy9aeTAyYzlFMnVpczY2UERsLzUydTBMaERjRUFCZW12WEVhMWFyZE04UDdpRVE2aWxYNDUvSlQrcmUwSUNqRXZjRkFHQWJPVDdZbkNxZVZOVldGUUFnVjRuajV0cFdEYmthM0ZoZzduUUZkd0NlTFg1WVZyTnNuNGVtT0xPVU84TFZXREpPVmk3bXVkUGwxZFVCd3E0MkwzMjkzcSsvZngwZXIvUDM5dCtkckFVem5PQ1hFSCt5UDFmVDVFbHVvV2VTQnM1Y1Y3MzU4TXpqa3VUM2JnV2FVbFlEL3MvTTdyUGs2RkVwbWhSeFdVYmk5a28rT0RmNE5hdlV6Wk5kU2JYZytMbzZzb3FkY1NGb2dPeHVGb0dhdlhCZ3NsWXh4MW5NMnlmRGR0eExQeVRUci9NUG94YUVIVzlzY2JxSlptNllodk5VdHR5YUJFZ3Q3M3M2ZDhGa2toRnM3bkQ3NWU1MndpSGFybHNBODc0ZkR6aGROOHRJaHFDZjA5LzRPMDJYK0ZmYm41YUtDY3dNWm5wTkVnbSt6NW9WYjZuSHNOeDhQZHVkWG9WTFg0ekFkQVVnQWIzYVlVYjlRZHdLc1dnK2svMXVtUU9RL1EwUkFINnFUZnp6VUwwWkwvVU1JN0ZjMm1YRW4rTTV5WGlnQVI4Uk1zQkY4WFVyK3VFc01sL1E2YllSejZOcXNIVVlEQ3FxR2xRTUFOTDk5TlV5bmFDdGV1NW1yeXcvL1o5eWRESUFSTjdMWE8ydzMwV3pMeW8xRG1yM1l2WG5GNUhRWjFCKzI1NE01OUwxOHo3Zkx1cml1ZWhzOUhXWmZGUHZvejQzbFRWRDBrMVYxY3c5ZEZkcnMzSllpMlRzWEJMd2dEcGhxTko4OGZ0NnFYVkFubE0xeHlITktqNW5WcjV2MllXNmQrT1BRRGxkTDRpaDZqNmRONnlUVkM0RDVVRktsU3FacnZWVXN5ZEx4ZE52TlhNWGk2cjFzOHByc1dhY1BmQ1FkU3FwKzVtVDIzK3R0QTA4VE1NMG5OTkZNUitJRTY1RXFTV3FBRHdBQjBwb1ZDTEc4T2N2L0w3Z0JuLzVWUWkxUFJNQlNjaklMRWc1VmIxdmZBTmI0elNkbjk1U2x0MkRDM21yYmR3S3JuWWlJZnNqdUhhQkVESU4wT1psSndZakFnNEEzc29kN1VmakxmWG5VMjhBcTE2bmZzMjhGMDk2MHlMbEFtODNjK1ZVNVdJWXpocFVOV29WQXdCRWF1OFhCMHVwT3IrNU8rMHNheDliV2UyMlplWEZ4ak5yOWx5ZFAzVjgyVCt5NEtuVDNYdmJMdEJ6SUcvWGhoaEp4ajEzK2V0eFRjTnhYZW5wWXNoTmRXWG5YL2RPQS85ZjB4aWx2Y3FhTys2ckRtNS9lUTB3ekRMbVVGa0RIWExtSW1kbkZUZlo1R1pvMGYzL3FzejA3dnVkcjZIcHRRajhGdEFhcEp5cGU4Sks3dC9uYS9EWjlHWEtJN0xKeG5YaVNaRmtOUlNvWXEwMlc4d3RsS3pmMWtkblpaMGZzQlVrbWN5K2wwb1Bud0JyK3c2ZUFhMENGQmR4ZVlsZjdGbGNiOThCU2NJMlNJMGlScmtha2dyK1B5elgrT3RySytXajFrNE8zMzBoNVF1L2lMbDA3UGZ1NEd0MDhEMDZiS29HTzVYb0dnd0F5QzlHRlQ4QUFBRG9PZVVDd1ZRRzhqZXd0Qm5Ib1lBQW5zb3R3V1g2ZTFmYU1BNVBQdFZxNWNjV1c1QitWM0U0U2JrRjVCa3V1OVkyT0ZWc1ZURnBWVlZSU2dFQVhITnpOcldwNmUwaDc5VytkUEkzajUvZlQxM2IrTHI3cWQxbXZuNzJYRll6aGxwTUM5bms1MlJZMVdldXAzVXVhWFBqbWFPeXI3YkQ0NWVxOG1aWjdtYlFITWVjMi9FbC85VzJwdVRUdjVqRlYyZFdQdFE4b0NpWGNrL1YxQjBwQi9vNXlvZnl6RVNaczZLazZtUkdFVitRNW9UMU9SUjdlWUhZcW5lQXFzT290cWVoWWFpNnRFYnhXcDlNeG5lWmdpUmJlc2gwWmVWVnhhTjUxSmxMRnJPVlZQY3dvLzZkekwxUGFyb0dUZUtGOFJUTkdYR1VhckpUY0tYY1ZGZFNSRU5UQUpBVTFtTmJFRU1FRkF3STJ3WnBDV0tTSE1DRlM5SzN6QzdLMERWRFgzTjdBd3BTS2VoOTEvNEM1T1lWK011VFV5UmZ2QXdQTXNnRytURUdtYlFUZ3hBZy9Ramg2RElCTUUvT1d4UWV1NVhrSllnREVtWm9yV0s0VGE0TkJzQnRZQjl4eHJISVc3RG5WTVV3TE1QU1FRMEdWWU1DQUxIa3BkbWZIT1RvdXd1TGgrOGY5dDYvaisyNVAxeDEvanhxVGIvclpLaFl0YTE1UFhvMG8vWkovdjc4QVVyRWtCMFpocFdUMmVYWm1kMFZiTHRIQnFQZ2FHMFhpUmd4TkVhc05vdEpYb3F4Z0FKaEV1RlNvQUxIU1RFeGR0bEdTc21oSllrQ2JLOWVRNFBOV3JnSnJhU2JjcDNrSElCa3lhWHBUTkxGUGVjeWw2NkVZV3pBTEFFTThwTkhrZ3BlZUZHUUxWelhCUVpKa3JUSXRuUlRUUklyZmNKZ3hMK0toQzFKZ0xTWW9SR1dHWGJSSWFmelBnTjhWQnQvVlNNcWZjNkJwRktGUlV2cENQbHNpWGFzdjV3NXZjR25ZV0ZhQ25GOHJjYkszMGVSbWN0SlplMnpxc0o0bWtVcFBqZ0VBTGFaemFJbDIwcDBmbkJtdVp2WkRKeHpFWUhlRDg2WTk2ekltak52OU1mRGkrTnRIcW9BQUd0VlZjVGo0d1NKYWxCVkVRQS9qYld6WHFMZnZ1M2dhc3E5QW16K2xITXFFcVplOTVWV05vc29DWGRyNkxOYlRkUXdzMWdkdXkxdFdVczROc1pBS1F4TUVDSWpsNFJYb3lBSUpFVG1rSlJia1FSMldRM0t6QUExaTA5YXNKaWN0SXdzRklKWWJEZUJyVkFaR1lVQ0VGNUJHSXdCQ1ZsZ1d3ckwxdkthcXUvbERSdDBXajF6RWtsbnR4VkU0cElrQVNRZklVbUpoQVFvSWdEblBlUzdxMnB3NjZuZmhKdTI5SDBOV1IyUkFmbXBtL2dXNHpsODYxQkZDbGtQSmFSVzBQUytmUzhBMlRUY01jYUZKdTB0cU1ZVW4wSGFNUWlHRHdHOXM4QzZYVElhaG9WMUdON1ZxczhLd0Vjd0FWQnNYbStIaHNnVnNnRGpKdmFtYllwZWFkNklQd0RqRUFxdVFKSmR4eC9aVUNVQkptWm9VeTNjSEJVUkdTRHM5bGo0RGRsRUpjSUcyUVFCWkdaM0xiN1RhYmlwM2RGNFQ3Y3ozc3I4OFExS0hBa1ZWc3pMWmtDemlBblkxVW9mNWNzSnJGZG1HcGNrQk5STkFMUmEwMUNZTzlGL1drZFdPYm1kNkE0ZkI0eGNWV2hlUFcyZWFUQU4wR3kxdDRnOUpqUlJwTUtCSUFyWmFiSVpSQWpHeHpvSWJHTEh1b20xNVFzenNidTJxRGU4ZVI3QTBBSXJ1RHRBY0NlQ24rcDZqYVpaNEdXQkZLSm1qUzRNcnFhN3FxZU80eEkrazY3bi9BQjBaa2RDT3F2aVM0Uy9xZDIxV0tlSDV0N0orZmV0RE1tbXBPUjZ4d1lyRGR5TjdpQkt5cVRDSVN5TncwYitTRTgrazZOTmNqNS9BMnhxUFdydnAzdHlwbVlOYTRpcnBmQS80SmRLTWhydlNqUjE5ZFZVM2ZoU0ViUnlVa1FHb3BhSmdjSlcxbVBDU0doTWIzeTNSVEhZR05NMVlmN3EwcGNZdEc3VEhqVTJYUEMySy9mdzJEakFmNEMyTUE2dkNRdys1WWl0MENhS0NCUEVqTWhHbUlob2pCQUNnK04yb3hhQ3FFUWswazV1U1JFZDIreDZ5UnFOQU1TaTRjL0tlWDhuV1MyYVAxOVcvN1RzN3dCdHkwZUhDbGpTak0rWW5VNmdkeW01VlhGTDdtZVAvOVNYMnJVK2QxUnpMSnNQbXczYVp3TExxa0IrZTlkL2dUT29PREFPLy8wMTZHemNlckdHdVdtb1dzR29OdVFQK2p0QTFSQUIvUUJXdEhmdWRhVWtzV0k1Yjk0ODlYcjk2RFAya2FMbDNINy9sODZwdlRkMW55Y1FSdkx6UDk4SDJXeW5zcmhYZlBFMUJGUmUzM0xrdU1LcDlvcnRhdVMrMGl5NEE5VHNQUFpmQmhSNzM3R1h6dE5Ycm1KUlA1TkRtUlpmL3l0K096NGxkVEJmbi8vZmVUbEhmdFpreHlsYkRyOFZpdkdaT3ZkdGdUeG5iTmZMMlpqekdxUm1SN3FWVjdRUzE3VnlLOTJnZTMwS2Y0QnRyZWhVUFlIemxvKzZ2Q21yemI1Ky9QVG41WG5jcVFjZlRuNHplM2NsMGJyRWtlSDFwK3Q3VjhwSWY0aDk4eU5qdk0vN0NobGFHL1JtcUpvdkR3QmtXbThkc3ErVzRTbDFtZUV4ZXhSL2dDeUxFSzRDL091a3FDN3pkTnVQOW1tVkZ1a25EZnFQK21jemxmdjV2ek9CUEN0WE05K1VhWi9FYkFHVVFrY0ZYVzA5L093VGFlRG81M2J5NUVXSWtKVktWNC9KaGhQODg2dkxJd0wrSi9OTWZwNHpldnQzRFR0TGR6cmJYcGd2RTAwWnN1ZkhBTFJDNVJwSHJabDhLNVZ0a1h1N2dQL1lhVmV4WGVINXFPRjlQbEU0OHk5UENlWDd5N2pkd0xQbmw0Wi9jMlU5Q2NLU3V6ZWhiM3l3YVVpYUM0Uk81WmFkdlhGQWhGYjlBZjIybGIvVDE5Y093VjRkRFVyRzc5TlRtT0RycmZQaDUyTlI4MlJzYmprOFhianZlNzJmUEdmMlhCQ0ZRZ3JmL3ZtanB4dzM1LytUWkV1ZW5HQ1RPUUtVWXJ0WHc2bHhoTTdrOFByMDZ1blVGWnM0bmRaTXJEWHV1RTJXeDcvK3dJZ3NyVjNzS1gvVmpzV1h2MTRtY3Y2NHJYelZ6OXRuemQvekd5SHk0QTJQeUsvUHo2K0JUM2t2cGlGU2hlY2pCb1IrdmNQRDMvY0NPLzBhRjAvbS9mRVk3L1M3OXNvc3JOVjcwTE81c251UjFhK1lZV1Y5dDhuWHVhNXpEeS81OG9QTDYwOWxsdjdSeW8yTUZZYi9LM3gvalQ4RWdUZnZaeVorYkZDRVhuZURSb1lxRk52aEhseEJtZGtiaHkrN0RGbUZlazJyTFFUUjZQeWcvN3ovZnVlY2M4Ny8vLy8vL3pubmZQLysvZnYzNzEvbkhPbCs4YUw1cXkvKzcyc2p2bjEvLy85WE9ZeE9PMURUT3FpQzZKSDZ0bWhLazZYOEFOVUdjZlM5a213NExOVmJZekdSVHJuWi9mLzYxZ2F2L015bjlNWEx0L3ZNMS83dHRyenZySEZnR1ZuUHIvVDRiVXhraWkydFI3aWVzZ0dzWGl2ZXdMdWx1cC9FTG90SGptK1NwKzl6alpZNDRPMkNUbGxjMTlkMFd2RzcrN1BKNXQ4bHZ3NTltK3d1ems1ckhlMEtWM1I5dkwzVjRML2RhVkQyNXhYdlYvR3B5UU9FVmp2S1ZuTXdsUFZZdmJXMmV3WkRHYmVYWDcxUEdlWVNTN1dlaEI0TWxjNlBRL002VTJ6QkprZnVvUzdyMnJQTzM1Mkk1eWo1L1gzZS96TGI2NzA3ditOK2pRUkVYbSsySnByR3lCbDU3V2I3ZXRvOTdJMkxXWkZUV3VzbU1LUHI3MjI5eG5OTDdQRDk1bDNLK1dmM09NOXJuVnFYZXIvNmJQL09YTElNamh2L3hJNzFqOC9mTWU2Kyt3S1VXanRGbS9jK3dqcXQzZDVRNy9WQnVMbGRDeTk0WkN4MnphejJZNXNsazNDZ3BaR1VDQi9TVFVUdDNYdktELzYyYmZON3R0ZGYwZ2JRTjdKRXlKUEg1YkZHUmdyLy9ZZmN0UUdFVnRQWlhxcU5HLzNtdERNTFVjUkluZFE1R1YrMW1FeEdycUdCT3VodzEvTW10S1Zsa3ZiN2QycG5lNDZQcVhRdWZhNjRjZGZTNjAvejB0cCsvWlVrS2V5OXhScjhsQXAxc2EwVkFZUk8vY21JSGRQSDVYUngwV0phVU5IdDZ5aEtxV2lWVUVPZGIrYWdQNFRDU3BiOFc2MnR2MTdyLy8vV1hONy9QOVpDOC9YOHZyNk4vR1cvZTN6dlN3cUxaL0RpNG4zMDI5UlNBWnhPemQ1bWRhd0FFcDFTZnpXTzR3cEl2VmZ4MmVpcnQzTk5FbkVzNlQ3dnJZSVY3RnBQa2JlNnVwVkhvbmt5bXM1KzBCN3pKdWI0bGtsWDZmMzB6UGtBVEU0WHJVRVRqY0Nvbkhhem5XWUozdTNMWTRRNFJwWHFOZEQ4bVJUZ09vYkUwRFdwUGpYbzZtWnY2cDk1ZnV3dC9YWHF2MzdDNW42OXo4RTVBRlJLdTloRC9RT05WVXJIemlqV0JFL2ZicHlQSXoxckJnNFMxd3padHB2d3lvVjFyTE0vTzFPLzM5ZDl4N0ZOcW1uaWwydS9yOHRocS9jOVlrUjJqbGZVdTlmUG13R1VTaGNDTlNMd1MrcHRRQWFvaDkzT3BPV1N1SE9iVTdjWmFUU0QzMzMxNnRXdWY2SGxhbjh0cS83VFdWNGNrZjN0WVBya3NsVDhEcXRkYlc5MGJQek9zQ1AzUGlESnNjTjBVc2VJM2h3YnVLdytVYkNSZE9oMjljMjdSMXR1ODV1Uk5HT1B4am5pWE54ZGZwUlVqR2pTRDk2ZjBxNW9ZSGVaUjlLWStYUVYwVjNNVno5K0ovL0pmUld1VnJFL29rY1Y2M0dZamNsOFZzY1VZOFNNSnFVN0xNWU9qdm9BcXZha0Q0RFRYcHhrK29hNVNyNzEySjlmK2Z2LysrZnUrWjUzLzdsM2ZHYXRmQ3RpbnF5ZkxXcUlvVy9rdDVGbE5kb2U3cWkwRjF1ZU8vcHFBL0k1UlZEUXpQWlg4cWVQalZqLzBLd2l5cEtKREpjOFNOalk5Z2NBSU9NaHJPck0yMzU0NDQyMXorY3FBYm5TWktxcUdGVlZ0VlVFem40L0lZSWdzNzlIRzRlNDUzQ3JkY0xnUXYvaURUY2ZyaG1SOTJtTnJZdFlkVXgxVUd5Tkl5ZFhkQmFaNjdXNFhvLy82cjV5S0xXeFlnY0J0c2NZNTdSWmQzdVZLdW5QclA0ZFozL083anowbktrOHUzZnR1dTc5ZTU5WGxsVTFNakdkOUlvZURtRjZ2YXdzbUhVZTUvSDlkYjU4L2ZqejYvUG44emlQRTJDWituMlR4ek03UHA5Wi9QbDg5dnZiWGVtR0xPNm9zdnE2VlZEVCtmdi84dnpQUHQrOGJ3Rm9tTTdLeWpzN3ozN2U1OS9Ra0tVNStaV1ZkMVphUmUzS1NzdUw1U2hVbkpWM1ZKR3pLQUJaMFhMTXorNDF6UjNnQTg5N25HemYzOS9mMzhmb3gwL2MreGhkOHJ5L3p3WEMrVkhteDVaMWY2UUN6NWlOY3JtTTNQdTdrQUZvWGZQaWh6ZzgzQnVBalNzWDdkV1lOOHV5ZkgvY0g5OFBXWGRQWEFLVFRqbG43b25EWVlBNER3QThLbmNuQ0NkWWM4bzE2ckZzVzlUZW56M3F4VndqS3hWQ3ZNZXplblgyYTVFek80NVNzK2FXU1A5ODhVNUJ6VDJUTUtlcmk2RWU3Y29mQUhSQ214N2tMaVpDb2MwQTVvM1krL1BXbUxreEp4clNtdWtQY2pSb3ZyTU83cTlmY2VmYXJySDNyNlBlaDNmYnRyRS9uM2hHb1VlT0ZYNEtrTjNmdlQ3OHZyRW8vd2RzT3RNSWpKUmVQcnV0Skx6TFV2NWVsZnZwYUxadDJ3aU13NVhuOVJ5NVJMODhhNXZGa3pNUnZsSmRPYjMrUGtlNUpILzluOWYxY2dKQVAycWVDdnNmaDZoNTlaY0cxNDZER3dBc1JuZWRaT2VuTVBwc0poRXFFNHY4QUdzbUxQTGZNMkNtcitSMFBpYTZ4ZTY0UGx6QitwZEJlTG02K1M3ZjYrZThYTHBWNHZTNm80NHI5RzRQYXVjYWZGNUdlWWNiOVR0WmRaQUNBSnhha3d5L0R4elVTRjFHeEFXQ0g4Q2NROGdBeVFkTW1PcEVBZ3FQZjFBL3hwM0NaZXI4SXF6ZnZkWDNUVjhCZVo1Ny9wL1hlbjlNYnVlRjhyTnRvMERCdi9EOU91T3RmS2RlTG9vT0FVUkdGeG1pUHJxaVQyaGFvM2FRdWdQTTdhYW01dzBjT2RhdFkydXNPMlA5dzV3UlJ5N2ROa3pSM09lZnBhLzN6RjExNUs4UDN5M0FBV3JLaXJ3c1oxWFV5QmN0bmJOYVRzWDdWUDVmdmRwOEFGeENPeWFrSklIL2RJNXFVVzdpK0FOVUpmVk5BRGNNOVBYaEZadDA1dnYrL1B5OGJ0dHplT3JybkhOdXI2dnZYb0xnNlZPMjR6aStid1ZOZjIweXZoNzYxMWY3Mm95Y3J4SVRBM1JPZDREcjlDVWNWQm5kbytocXBjSzZBK3kxN0w0a0d3ZjcxTjdqTEdBN21idnZuejlPTjh1TDEvaDJQdHhVbnBjUDBqWEJrYk0wejJST3lYSVF2b1ZoOXlNWmhPYk1mOFpsUFQ5WnVLcTRLZW9BWEVJN3ZpYmlnaVEycFdNVzlWcm9ITzRBcXpoMzdQc1NhRlZuOVFYT1dTNG16Y2R2L05Od05OL1BYN0ZlY3Y5ei9maklsOEhUdGRaVTV4N0hVdHExNS9XRXI4UjhjR0wrbGdDSVJqNnZPL0d2LzNxbGJFTEhUQlU3WnJPNTdTTGtkK3pITzBCYkd5aW1Hd0srNldmRnlNKzFWaWw2ODJaNThmVEMvaFB6MWo3QlMvTHh1ZitsN2ZjNjhUemFDL2Q4NVIvQ3kvTGhSQUxhczlkRktLUHc3Yk00dHVVNEFDeGF4eEIrUm1Xa25WNlpSZnhHaGROM2dNMjJpVXEvekFBTytjZ051djlFMTlCNnRYaHFsS1o2OUdIcmw3SU5DZnZjOVBMOXIvLytKeFBMazd6eUxpYUs4YjhmcncxZWZvTEltQXFXSkc2MHZPZ1NQM3BaVlhUcW81SW5BUDhubHFobGpNMEI0TDFyYTZvVDdkWXhzby83OS9uamt6bEJKNkgvd05lUGFZTW1WeHBaVllQbGpCcDBqS0U2S2xGVkJGei82bDJjUER3OVhyOTJQK2RIQnk5TU96cTFyZjd0TmI3eWJvZHBsdUxyRDJmUDk0WmFaWVk4R0U4WHp5OXhja3Z2dnRqYWE1TjlkeGlzcWs3SVZ0WFR1VTRCb2dZcTR1UzBPVXpydW1mejduaXJPaXU1TjcxTENkRjE5VEpWcWNyMU5PdXN4YkVFaTJKSmQ1N2NUZDdrNGRPWFJkUUU3dVQ4NllJa3M5SCtZanAwUEVpbzYvdzdlZmlTemV2WnZQSnp2dnpsNC91cW95Nm5YLzhQVHFvd0hjTE9yb3ZLVE9iOHhjYnA2OWIwNlVRa2o4bXNySFhPengzeTdCdVN5b0l6alViUDJDNXRiTXRyWnZ4VjZaaW51MHZDSUZrMjFtMjdmUFk0Nyt5eXNTVmhHVGQrNmdTMkxDUko0RjJWNjJXOWF2TTkzcmd4WFpwSkN5MTNJTHdIb1pVQjVoQnZlMUpiN0ozWTdIa21NdTUxcWFFRnoxNUdDYlR3WGJPTm9DaW1jUW1BQXA2SXpJRUsrQXRDeDliZEZpcnpvQVNIUUFUdHZaNlgvdzVlck9zRWNGZEdIcFZxVkdJMFVLcXFLcmIvR3VQdGRUb2ZORit2ZjNXMXIyVjVmV1ovM0NzcnZqTmVqTFl2SDV4UEJ2b1RjM3ZVN09TQmhUQ3VHN21ZSlUyTmo3TXVldm5ycGJXMGhCN1VFWngxOWZ3eTlwdFVGMWlyU3IzSkVocnlDY2pobXRzU1FYS1pjK1V4ZDNoYzN5ZGZhTjBXZWFmcWRERk12VG1xdTlHdXI1ekR6RnJzakE4VUx4akJpTzRKSXE0NktHY3Y3SHV5bWNlSHl1bWg4bXV2ckJTaVpIRmYvSGt3eVZYUTdKNWlmYXJPWms2YW5udlg5SFNTVmN4VDVEUm8ySk43MStlVXppUk8xTCs3ZU5uMVlMLy85bzllTkdWSnduc2JXOVRpeDQ2Ly9aN3psWnI4b1d2cCs4NlIzWC95TnF0ZE5sallmckt4UEZOYjBZWEx6ZzZyeFY1eS9XQTd2YWFKd0h0SlhKbkM3dDRremdESjNUV3dBN3pYZG5sZXBOc21QZEhLY1V3MnRYSnhuT1BOY3dRQVBycWszV1VJQlVSb1E1Zk11SW93RUlEdnZqNVhmQ1J1aWtFNSs4YU9TcHhLeFJqUUdOVklWUXluU2Q4Ykh4Zkp3Ny91YWUvUmQ0M1UxUHhjZlo1eWtlaC8vUE9sZDJicmgzNThlNTI4L1l2NmNGM0grZWRmamltZDVvZm01YXJWM1lPa2gvTnlqbHBzbDd4Sm5IbHhuUWUxZjc4M0xDOThkNHhoakxOZDQxMFhWWEhObXBXdzZYRXVqdFBmMVNUYWNocTRNcFBabFhFelRmSEpwUHBreDcrcVhaNDIyRVUzQUZ3NTFGVGVuMlErd2pydmxCRG5VVGpYWS8xUzY4VHJtUGV6bEMvTG1Cd084OHpPV2d2WFVGeFQ5YTdGb015Y3hObk52cTJNVWFkZWwwazZpeUlwcXJqWWRnRVVPbm5HYmEzblV1N0o4VEpVR24rM1U2VjN0eXlYVnBYR2JaaUZHRm1BRlVtMkxWc0NmUkNTNUhYM084Wm01SjRTZWFsdjFMZnVtZ3NRcGhZRi92aDhYNnNlZmpDMkpOczJMRWN1aC83MTdVUUVlc0ZIajNURG1NRnBtZ2JtZ0k5TGc3aURFQTUreVFSSnhvYmpvc3ZRYmpKeGtUSHVXTVhNbkZqLzEzb3hERXZUTk1hV1R6ZEY1MnBnaEtRcVZlWEVEc2FhVWFRU0VhcGdoeUhHR3VYMVZqR3ZSbmRNWVU0WGNlc3RyT2JwbWVXbjVXL2ZwOCtXUmJyOFcrVDdvdU4xMXNvd2F4N2tDVEJsS3ZlZXVmOW40djRhVXdORG42NlRuWVVYeHN5ZXlyZmVLT3NyZml2TC9lQjJlK0pobW1ucHNMVmU5Si9kTFBGVlpGZnBrNGZaVE04NlJTYmNyaVNmWmtJbVM0ZC9acEZhR3N4cG56blZ6NUExVEovSFVjelVSemxjNitiRTVibTFtOU1VcDlTcnc3MHpHck12K2lZZEU0elRTZDBaZDFZZGduL2tNWG5RV01sbzRJb3pweTRtTlNOdHhlOHVqc3dIK053dGE2M2tpVzJXYlBrTEd3VmNGaGF2WkQ5Q1NMOUc1dHRiSUVtU3BRNzZ0R1JMUnJaMVcvSnJvNzFuOGVJWFl4a0RFaFF0UXhDeUNFNS9tdFNjUmd3bTNlRjVpODVHWXFoaXQzbzZqeTBlWURDVWdnc3lQcm1tQXZSRThUVlFsQk1BZm5nTXBJOE13d1h3SFI1dGtRclVOQURwdS80bzBiaW93R0JUSlhaTkxHdU1xcW9pRk8rdmpYYWphZitlMVJ5N1B1dnVWcVY3VEhhdGUyK1NGYUpnakYvZlhmZFBlMWQzL1ZlOU9UZ1phNmJ0eVpzUEdmSFFLcDFVN0U5V3h0UG9xQ3VjNS9VOC91YlpvbS9mWWFrcGVkT2YvSXlsUnRQMFY3K0g3azZtK1hhS21wUG16dWw5NHlyTmpGNTF4dnAxblhROWViUjlKcThOUjhSejRBTEViTHBtNERwUmZrVS9MMnQvZDFycm1DdCt2dmFhYzgxd0xWTTNqTjZYdjVONjlMS0tPZnVxUDJoOTNIMXI3YTg4ZmZyQUFzN2NWMlA1N0F0YXR6KzZhWG5ZazVXOXorNkMrZm1vZGxzM2F3RjJnQkRJRWk4MmlzL2FFN0xreUNLd0lOK3JYZWRmU2Y5WGVhZThmaHNUVGUzdXVhSHk3MVd3bjlEczhtYkQ3eGNONjE1aDQ3WU9RcE9PN1ZlS2xkVEpXM0V6TXpZWGtuRkFrcEEySnRyTTZMMDlnSTBhVUdJQ0FBNitkOHlERkVKb0ZDeThQbU1JU2dBQmJMbXY4ZFBLcTlFeEY4cytnNXM1UmxWbGxtR00wS0FpVkluaTU1N215QjJrdHVuem15aE53MVRFU25KMG50SzhxUGY4K3k5NTgzTDQwMHZUWnRUNEU5MTlYbngvVC9zY1VwZTgvdisxMXFQTk83NSt6dGY5ZHlwZldmV1M5VWM5ckR0YXgxd20xMzZOc09HcGZnZXEySi9obzYybUhyekR1Y2cxcytsNVlGb011WCtUMmRsVVpuM1VaYkdkUFQzc1BQeVVXYzEwYzg5TTViUjc3a3hWQTRNU3VrbEg5UHZWOEx6elVaLyt6K1A4ZmZ2K3JlYnJ6MTVNei9GejkvMVJPVS85MHV1czA3cGZ6SjVqNU5mN05OUXhOZFh3OWZ0dmZIMTdlNm9YVjdmUWJxL3ZKOTVSV1doeWo2VHB3bUQ1MjE5SXNrQ1JEUmFSNjU2SnE4eDl3NkVra0N4SmtlS1IxVGZMNmNWTCtoOS9UOTNsaFJCdkpJTnJMamZINFJKb1lJQUdZS3pXQXhDWUc1NTFTbkllNyszWG4rd3pYSjdyWHIzS1JNak5HWllDQUY1M3pBRWZDQUQ0K3BBaGpTSFNRQUxlM2VHeWdkTmdlVjdnNjdOWTdCZ01POWhpUkVlTXFxcUtoeDBjZFhoeGtHaDgxU2o5cC9tRG9lZHhMbSt0ZXlleFo1eEdiOWRXSHFLdTExNXE4OXZMajZ1UjdxN2ZlOWVVV1o1dkZycmpsMCtlbk5EbWlxMisvdnV1T05hd29zbythL2J1aG9MV1BmMmR5bzVxeXJCWnFEeUdVcjJ0ckRubk5Ka3p2UUkwSEhMeGN1YnlYbWRlYTJHbjd1WjBOclY3d0hqVFZOVU9jUWRtaXRhVDIrdTgzVXJkbkd6V2JPcnNLeTlWL3ZwN1NleHA2YWlKUmwyOXMzQWtGS2IrbE9ocTBuQ3VuVmtnNm9XM0JoS0dMSGdiT0lWMjNVcnorbk9WOGxabVFrb3ZxN254c1hPeWpIbTkzcEFKYm13c2JBbjBMRmxDa3NXbFYrdUMwU3ZaZG1BckZKSlcyWXJFcjIvc3IzOHRGMjFXd0xTR1UzTUZDQ0RSaHBFRkxqaDU5L1FpWU5CTEh3VkZIclFhNWpROXVuNlRkQzB1RmtMSWo5RWFGaUJrRUFEMmRoek94cDZyQzBoWnlqYTBkKzZZTTZXUDRSUUErM1AreC8vKzhPRjNyOG9mbTRmMlllU0hvcmYyeGFOL1d6YzFUVzlzKzZneG1EeXI2QmdpVkFSQ1ZSWHVHcXBjbmRxWGs2YlB5KzMrM0t6VFhuODY1b3hOM2xXNnU5S3k1clZiclB3NXYzZXpscGxPV2d1bWlpZytTOWIwNllmOWRQNDVBMmVMYXByZVR6VDUvVjlVNnZUQXU1bStCcGtoYTB1OFBIZlVmUTFvK1poOXVhN0JHN3FuT1U1dEJTVHpVVCt6M2ozSitYdXFUMTNuem5LRXArMmo5ZUdtcWJ0MWt5VnJVblh5LytzUGd4OXo5bGNLL1VaWFBHdlJuOGVOendKK3V4YkR0VjBQa3NxTGhoUU1XUzZ5aXErY0E4bkFmeHFhN3hDbjdoeHFONEI1S0VpY29GbGJidEgzZTFCNTd0Tk43S1BsSW1WZkNsNHNJMXRJbnVQdkdwajNVcFdGOEdWaERKdmVBelRyM0IyQ2N3QUhiSG1hWEZDRWVzVGxtamg4U1lXTlFIdHg3YXMxQ1AxN1J3RmtFMktjUEJVd3pBV1hIUEplU3VMK2hBMkh1S2prUDRDcVVMZ0xvUHBqKzkrOGUrcUc2ZWtkcWhpejRmcDFUajNNbDkrckQxZHgvYzZRNEh5VFNtSndDR1RNQlJjYzRzT28rb0FwR0VRRGRsMTlVUnlOUnBaaDFkelJaT2Y1NTlzdlFpTVFVY1h2dllWdG5ESmluSjhoZnk5cThlNjdvNm5KWkFIRUFWTkc0V3NReFJ0d2pLRGVWMmovQWJSUzRkNEIvVzIyZ2NZM3gzY0ZkN1NQK3BPY1RYM05XZmxWekhQdHU3T0x4ajBaUWRXaSthV25heFNubkFGM01mUzdJSnMzNEE0QUwzM2RCMUNsQ0hveHdJdGQ3ejdzelV1WjgxVDJyOTVrTytjb0dwZ2k3elY2aXQyOXM0WVZ6M1l0UkJ6YkhESUZsUFhlMWxBWFNKYjk5aW44WFpQRUhhQ1ZFbnp2QUFkWjJpMnpiTGRZeDlNUHBGMjFrNityLzV2MWR0SW1kZjltUEZxbVQyTit4bTRNU0pNeHJBRnZGTGl3bUQ5Znd5bnp4V0FnOFFHTU1sU2dWeE5jMW5kM09DdnNtYWZ6MDkvZWFsRlQrd3hyOHFWL3Y1eVRyeWFMMXFyWmJMekR2d0pKNmtvV2xBbmZPczI4Y1BLL0FYY2Q1TEVScjMvLzZmS3V1UXVWWVJFa1lhNDMzQ3ZhQjFmTlVzM2R1YXhBU3MrVE41MHpwaUd5M0IrclhVSENDaFRNQ1hjeTRzVndEVGpXYThQSUZxUzliOHN5eGtNMzl5VW0zeTgzYjlJWmZLbmNQYzY2UEZMLzd2ZXRPZVM2ZVdNNk9uR2VGNzV2Ykl6dEQvVW1LWkNEdUpYLzVxdnVMY3dEQkVxN0JBQ3dOeDBEQU1BSDBBb243UUZlOWJ5MmZTaVZWWjFvZVowQkswSGd1QU02SFRWcGdneERJbUlDT1NiQ3NaRWUzL2w1dzloNXY0cEUrbnFwMUJjMEdtVUdHaUExRmowa0szMEFyOTR5STRoVkN5ZWNqK3V1ODZ0N3JTM2J0VzJOTTlvdE11alN4bVVrWTBYTzBKTFVEUkJZVVlPTVordTFyZklZdVBrRTU0WWF5VlFtQ0lOcHVFUk0zRWVtMVRBazJSUVhHSEhmTTg1MjJhNnBSQmtaMmR0RjVMbDUxMjVWdVNvbVpoQTZnUVI1Z1lTZ0tzRlh1THViVHpNYU5zMWNzMGVKNjN5MTNSNmY0akNkTlRHN1kxZHFSa2JXekxKTTZwYlZqUGRnbXdhcDdEYjBadE5FUVVyUm8wYW9wMklHQU9lQ2tRYVdBSWVHV2NoR2lERW9JQkFwaDlpTURjQ3lEV09JR2tDZ3NoRU9wUUNNN2RqQ3lCNEVRSWhCRFFDQUltRWI3TkIyQ0FYNGpVY2VCd0VDVUFwQ21pZzBqQk5oUVJBSk1DUUFOcllDWVRkVzF3Q0U0NVBrQkRjSnN2c0dsQ211M3ZqdGE4enBISkVIOFJQdU50VzBpbHF6dlFzaFRJekpKQWFmSmphRDFIRTUyci8yVHhLaHpCQmozbG4rUzJ2UHA3R3l0NENMY1Y0RmM3NGdESnd3OEs5bVNWWHcrY1ZsQy9RNzJuSzY0aVBUTE9JbnFSTnFNUWwrRzZZTFF5SS9HM1NKVU1OOEc2WUxCZmhNVUtHRytWV25waEprZ0dBZnFTb21jM050MENWUlF3aEJWYkZhUjN3M0lrYXNXS3k0NVZMSUh4TmpUZTNKeGtpczI4eUZta1ptdFNuUkZUTkdoYVhtTEpETXBodURCZEZBaEFTbHBnMVJFd1FpUk92QTRBS01BR0l3SVBDQ2dJSWhDUWVKTW1BamlUZzBSa1pnaEIySEdBVVFDTERrQWh1TUVRQ0JpRWxpNnBvVUdBV0tVQURZRWxCZzdJNlpHS2ZmYjh2T1FKaTJEUmxNVDRsY0JNYjF5Y1hSa0JXR1J1a0NFSTBXU2JLUkYxTGdIdW5RKzd5MldjT0hGT3luMFRCV2YwZGlDVlhpNDc5V3VmWnIwRXBCVE1xSkJTODZBQitybys3N1YrK3JGN01oVTdRb29BeTZ4WjhEUGdlZmkyamJnTnRkL1E4V1BwK2hRVGlGRERpRG8yVWZCUVEvQi81N2xvZHNrTkJFa0tIM2U1YUhhSkRRUnBDaGh2YXF6VG9pSWtCbWJKT2JVM3pjemNwMEtWR0RxaW9Za3FpWUptclFhRWdWMTF4NmhXYmJjcGxhV0l0UmpTSHJXOWlSWjVsVGNWMHI3azRua0ZDWWphZFZOSzBBdDRCNlVOd3BCV2pCbU5FM3pCYXlnVUFHVEM2UmJKQllRc0l0UVJBTkJFRVR5aGdBWlNBWkdnRmduSGpxNk5vMkNBVmdjYVd5TEtrY1lIbGhSbUJZVVFoa2VkRVRYdStDU0Ftd3pKcVRBaUVaTUdnQlc4SUtOWkFBSWRuZGtCc0xRSWtJUUM3aEo1ODczRExPTnhUaXEyYmpnZ1pubXpnWm4yN05sMkhpa1pnRXo2Vnp1K2IzcnU1b21MUkpYRmhCMkpyeWVzQzZkVlJBd3JxQ3ordFdNazljelR4Z25FSlRHNVI3d0E0UkIvN21ZZUFodlZZQTN2dVZWNDJFVHdPMWpHNDN6TFlPQ2I4R2FnbmRTekZGVWJZU21aeHRMeVJqVkkyY202TlVKWVNvRXNWaDV2cE9kOGVJYlNaMnhwYVpwc1pkUExiNHkxdzlTaTU1UVhWaXFhbEZudDF0bzBuTXZFbTBaNk1IZ25kUG5sc2Y0TGEva2hFWUx5UmdzRlRRcjZ5RW5SQUdiR0hFT2dMS3lJQVhSekFCWVVxc0lDcGMzTWdERGdTdXdMYU53Z0NJSmVjWW9BMGdLZ0prNWhWMGhrU0FEQUZrQmZIUVRvc3RLSzlZUnJiSVdrc0ZZVENFdlNvd0pkb2dqRXV0aXNCRzdrc095MktoVGhDMmZGaWpaUVlLVlRJUWRKYXFZSEdZR21EY0JpSndOQUJra3BLeGhBbUFSZ0FLTWs3WWpwdE4yOHNmNmdraE5RRmg2YUhPVFcvR3VTNGtaZ05Uc1diZFkrZzVlRTJYSHV6bEtwdHZUQjdOVUs1UnE0bi9ERnlqNWNKUEJhV3M1NTlBSU1Cc0pXakxsNExJWVVNQVh0dU5wd0RzQXpMUXJYYlpxUkU1RHlvb29Ic1h6ZWV2MmQ4Y3RnRFFHZnVZY3haYnpWRXFVWG1xS2w3L0RpMlBQVlk0dFVQc3RLUU5NZWZwOVZlV2Uvb3YxajJ6TDV2Y3VZMDQrMnBwWmZZbjI4eWJEOXZQMG53OGJmWGRqcVU4OTNmbGJwZGJHWmNWelc3M2YxMVVERjA4a1ZSZGtnWDNSSHhrcWhUbEtBaW9wQjFvUXJtWVRpWVRUcVhXcGVKNWxhdXNUSkdpNFVhNTNqd1FwSXlUMmdLRTNJV1lXR0hrVmtHUzNHNUhYcUkvUFl5YitsTjh2cWlvWVNTMzJPdmxSM1RaMlZSVWs1VXFFOWpUdDk1ZlFBNGdORUpWNnBhbzVQc2FBeUJtRnMrTXJBR3JMRU91c3Fhc0JxZ0JJTVFDb05FNzI0bG5LS2g2eGJ2M0JvT3N6RVJ3MGs2eWJXMlY4aThZLzNmYTRnYW1rMjZ4ZHVWaGZ4d1NkR1RQZkpMbHFCdGZYU0FUT01kSjgyaGFCd2FCRTVHQ0VGZ1JCUStKMmpua0lJQUEzbW9WcHdGWUJsamdYNzJLMVFBc0RmVHd2NHZiQjgzNDRvZmUwZXdCODJUTFZhTnFwQnhEVk9VTHFrcXc1cTMvanNOZklkWHpic2o3WmJzNFdieTV4Zm5LYU1vcjd4Zm5uK3orOW05dDdEd2tGL201MVplUHMyOC9YeSsxdVkzUmZtbG1vZll5UFBLdVNmam1UTEQxNERXQjdUTG5mNERxZ2xweDhSVnA4SUJrWWhhbVVwTXhkT1hqdERhZWFGYWZ3L3ZzdzJ5cXN3bVVPWWQya0JoUUNhUEtXU3ZqMGFWUm1HdEMzTk9WRU53VlRTNnJKZzRKVUhKbmpVcUthNnEzaW1oN1llVm1Weks1RGtiY0UzY3pUTVVFaUtxYTZxZXRzV0ppdmZNVkl4Zk9COGpWZEduWEF2cUZXQkdxZW9zV05XUmowTmlxeEpCOENNQ0J3MS9pVHR2VkVWcHU2d016dU9DenFtb3d2RlpEMVMyTWRBZllvUlhFQTJFQTd0aGZFL09uS3ViL3RSdndWSzB4WmpsWUtseVkvTTBDUHBvbTNjRC9ZWHNTdUNXREpNaFZMcURvdGRWckhzdU5kNGZNdVRYUVFVMGFtM1VYQjNBa1VFdkk4dDh4VzJhMC8vam5sdzJzT1FVUi9uTXdTcHB6ak1vMXExUUQ0WFdDSktqWW1oaHY2bHh2NXFyN1NMOGhmSisxOTAyMStVZ1dINGJmaExkWDdkKy9Od2MrdEdldEc3czh6biszTEQ2cVI3dVAxN3hmV0k3bXZMNm1jMjNKTkNJY1dTeXN6R1grZmkveW9CWjhDR3U1T2M1YVRESWo3TlB6QmJ0U2VSN2VIcjZtczk0VDd4WS9YTHpJVkY1YXFGUlk3dTVCeS9UeHBMdWdCaFI5TFEra01SNUxaaXArYlRxbXdYYURXQ2l1TlRrNTFBaFIzYlZBRCtNSGx0VURNNWkxbStBZ1pJVElWV055QVkraG1haVo2SmMxR0U5TzRtcGdEZ0NoVVVTdGN0d0xqUURBR0lSaXBQWGxYYjJaMEtlSnE4eEV0R2FJelJLNFRsZWVXQXVid0tlR1c2ZTRNTWZBMVdjSzRhTUcvK1FEQ0FqVmtZMmh0WEtkaGxBSmdNdDN5NFNrYStFeXBBVU9QV1I5RkhrYndsTUw1QzNoVWdwQ0RxakJwbkVtQUo2YU5ZZEd3akVBNkdhcjZXbEFpb2tPb0h2N3BBd3ZXODhUekZrTFAwOVgwZG5TeXh5VnFpb1ZYUklKeWhlSXFvcDc4d1A5ZnRMWkxIZHRmZS9qUTZSNXZMOTlQZlh4RUI4eHRxMzEzNXR2U2krZXFmS1Q5dzl2d2hnTWFhTGs3UEt4ZUdiTk9hVnFoczhqOXgrY3FJQTVLSjBNMTdYL09uTk1HazFGdkpVUXFVVytoWXJXcWtaRlFadmk3S2V5cXJmb01uVUFsRmUzYWpGKzdFSEZ3S29tRGMvckNNVk5tWjV5T3lpN3NxdWNCUlZVVjJycUlodm5qaFhoTjlZNjJObjlwU2ZQYWNWTW1uaEFFNGw3WGdwY1VSWHdOcjA1WHQ4RkhUY3B5QzVxME9QRldHNUErekVoSGxaOVNPbHZ5Nm5MWlV5SjJiZUk1RmZpZm4yOWhPaHVDQUNZOXpxYWpnNkZJR0tFSVFEZEZRZFlHeURBamlOTEFNbTVIMWxVZURuS29mNkFORjZzVjRwekhFMUVqSDNCeFpHM0lORVZOQ2VhSFJpZ2pTSkJyd1cycm9IdkFENmFGVnNQc0FOQXUxcU5Gd01EQ3dEK1Yzd3Vkb3oyVmJQbU5HdnZvNnBxVHFhU3FnWlZWU3dOY3cvME54N29vY0wvOEp0cHhQa1gvR3pseDArZnY3VXlYSmxQN3Q5eHUvWmlNeDk4MWY0MC85NGlmMkx6RWVOOWFTeVg0K2ZYZlYzZlZsVXZmODNMZFg3a29VdXdUNmUycW83MXVTbTBUMVkwYjNFTjV6ZFVYbFNUZWM2N1k2Wm1TTGk2SGk1VnJNaGNQYzBDWEN2SzZhSno3a3dOZ0E0Wk82ZTNNKzg5UGJ1SzNXN1NTVHkrTEJWZWRIaGRWYko3Mzk5V0ZXZGVjemx6M200bU1aQXRtVHlQSnhNNEhwTldFUi95ZVNqMTVsYTRVL1JVUmFwQ0xpakkxa04xcW1XTmk5SmlSdVFzWW5HeXVTdEVsbTA2TWxiYUx0VjBpT1JUcVljTGhXYm54ZTRXTTNKZlIxdmoySmc2SFFrWXV2ZFRidXB1UDB3N00ydHRldkc5bnBkYjJRVXdaY2ZpZGUzUTg2MjZnYXhKM1FUODROdzlENGo1OEhFWTZmNFlLaDZxWldjQ3hBTVMwTFpxNHlOQ3htT2dBZTAzQUFDS0YvWlJWV3lxVkt3a3FJUVFEU3Aya2JyWkEzQzdycmt3RXQ3RUR3Ly8xWXNSNzVILzRZcS9kM3hUdzRTZ3lSYXB1NmMvOE9yNy81UmVyTlhlWCtJeWZKcGZmaWI2ZW5xYUxMYjl4S2Y4T2UrWG03NWZWcUlIU2EyZHI1UHNRMUhUWXFLQVR6SXBSbk1jakg3VkRFUFdobFJ5S3UrcFNqcjV5Q1ZpYWJkWkRSRVpKNjNuWmNuakdic2NrYzNiRFRkeFNFTTIrVEFaWTFvejBOelVva3J3MFc5azdhUWJROTc1MjNKWG9vMkFLbnFvREEydWJwWjFSSVBRZlVHU1pwa3F3b1RGQ1JnVkdUaG5vR3Zpa0dLVndGSUlpOEFJaEdtZjAwSW53cjdibVB3QmNhQzRJT3hiYjZYK29HWFRDM1hxcG9nOEp0aXI0SDF3a3A5OGdUdU1vNG9oSFdnWGUxdmd0eERLcnVIaERpWVRQQ01rTnpoN3dSRmNyb0VRYWNZQndVQ3FCdzN3QS80cGxZZkhablFOZ0MrMW1xNGVtVmlDQmFvVDhMMlBaWGZlLysxdWpibTUyNjFFOFJHRmZSUTdhaFF6SWcyRThFaFFWYkVWbDlubkg0YjlkL25aK3ZtYmxiM1ltbHQ5N2gxZlBmREFmRG92LzlOTGIrMDl1NW5kbDhjeDMzMTZiL29ZdzlNaWlidXFuM1huMFZieTh2eVpMM2NWLzExOVQ4SEx4YldIV1JRZjZwNFdPNzk4WDYycFRQWityM3hZelVpeFhkcTh1VkpVSGRLUCs0RGV1YTdSY3I0TFhSRlFPZzBpQjZnMW4xblNQVks5MVRIazE2dWhPSnl3elJtK1hVa1ZQV2NaK2hvMDdDSzU0dHZGenU3MXNNcVY5OGhWSllhU2ZwMFZCOTRCU3Vmb2szeGZDU1JLTDZnMnVIRUFFM3NBME9xa2FkRGJUc3pHVE5PUENUM1Z6V2s4NmZPcHBueWR4QmxIMEo5MnVvMEEyVWlaMnRESlltU0N3S0phek1nUFpsaDZTRHhJTnA5RnFIODRBa3FURHh2TGRxSDJKUDVqT3ROd2lRbTNseURLb1Z4MUJGeTlzRThleXlBSFBucVZqdzVaZldCUVRiSXR2ZnBiUVE1OEFOVm92d0VBT0lEQ2YyM2hoQU9qS3VXeFZwVXFscWlxWW9ubnVBVlk1UE51OC9yNzRHRTN1Znh6MTRiVGY0OTN4N083L2JMMzhMLzEydGxWRCsrcyttbmZ2dDZKRHA2VWJxcjMxTHNZRnhXdjJOWThIN3FpTnJuY203b1UrNWZjN3E5Y09FZWozZVNVSjhtdXJ3L1VEb0ZwN1hwL016MWI4N3lkY0RmVjNadUJoNlJTeGJOWks2NTNzdDZ2aXg0NU4rZS9udmZPQllPQVYyaFErOVBDeC9vZlhwY1BGZzJMdWo1VGFpcGhKdld2N2sxbk9RdFBqKzkrbUM2WlU2K09QajA1bFlncWFpM1hyNmJ6M2FaMDd5NkFUSGp4NlJ3NEdSKzhoK0pYSkR5bFVzODZrS09oSEdmREFHSngyWmFFWmF4WWxSQmpmSVNYcGFaSmZmcWlSc3U4N05DeXhRd1NWdGtrYjg1MEZBMjBGSlAzTUppWWxUR0JUdDFjOEdjb2tieWtROWhMcFNNOXcrcWN5OWpHOXBNY0hSUTM4THNNZUdWRkRxQUJOZ21GTzA0dTBFYXg0Yjlzd29NV0NXaWdFR2ppZlE3bFoyWS9kL3htek50dlBpNnYzVC9Wak5iR1M3ZnR6WXZ6OVVOQmpWbFZlUTZtVlZWRnlGUEJ6d3J1R0d1N0x1ZkVLL3h3S21obDM0Wk5XTkg4K1BMblRzZHB2b2krTDFUNzV2SCtjaDNuK251eVh2N0orK0liK2g1emhmYVRkSjl0TGdyOEpxWG55dUY0dlM0T0w1Z0RlNnMvd3lIcjVQTGttalZlQnl2ZjY2eU5XdjNsMk5hMWZoWmovRk5mMXluVVdhK0E1TjdaQlFWUGQ3bTRLUDZEbWZNa0p3OTV6am9OVU9HNkE1SnA2RzdJMmU2bzJXK2R5ZmNhRDV5dWdmNE90TDUwZ3lQZTkwRi90MmZkVkhNdHZWeDNyVnZkMkhrdE5ibldkVjZxNFhNOTV5eFhGc25DTUVBSnQxaGNwZVU0S1h3U0VQQXNTVFlHQkxGc3JMdjZScGVkeXM3K3JOS0xNT3F2YmF6cjdtZzlZeXBCV29aY1gzMldyZVc5cHVDa1hjYVUzN3JyTFJBaENKcjFSSFVWQU9ZWG04OHdXbXRoRG5zenJqSFpucGdHeVFBTUxDSkpwYWNEeGVEUDhBbGlBaVIvZ0dLVmZMMEZGdHo0eW1FVnJzSGwxM3pPWE9jeTVQaDc1VmxSUmhWUDRuRTNOMjMveUxQaDBqU1hzenNBYkRLMXo5TmFTZlFhbDVMQnpYa0o2Z05nWkZTaDl3UXMrRVRQQ1hPWHptYUlmNmRiOTlkSW1IYldlbm85cHpPK2pYY3pHY1Q4b0lkRXJpSlFBV1JLc1hSR2dyaDNORHRJLzRyc2Y0QTJWNFJyQmI1NWF2bnRoVVF3cWJuZTM1LzhkZmxGNi9ubnI5eS9uT3JlQ1paT2sxMHRMTzlXcURmL2xxMGZZeU5XK1ZpVjZ5ZGlMUVFOZEVvaFJWMC9ZTGdMbVQ3cnkyOWx3Wmsvd0pvZGR6OFJ3RTd2ZkhqRlBQVTlxcSsvRHAvcmVMcGZmWG52NXNSbnJZTkxyQStyWng1RmNlTFFTSDRPQ2FUVjNzM214Q0RjaFFxRW8zMWZJODRITEZaVGNGYXE4R0hKaWRBRytzUlhhVVB5QjJpNzl2Vm02R0Q5aCtwNC82VE9yZ2IvVWx0RWZWVUZ5N0o4MWFhRTYrOCtYUXp6WjZxZFdWNFJkOGYrU2w3Rmxlekd5QW90UnlJT1lhUGJiNzlkR0FDU2lSMllHL0RzU0w3NXYxcHE2aVYwY0NwdzhSUXR1UDNUWnlMcnZnRUFaR0hMVk5qSHV1Wmp2U2tBMEF6T3lWRUZhUVFQdy9sUWlvWkZDSWVCcXdRYUNNeUVyR1R5OE42LzM5ZFR1N0l5dC9jWS9rM0ZzWDgxMlhmdzZ2V1ZybW82YmY0M0hVMUtnYXdJcU1qcm94TlZUVlFCQUVBaEtlbHNWY3Q3SEQyQWhSVDY1cVM5a2x0bDlVRldYdkxvK0kxN0dVK3ZSdWF0M0QxU3lhd0hIVnZkMmRBQ29ya2x0N1dQU3gzalBJL3orRHc4bFZOVHd6Q3podE0zNXg0anhFQVF5Z3NoaTZKSklPOXRmM3pTdVFDaGlDa084VnVmeXM0MEdXZDN0V2RsS045MEoxN2tBVjVEelUwa0hHcU5NZjVmVTF4cjNhamExOG5TcHFLYmhDMHFVN0svelE1LzZFNzVYTU45R0cvVHh0TlhSWk9WRGJValZjRVp4UDE5N3pLbjYxQjZ6bHJIVE9Hank0VlpGSU1EaExEQkRPN09OelhackN0aldodU0yY2lDTDlYajgyOVJ0M3Z0R1Nlcmh5UmRXVnRZTm5KN1MzaEJEZ1FGRUVEUVYwODJQb1FHZ0FEWkNId0xFT2NBbm5jQUFNM2JQd2dBWEY1bHhNdmZEMVFnbDFVSlNQSVBaN2k0SmRBZG9NYU9SSENUcThCTmlVRVNIZ0E0YzhiYVhaWGNNMEhnN3RnbHRBdUxtS1dubDk1STg4Wmgyc293K01lRWZDTW9JdVpLbFFia1hSY1NJLyt3L3pLTlF1c1MwK2NMdTU4VzF4MkFMVlRnSmtyR0d3aW0yQUdZc1BMc0VlamFJVE0wNHpkRDVwbXRtU2xpYUZUazhnYkZjcjBSaFd4ZUIzK3dFYlhsQVdSaUdYbTM2cTgwN2RLYVl0TC9jS0hOTXU0QWpJVUdIZUJZVWdPQ2VUd1B3R2ZXOGx0TUVLK1VKeWZMamhiZmFXZnM3UXhiUWJIMkU5VjZuMEdKZkw5K2h3YXNleEpPT1FCTVloTWtxcS9TVDlEM2FPMXlPdDZoVmR6cVZYZUFqTkZBY0pNYnVRQ0R2bXdBVUhWdEQ4cHovNndreDBGTDRSc2t1NWRmYW1IYm5iOGtmNitxQVUrLzMrSHlLUWM4WnJ0QzFIZERrVGRwVFlCaVRyL3F2UE1BaHNwTGNwTWI5UWtnNWV0UUliSm9BdkRWWWNuYUdldUZLNGQ0TjZQYi9mU2JWNjFUdjdxdmJEZTdJdkt2Ky8vL0hvRURQRjRyOXVqc3IxaHY4dHFsckgvaGhpN1ptaCtBelRZSXVNbXhZcjhYTUo3bkFQaHZnNnZIbFJvWGpvN1kweTdUT2szOG5UMmlDOFd1TmRVL0E0YklrOWVtaHVrbUpnTmtabVg4REtwMEtkWkZZaE1vZUEzM2FROXV0My80dCt0MnY3VG1pVnNIYnFMQ0R1dHRHYnVhY3ZoL3hwVHoxODBBdEpTVmRUVGxjenBtMmpiODJXaHl1TDcrMy9taGI2OHpYdzlHc2pGL2Z2MFgyN2hLQUU5bloxTUFCTUMzQWdBQUFBQUF6YjIxL1FVQUFBQUdVU3JqWmxkSVJFTkZRbEZVLzNuL2IwaGRUbFAvbi85di80Ny9sUCtIUTFCUi82ci9uZitWLzR6L3BVZGRaZitrLzVmL25QK1gvNUgvbFAraS81SC9pLytVLzRuL2h2K1YvM3YvZXY5NS8zWC9jLzlpLzNEL2F2OW8vM0QvWC85dC8yZi9hLzlnLzFyL1dVUnFNVU1NZDMvT2JZdllzUlZpalBlaWZoNkExRVo3UjNBekx5N0F4d1I4WVNxVU9ES01BQlFScHd0NkNvNFFQV3NGWHQ1Yit2d2duK0I4L1RuMzFOQ3Y0bkFaS3FqSW51ZU5GZisrQ1N5L3g1SHR3QmRNQXpScVRZTlNkK1cvcUY5YWZhVEVISFpQVE84QVZTTVIzT1RDY3laZ0NRQUxYVzd4VERDQ2YrbU5PVnFVUlBmYWFJbVFvSmZzakxyVVhKc0JJVHZvU0Y0VzRmeU9TdXFFQmtSbUU4VFQ3UGRobjdUNmpLWm11S0kzeWgrZ01sN2dKbGVCM1FPMDRSZUF6QytieHdSSHRKQTl4T3lNSjVsNGpZR3ZpRWJGcW1KTmZ1OWtxbm1XQUFpK0xXUUJUR285MXMyczlBdEY1OVhqd3F6aHhoOGM1Ti9PMEpwZGVwZk5KSTN4MVRFLytyd1pzRWtGTnFtbHBhMlBMYzVNMDdHTGE1cGpzc2V3Yzd4TlQ0U1BLYjhEQUdSbVVXTEtVLzJOZUtmVmhJTFhjSk5tZk9jOE14MTI3eXhaTnRqSE1GZnN1MEdlWnBTUXdoUkxiZWVNcEhXdDFveWloekllU1U4VzhlbjJURVVCRU0rS2Z2c05BQnhpRjRReHN4OVRqMWVmRmV6c2N6anZBQm1MS2plNTBUNHhJQ1lBSERHcHVRZyszckEwS2VjU2dkSlpSblBwcU8wd1RlSXNyMVNEeERxMHYyV3pER2ttRGhSZUV4UHFoUGsxdG5nMVRZT3JTcDgvNHJDWFYzSFB1T1UrVExuSmpibmQ3VzNhdTVxY0MvcDlOSE1vRmhNQVVySnJMVktwVDhiN3BDL1doZnlhaUtPVXJIREtOaXpDSUVDNjhVNFZJNjY0WFJSZUswbldzL2ROL1htVk9LcnU1NTExQjZqYTVPVW14NG8vRXVndy91WUEyT1RMRGV2SGY5U1dXMldrTFU5bXZON3I3dGcxQ2tkZWE1YWhNNHl6YXJDS1BOajM2bTE1YlJncXN2S1gzUUF3OEcwVUEzcUp0YmF5eUR4czdLNUN5cXZFWm5ZTkY3RmplZ3BPSXlyQi93WUFlTGZyaWZqZG5rVzR6Z0hHc1U2WFNJQjFWS3BaeVQ2aTFFZ3hIQVpVQUJENmtUSHl5SEhUMkc5SFZxYnN4OFA5TDA4SGxvM044VGZUazltUHk1OW9NWEtER3hsaDhlVzlxYjdQdmtxaGxJN09YekczbExlVUQ5N0hDUUFBcUt4YWRzVVczS21QN2MrLzc3S2VOMW45ZFFxdHNZK3ZieDl2dW5OMVRUYkRXVldHYnZibUxCVTloOW5EVlhNYy82YUg2MnU2UVV1bWxGbjF5ZHRyK3FaUnUrV2NlWlF2ZFBxdkw5b01KdXRkQUpnY0Q4NkZsek56b3NWUk5YMzFQWFM5TkVtNVJxR3BLRmhEZkJzVmpTcXZ5ZXdra3dwblhJMGZ4Z2tKSFJjK2dteURNMWM3VXZOb251My93OHdvV3FaNXp4elZFL1k1cW12Y1l1Zkc3ZDdEQzBtdFZUbDJ5Z0FwODZUZHc0TzhMbmZabHQ5L0RkaHYrclM4ZWlVaUtvaW9Lb0tNRVJlQWtHZVhWbzBkSGZHNXZodUU0R0hiR21GZEpKcFRvL2JHR3E0UklheVIySThBSkxBZWdjdmRidW5PNXpLYUZ1ZHFwOGdIS0FOMmFCMWNZVEtjRnQxVzFiU056b0VWd2tWTThNNXd0bU8vQVFEcUdIVmNYVCtBNS9WbkswY0RRRE9PdkFuTXlhYktiS0kycHlKUXhkQUZBRVJqa2pyaC9yMlRwNmR4NC95am56aTkvVy9UcE1QL0d2dUpQU1RVNzNYQ3orQ0lUSnMwMzArYVVUVERmM3JwcmhSdEIzcjlkblV4ZUZua1o5NThYbHpyaHdmTjdlLytVNlkrTmFYTjkzUExERkE1ZFp6cGVScXlzNkQ3V1hCTXBrOW0vSEkvU2ptTEhEUVByWUxnZW1uMG1IWFRRM25Xa0hldTU4MzE5bDh0K21PZGFkS3M5ZGlXM1p6a2s4SzVGSzBwVHhVOWxSQzFoRnE4K1RXNXQvZ3IyV0F4ek1KcWwxMFVDdHhwZ2NVRTVKaktVWHh6NU16TjQvS282NTExM3JOdmpmMzd2bWhTUjJnT1RGL1hRRG1oYzk2aVlZWWhBY2dVL2drYkFSWXY4UjlWUVJEMG9idXZ6cXJjTjk2M0RiWUEvS1Q3MTMzRGIxakkyTFp2OXFWSTVQYTMzLzU1R04ybHdIdnBhR2xsVU54UTdEYmFBVUNpbU5xK0ZxRkFDQ05Ec0hLekZCeUhaVnFKQ2dBQUFNcWpKOGNrS3BPdVkwMkZ3K0lIa1RzRzNJNkZORC9BekpEdFkzempERXczQkJmM3VLLzVqMjN5eWUzQW5QVSs2U2tpRkFnbURiOXU5Q1BTLzFYRjBPK3J4dUFDZ09UdllYaGJBUUFrTXMwT2syUDF2TVVibVYxVzZTV1lVZUk4Z0dmYTk4M0VlWXpUQnpvcDE2ZjlZaDU2MGlEWnZjblg5a2I0RTh2ZVZIVWVqWXFxeHJBOGEyWDdtcU9WdnpiNkxQTGt2ekJWM3pyenJVam41QjJIWlk0ZkZRUXdIdjR1Q2dBVVNtOFJzRXNXOUhuMUNiUmVzOUlmb00xRFBrK01Qd2NZdXFlYnczY3JUMyt1K2RTK3JYYW5hckoyWWRTU1luc3luelpEV20wRm5pUGFEekdGeEh4Yjlhbkp5TGpraStISSs2eWljemNFYm04WXdRaHFpVXB6UStGeXFjVDVBZFlja3daMzFGOHlNTGo0TWVNT2R5by9NU3VQYkxqalBkMVY5cy90TGIyMTNyZjBUMjQ5a2xiK01tNTJvazc5SWtsRTBFL21COUQzTGFHZ3NJejJ5bXB5QjdvcEpnRk5HcGducldiRGk1UnU4NXZ4SXB0QzN0VTcxMUY5M2c4QUNsUFRFZTJXakxTU2gyTUI3ajlaa1FDQk0veG8xanFLSGMxRTdXaHUrUjJ1QUdJazJqZUlFQU1ac3RUSFdhUWZ5bmluZnBLNC9PekIvTGV0SHZ5ZGE1NUkvL3JHTUU4ZVU1a0d1VFR2YzVKUXNucGZ3dXZtcWxXQmwwM0RCRkJVVUZUWFZHRFRqTlh6eHJCbzZXRHQyNU5nNTVBVVZiUDR5dVA0LzNMOWYzZ2E4YnozL3JVblJHcnVIVU10eStmdm11cGZVYjBzUlpBMEtkSTVXUjdUM2VYN0hOb1RTTlV2czlJa0psMU52M2kzSG01MTlpOVpVTVAwc2toUVVPRVEwSlJOMlVOTVRuZWxpSHNJaUNQTktWY2U2QmtieU5DK3RURmE3YlhkT2pyb2xkTTV5WVMvZ21yTzJVOUJja1g3T2ZEV09SWC9Ma3h2Rnk5VnpDUnZDcmh1eXQxWlVySElsa0NXcE84UFg5MFhRUFdhdjlQRi9ZLzZPL3ZMaDBUZXFDWXNSVVIzRitZRkFjWUlmemt3MGw4SUFJR3hRT2EzWmNscWpmZVJyQllzMyt6NFRsaFZ5VVpBUUZVQTVaK09lb2pSOER3TmRpQlFmcW9veHdMQVlWblc5aFJlN045LzlsVlVBRURsd2ZkVzFMSXNDd0cvZWpjZ1FOejdYSjQ0QVA0NXpqVjY0elZwM01BZERmTWpPR1NJK202bzBpUDd2d0lBL0FBQWZ2OXFBWGpkdWVCRmQ2MmpLaGZqNEs3QUh3QUFYeHl1QUtnb0lHa0JBQUM0dnRzQUFQRG9HZFVxZ0JWc1ZHRlMxRU4xZGhLQ1YxVlZSRlFWUkVTeXM0Q0FvZ0pBcFBoNGFUYzJoRktWdzd2M1dwbmtYT3FFVHZhY3pOVHAzYnVLNks3M0UrMlNQV0dwRk0yWFc1cGlxaHAwZHAyWGJ6MThuUHNqMHltbzZlcStqc2RTTlJmZW92dTVxdDllOFlnZUhDYk1haVliejFDeGZSOHpIYUZReGFudXBidnBtcVkwSkV2TWJFK3B3YXdwRFBBbXAyWUdFSGhXWFBRQVRHWUVzczB3a2FCWk9tNUlFaHNOWWRqVGVIZzZqbzBVSk00WVRibm1RUmhPNHF5cTdvb3BsMlNOTWNtQWJLS20rbm9aakxuWGl4dzhleXYvVjhUZlArcGZyQi9CdjcvWXRtOEpTVndTc20vN3h6Z2x3REsza05DdDM4Y0lXYmFOQWtYQWpXMEo1MWFjbW0vYVd2cjU2czRlQVhIaHMrUXZTWUF4eVBSZGRLYzVKZHdodjRBRkFBQUFBQUFMQUFBQThzY29BUDQ1NWlKL2t6R0VPNEl5ODZlWVRPaDJsQ1ovRXpVN0VpbmRWd0NBSHdEQUc0ZTR0emY0QmsrQXVQd1VPRjcrR0lDa3A2cEtsUktMN21FYkRRRUFYeW1DdGtCMENWQUJnQUN3M0hLUkFRRG9xM083ZVZNdngzRDVvdkNDK041eit4N0Z6TjdJSEVJT0RGRVZCVUJCRVhFQkFBQllUa2xxc1hwa2w4dVI4ZXp2LzlWVFAvWFF2cUJYdGptZXJRZFBIbDNSaG1wcTB4cXU3bEJBVjFONENLK2tZTnM4OS9wOFh6TUY0REtYWWxTMzNFbW1CbEM1eXlzb09aRTlVMDM4bmRQcXF2MjBuR09tbzlicWFZdFMzQ0R3STFUMHRCSUd4VkRnb0JtV0tzVmVySkhGRGVZV0owV2JvRWJJSHQxdktRblR1NGNKckc0UzdkZ1E5WWhLc1h3c1hzVlRRNTVrTjFBZXdnZzF1dkpVUFJPelQyTUh4a2Eyek5RRmNvUU1nREN2QlVVUUZVRkY1YldLTHI0ang4QXlNUVVLcHIvN29tODN5VVowSTF4dC83L3F6dDgvZS9uaVl4SDgyVzlSaUpCd0VFaVNkdnI0bGtBQ1FJQU1OMFlXVXFpM2kyM1o2clozMS9OYmkwYWx0clVkSUl3V2FRU1VLM2xXTjNKOXpaZHl2M3lXejY0QUFBQXd3QUhlT2M1WE5qTjExWjI4Uys4cVcxazN3N2xFajFtRTdpZlpvZlBGbVdWSyt3b0E4THdqWXR3UGdIY0FBSnpoRTV4K1FNNDFLcVdFM29DRHZ4Y1lOeTgwYXRBRkFBRGdYVExNdWY1eGp0SEtlSC8wOVp3Tk1FSE9XUW5WUXQwa2h3RGpSVXBHZ29TVTBIc3NLeHJwdEtoRzkxUFUxSW1uZUV6ZnNqNmxEeUtpeW4xZU1YYmc1RG1SYUQva2x2ckdoZDdLZEFIcXVhT1JIcmUyeVVNN293emI5dnQwcWFjVWtrbWZ0MFhJb21veWZqbXk3YnZWOTFKVmRWZlRkQkVROTRTb09ZVnphSDg5TkttcXRzZ1ZtTGc3UmUrdXpvUzVVUFYwckRNY2JiQWFxQ2hKVjRzRUtRSGxPOTM5WCtmcGJGNUNZcTdYTnFtbG92TEV1QTkzcmNWWWpnWlgxYjFrVDhUazVNaHFiTHBUY3RTZEFOMGZ3MkI2b2VwZWhJZ25yb2x4eDkxUUlTaFJqSFhtYlRXMlREeGxFa0hrNzlMR1FnSmJLR0xrenBnR3RSUitBWU94WktuQVI5MlJLd1VSNVNYZXpTTXVteHR6bXh0ZlNKSWtXV0R3Kzh0L2pLcUJYQ0NvaXZEekZWMzdSbzIyZWtNVllBc0FBZ254Z0N0YytBRUVHQVNnUWxpZDF3TlJERlJRK05mZkdsb0FGaXBXSXRsa01TM3ZyYWdPaGRzSnpsWFFiaXAxMzJLclZubGZBUUFlZ0QweitnNmc2WmRzcHhmUXJEelNxRVJ0NkxRL1hBTEVZamdNM0FBQVFHb3RNZnk3UExXMzFZQnFGS2xhTmIzME1sMzJGc25mL2VMdnA2b3BSQ1ZReHQzNGYzOVdWRlVGVkJSVkFVQlJVVlVjRmw4WFhXeGFueURGdG1xcHkzK1NXMDc5cEZXTCtoVTdyUGVOeVphdDlVZlpNYlo5c3NaM0hMeEw2ckhQVjNkRXJUcTRlYXQ1L2JndWRmRDROSk5GRm1KNmx4NS9YTE9KaDNnTVU1cW5EemYrNk1YM3BSdzYxNjRxV0E4dm5adk9ET2wwZmZHZlJUUG5NSVdxazR1RHFjcXdaaTU0Wmhpdm95S1VPY0RLWkE3VG1uV3ErOHlRMWZJeFhEYzlvVHZ4V3F2UDZ6NU51YXdFR2lySWhvbWd1cXAxWU43Y05WMWRLbko3UGhUb3RKamNxK2pLamlOYVFQTEMzVTA0TUVJQ3BGOVo1RVRlVHZVc1lpcFh0elo2N0htemZsSGYrNjhsK2Z0SEJGbEdCbDRaQ3dDRWJIaTIvL2V6alNYcklxRTg4R2Y2QjJsSmI3SnNTd0twaUlDcXFWenJNdVBSR1ZEZWltM21YTWJEc1c1VFdVbHlEd3NCckdvbENMVjdzZUJydFVxZVpwa1huQitnOHB4MURNdUE3RS9VN09QVUZ6SDA0TWp2S2p4Ulo4N2lxVzU2emFtQ1orMnI4T0xyb3FENloxM3ZLRlNsQzM0TEFNeHVJYVJjeHJ4a3htb3JTM1QxdlBYOEFHczdqRHRHeEJXaHVNbXZDR1Qyc1Z4ZnI4SDNaN1gzZk1yNHV4N1dOaEVDTEZTZE9QOWNkYVVjQ3YwWVN4dmNwWUlZMS9weWpQUXZIZ20vVndBQXRHcE5qV3dhU1Z2VmRoeHVPYSs1ZDRBMU4zZTdCdERLY294R0NzL0twU3p1ZlpSWjJab2J5dUhaNVRHM1F1empUR2VyOEhxdUxsbEZlVTVVVlMxRTNnSkZNZjViTS9SYkNBakR1elhwRHpZZ3Vpbk9hVm5LYnBhNyt1cmw4aEtYUkw4SkRnVE00S0wvcVVhdFpyNGZBRUNydHN6aVdLU01qR1RaNndZbmM5M25xTW9wSjZvUm5POWFONWVBdTlWakFLQjU4Y1h6dnV6aXc0QWFFQUNRa1MwYUdYSmQ4eDYrSzlzNjNuMjdmMzcvdGxleTV1SnFQQ2xSVkdSUnhvYXAvTnRUV1p0V0ZUbEZGVVJFeVFLaWlJcjBJTDlaQUFBVWthMGpDZlM3QW84UjZxaDF3UEhXL3VIbmRlRFNXbEtmdHovYnhXS2JhSkpLL21OVkFIelZPMitwUjFVenBvcE8wTDcyYzMzL1o3MXBhWmcxSk5laXBZQmljN0lKeFhsZVFJNVlaaHB0Kyt2eDg3aXdTQ1dtNWVVSDlTdXVlZUU2MnkxVGpiSTUzZDFkZlhPK2x6OWU5NHpIek9Cd010MTBIdzcxZEJmNFRYTFNBRlNNTWVLVWNkNVNNL0hsczg5VU90RjFtdHI4cUhuNlZmanVvVEl2S0xwdDEvNkF1ZkEwZTZYSSthTm4rUG41cUw3UCtmZkZkTG5jM1ZXQVUxMGFVRWlrSkVsbzJObzNnQkdXOWdsUkx3dFpEdi9nZTZjV3FKNDhVRVVFQlhHQkJRQldFVTBYRHd0SG91aHZ2LzM5NVlzQk1BSmtmTHk2NHFwOFcyU2JYb2xpdkJhUTErOVlDQUdBWlorRm1PWVgwQWdPRU42S3hIZ3FBUGNsUWgyQU1RQytHYllpbk10UzNmUFNjcTlHWEZNenY2RUhrM1dvLytzTVVZTXRsT2wrQUFETkRBb1lna2lQQWFaT0VWalE1OWZ2bktIQzFvK2MweWlHMnJmRGdOdTVFQjhUQUFDZ1FRQ1FBRnBFbW4rOUlZZUtyLy9zSys0OXg2R0IvbmZJNnNPRXZEeXhsZTdsVTh0VjhUakhBMEM0akY5TXF2dXFqQlVWUkFWQlVGNEFnTHVPc044OVhSbUNFTzlxb3FtVVp1ZjluYmZ5Y1lWYU1QUFJGei8vc1JlRTQxb3FtMWpGSWJMT2EwUlpySHg1bm9oMVAraC83dlh6MmRPZFNQREZSR2hFc1RqT2ZYT3lhZ2tYYklaWmhSTURtYi8zNjczbklLQ3FhbFYrNWttN0t1ZEdkOWFXKzlnemI5YWNkMzVBNzBwZ3k2blpsWkhCYWtpZXB1bll2ZnZMa2NlZFZIczAxM2V5M3VmZkovZFRteG9hRHpLMVg4NEJUc01zeDZrNWJiaWt5ODFtTmJxS1lrS0FMTHRvd3dZSnZoN3c5eHQ1L2xvdWZxSEQ1M3B2Wi9QaDFaWm5IcWgrTGlLNWgxNyt4MjkvVnlVMTNucjVXRTBWUFJFUmthVS9rcEF4VmxWTlF1RHJsMzlNTDdHc25ReUIvS2xXOHB2ZlBrQTIyUHJnYlZSQlVBRVV6bTFoM2ZKc3VpaW1CZ0FBZ2diNUtnTWlBQUFBK1B2WHZnbm1ISnFrdXU3dmx4bDYrUkVpbWYyWFhsVVNFd0phL2g0U3NyZEMzdzhBb0dsUDlFQ3pDZkl6UmpZREVKb3p6MTZ6TnpDKzg2amxCQmZ4ZXZmakJzQVNyNm9hMWVZOU9nTnVkQzdFeHdBQS8zb0JRQmNBQUlBbGEvTC9sbFNpZjJmK0RKYzB0NGNYZlBsMGZ2eGhORi80VkNaYzhhb01aQ2dYQTdPaGpQZWY5ODM0OFZTRFRZVUVpQ3FDZ3FLOEJBQUFSdlpTRlFrOFlXaTZUSTFvaXV1dTJuWHJZd3F5a2k2dUU3cEtRNUg3K0d0RElrSHJhMkE0RXFlQVJJSjQrbmZQVHJyd1ZqK2QvK21lN25ZT1ZKSEZzZ2V1VC92MEMzNVc3YTRMVk5CdUhjb1B5b3lMMnhIMElJamE3dm5hT3lOT0RxNjVLTEtHNXVSZGJlVkFMeDRXb0pPN29Mc2RlVHhQNnZ6OXhUNmJzMC90M2d1Y3lZV0RwdWNyMi9WNnlDcUE2dTNyRFZRV0ExQ0xGbDJYQXVEWGp5VGJJQUFBSS92YmxHZWU1V2ZQeWpQRDVUTzNSRDY5ZnlyUFBQdW5JaW9yaW5sS1A4aklHTURDdjEvWG14Q0RiV0VaUEg1K2tJMWtneVhkbGw5bEdmbFY4RzRMeTJEWityMy9mVUVGVVJRVkZaYkxDR0RDczFZTXdBZ0FBQURnWjZMKzZGVWRPbVM0Nnp5a3RHaGY1VTEyVmNjZGpJQWV6dytFd0s1cmsyRi9BQUFBZ005S3VWY0h1cmRldE5pQWZ6L2p5djMxOERNQU5Qb3FOdVhFa0NXb05Jc0xjRk9OZ0FzTC9Ba0EvOUVBMEFVQUFHRHBNdEFEQU15d2dscHRKMjBmVWxlSHNIT2o4azc5dXRvbHRLOGJRZ3FlWDRpSWFGek0wNzFmblkycG9BQW9JaW9pK3ZwMGRRVmRVUlZFMUNrQUFEaDZQOEZXS2h3UnVCeFpUY2Eybk1rZjhoZTRxYXVaaktxMlRUZ3hKcE5hQVBEb2YvclRLU1JhTmtVc2lpWmlhdnlEc3cwSCtKWGhHZ2QzdGJ5S01xU3FpVVFXN243NDNIQ2QyNTI3blBxbU03UlZpZXRHdmZLbFRRTGpNMlNRT090SFoyVzhBaklYenB6VFh1RU9YY3ZiNGQ1RG1PaDJ0bnNLTlBkMWlsWGs0V2FQbi9vWVZjNzM3cWs1a04zM3g2SWVQNXl6RHRZWm5EZjdNSml6cjFuVldQOS9ydm5mL21hZzY3aFRueWVKOUczMGR6ZnBDSi8wSk5IdjYvZzlSRVJGK09zSTFVK3Fza0VVUWVkNGdiZFJWVkZVUkVSVS8vbG0rb1VzR2IxSzc5SVZTVWJ5dTJTL0tkYmVjSnR0ditoK0ZBQUFBSjc1SlZiWkRRWHU0b1R1KzJubjZuUXJ2TWR0MWdCa0ZyLys1NlhoT0x3L0FBQUF3R2VUNklUb3prWWJZUFh2OCtnRWo4RDFlVUFlWTg0OEdQdTJzUUpRUzhDMVFPQmpBS0Q3YlFOR2RBRUFBQkd4dEMyWjZUNEJ3TnZ3NWpkZlNESGRyUTIxMXZPVlgwNi90VjBhTkFSOFh2Q3FiWGY0TW13c2xrbnJLNVVDRWtyV1BnQ3JvSWlLN0l0cXN3aWlvQU54QUVGRTVHdkpzNjRUK25WVjZLeldPbE9sK1pjSDlObDNJeXNmR2VnWkNkcnkxWVplYTZqVlQ3WGFGRDJaVlVPaDVQVENSRXFGeTcxZjMyeUM0cGQ3ZHArY1V1Rmtnbkw3NVg4MFp4TStuR24rbmxtaWtwd0VNbjV4UHlhVlhmRDh3N1dIT2xhdW1Tc3VUbjFaSnpQcjNPUUpIMjMvNTFIVU9oLzZ1UzZ5V09NRnhjRDRLZWVjNlpXVUt5KzBhMzlWY1ZPc2ZwMWtCcWF5ZW1xdHl0VTJlZjlZemN2amxzT3E5K1oxVVZNTEc3MTBVY0o5dTZCRDF4WmtoVlVRTXJrK1hReXRjbnR4b1ZISVZkSnJLSWMzb3ZwZ0svY2ZmVVkxVDNWbng3YStrUzBGR0c4TS9Rd0FRQUNXZnVXRnNEVUFZQ1Q3L1hxeDhESWlvcWl5TVUzZXFDQ0lxZ0NpWkNGam9BRUsyWkVCTWdBQUFQTC9BY3hXRTlyS1pWVE9WbFBkTEJ2MHhYRXI2azhTVmxZTG1adHdCYW5ESThrQzVFSS9KWDNBL0pPN091bmZqcTdEbVhIZTN5UU83aTV5SklGMTg4OUdvRDl1OFQ4SEFGSUF0RlpUclg1MXRiU1ZWa2V1Z2lvT3ZSRHZBTnQ1Nkw2ZUhGWEFBVGkvNUs0OW9LTC96Tm5mcXprRUFFRC9HYU9LcjIrbmplQVo5Uy8zZ3c5VE90MVZtWDkzR2ZHT3pNSjd1cmdKdGdpejZtMXhZM2RYa2Yra29hSXQrRFlBdkZxOXdQOFFyY2JjVE9rT3JVN3pEY2c3d09ZY0U5WG9CcjVsakg1L2cwZjlMeUl6VnlpS296ci9COStIcmtaOXM1MDU0Y1BtY3VXVWIvc2ZYZmd2L1lUWTUxdGYrbmwvdWJDSG03UldkUHhsNnh1L2VQYlh0azNBYjBCQVVWVDVCY3BuQUFCNitWVVpjd0JaUm1IMFhTQzhTYTlLZ0g3ZElTMXFPQzIrUHdBQUFNQnQrcUFQMW41OUFxajl2SUJhYzdGdTdRMjRLa0FVUDF3Q0FGbndUcjQzQitneWNDS002QUlEQUVSNjErV1NGM1BLY0JWQWRxMW5VYlBGeEZCU3F6Rk1RNVJXZ2dyYWZELzZYalJhLysxRk93NUNvS09EOFMxeUhSRDE1UGJSUzRXQUtBQUl2VkdkRUJVVE1WVVZFWkY1RlFFUUJVVlFRZmZUSTRnQWdDaUlpbmw1OWZidGFuUHFTWFpWLy9GTDkwbCtYTFYrYlMvNnBLUHA5c3o0VEc2bTJxd0hPRE93TTZHSUNvUXYvZVNiN2RGVVhRQmFDQkE5OTN6V2dhQTZzY3dxSVVkWXY2WWJaWkgwOUQ4dWsvQXB3bWc0S1g3KzkrOFhSMGhRdm1nU1IwQ0w2bXJHcEZ3cWF1YXlPOHJycEh2dUpuT3ExSU05bTYxc1JiMGJnbjYvdWI2UHNHUUJUblV5bFVtcitnU1ZuN2xCTkEwWjdjdVpnSEpsK21YSTFLNXlyNUIwSjAxems0THV5Yk00S3p1c0tyREZMUXNrOVZLNFhFbEgvNEtKM2hORHQybm01VkxFSUw1Qy9wZjVEcXczYlpJQUpHUDJxaFRMQ3JIOFNNWktUMyt2OWNpMmJjc0FxQXFxaUY2bzZ0ZS9OZDBjdU5aV0FWQkpDVUFBQUFEZ003YUFBNzRaUmd4bVMraGFNSVhRY2NETXF3UVRCTXFGUkhZMnRPRllJb3JFK3dFQWVEMDZUcDJoQi9nREFBQUEzRGpXQU56dkYvK3dBV3NETFBLSkdxeDFvZ1I1SkdkMEJsenlqd0RBYnhWaDVEUTFkQWs0SHlDNkFBQUExUGFrU2FIUTl0MnJBNERzQTNDdUZ3RFdBWkE5L3I5ZnU4KytHbWRQSm9qMzBIbm96VFNSNy9QS2dXT3FmSUVHSllUSWQwYUc0QW5FUFpxOUR5MFEwSngwUitkOTBJeDRGRUFCRVZGZEVUaW9naWhxWllOd215WXBBQUFBQUdndmY0b0c3ZFlUZ0IzeEV2UHR5R2V6MnNHaitHb0Q1Z0VBVlQ5cGcyNkt0UjBDZ1BKMytrcTd2bnA4OG9VZTA4WGJMMnpjMTdyUHNlNTZaQTg5K1RDTGM0bVgwUU5IVG9oclZSZUJUQm5ycXRwYU44V29xZ0ZxK20xcStEbXF1YWVublRERjhQWWNSdTRwa3p6N2hMd1g3dW0yV1VmbEpmT2NhVlltdnl2clNzM0tsYzZxck1yZDJZYTd1cG04ZTllSVNxN0p2Y0RuZFBTVDgvT212N2FGMmplL3ZZcTNWMW1kbDM3NFI1YS9qQ1ZiQzVKbCtVYTQyZ2YvWkZ2SUFxUGc4NHE4WVBibGJ6SVljWVA4c1NTUU1BaHdnRUlBZ0E4QUFBQlhueXUrR1NhY0xxNlg2MXR4T21HUGhCbGNDU1lCekFBeGd0TFJJcnQrZndBQUFJQS9BQUFBd0F2US8zVUIzd0FBc01IWU4wNDNmV0xjeDNFQXdLdUpIUEF1TUxKZy9RNEEvZ1JBbm44RElMb0FBQUJrQzhFRUNnRHpFZ0MwQ3dBcmxYUDVNTzg3Q2RYcnh4TUE0QU1RaUdTMFdkY3JCVkFBRURBNlZSQkVSUUc0SHhVUWU0c0FBQUFBSU93MnFPVDEzaHk3SVM4am9pejE4TkpVbWFsV3ZEaUNIYnJlSG55eExnUUluQ28vNFdPVUNnQ2dDTVBLc1hVWktBV0FDTDg0eHNIQk8zQ2lpTVZibi82eUxBRTRRWTl0UnljNlhIOFdKRnBEZWxVdE5XWUFWVVBIaGZ6cC8zeENGNjNsM3N3TzNSV3R2cWx0Ny8veW5Wb2lLVlRrVk9Yb1dPVkZMdEt1M0o1Q3A3bytuWVJ4TW11cjRPSlNmTmFRenNtUE15aktSTUJoZjI5WmFTL3g0K053TXFoSTdPcE44YWpVUHVkYk9POE1ueWw1VHQzOHVIYmVObGFiczUzYUhoYXlsR1Z2d1FWM1BoRVZIZGpJaVhuL0VUbDUrR0dWTnlKR3FpS2lLaWdZNmJlRUpRa3dOd0FBSUMvRzVrVmcyMkFiK0d0c0cwbTIvNW9mM1pHSG12bjdVd0FBQUFCd1FlQWFBQU1BQUFEa2x3RGVHWWFGdVFETDlDT1poTnBuQ2QxSk1BQXdveUJhTlRXeDFKUWc5Z01BV0ZkbkJ2UFB2OUVHL2dBQUFBQXZ3T1dYRjhEbnhqOEJnQTBnOGkwd3RpTTFvUFk4NkxqV0d3RHM1cXZ5Q2JSVWwyb0FSb28vQWREOUVRU2lDd0FBUUN5UmZYSy9vejkyV0lZTVlKY0UwTXMrQUZiSW55SjAvYStvaFhWZUIvREZ6aVdRRVVUS3RwUTNYczh0Zm5FTUJFZ3BxQ29vZ0NpeXZ6MlR4N2VIVXBPcFNsWFoyNHNESUNpaUFnQUFBTjFPVVdlKytlbHlCQzRvOW8zZU5tOGcwR25VdTYwQndHYWZaK3NnV29JZ0RKMkc1NTdWQks2MEUweStwT2s3Wjc3QVdBd2tZcCtwTnFVWmhXMlh5djk5ZmprZmVqQkJDRmxjbWZ1VzVQQzB0M3czMnhjeXhxR2VncXFjMGtETjg4WkZuNktvdDVZbHNmZ0RKdmU2cTg5dDgyOCs3YzIxN21nNTVxd2RmVmZ6RHBYWG9veWJjdW5BYnFPOHZQcXhvSDZvNCt0NEpGRFZKQUJRUU5BejAwQXhDRStxRFQwUExNZitmQkU1TnNSQVVGVkR3U0NNTUZZVXlPR1hKV3drYkM4aXNDVUJDUHRIa2czSVFJMXRmM3h2cEdJSkFMRDRzV1FBZVBzUDN5Z0FBQm1BREFBQWdQNGN2aG1talZtQnVyaEdWQWliOFlqZkpSaFN1RjNBMWdORlZwb3MrZ01BRU0rWkI3Lzk3Ulh3QndBQUFMamdXN3krL3hVQWJQUXZyRjhBY0RvQXFKRVNnNjR4RDhBSi94VUExdExHQXY0R0FXbmNnRDhCMEl4L0JSQmRBQUFBb3NGNVBlM2JMOXgxS0RLNFhCTkFMZ1FBSTZGQUlNZ1h3d01UUDhtVEhPdmhvZEFWVnF6OHZjYjZsZjJoUVQ3L3Qxd3N1ZVNTR1djb0NLSUNxQWh5bkhRd29xcHFWSlJ6UlBjbSs2Z0srNElDSVBwMnZLb0FBQUFBUUg4QkVaMWREbUdZeXlyU3dyKzFXVzh1WTliNC92T1RLUU1BS2JiN2RodDZHd0FRbDY0N3RBek1nVWNzSVZuS3UzVlFNOTN4K0FmTnFBcHZSOXRqRCszSSt4bXRXd1Vhb0lTb21xUlJ2UHpMRW1nb1ZwZzJVRjJiZk9kZ2FxcmpyTS9SdFBXNW1xM3FlTHVpNVBWUjQ2V216cHg1ZTRHQzNHbm9QK0RLekUwOXpHNGZyTnk5R2UyZmV4Wis1T1hKWGQ2Ymk0S1FWa200ZUFTNm1aWkJTRWhHWC82VmU2azgwS1dJSUtLeXRiR0ZiZG53VFpjbEpBQUE2cVcwa240a2YyOEl5WUFjQ2lCaHlaaEgvOWtJaEFFQUdBQUFBUEJCQmI0SnhzVlpBWU5kTnlQbVVLL3BVS0owSnBoZ250aTJYMzhuZDFmQzNzQ3FuRXFXL3djQUFBRDRBd0FBQUZ6WVQvRCs2dFBvQUd3d3lYN1JnRk8rUUszVlpGeEVEOERwZndjQWlKQURmdjZLTkM3QW53RFk1LzhDSUxvQUFBQ1VnQWp3QU1CNXV3RmtDUUNnQXdqaHVodU5YQ2lsL3YvZ0E3ektBY1VMZ1R4bWNtZm1DZG43Y2o5SlM1ZDlyMERoY0dRN2RCbzZnTksxWFVGQkFBRDB4eUdwRlVSQmtLOHE4b3orSXRNNlJuUWlBTkpEQlFBQUFBREVSQ3NxRXVaSnNpRzJSb2E5azkyMzQrUzlQajlCaE55OFFXNHpDQWdDTWMyMkx6NVpCUUJIWjNzb2lnMEEwdlZYbStmYlcyM0hZK0hobDY3OW5DNCtVaDBoM1VCVi8wcHRFNGpXR1VHQW1JaVE4eUZvNkhvM0oySHc3bjN2Z2l6NnVuTlQzWnlrc3o0em5hanFRSFR4RG1UUm00NHJuK1F6QndNOXVkQkE1WVYvNUhBWXpLaTlvMkZUekZQYzMxLzI5VFhqUVRBSFZBVkhtaDhQWC9qbzJnZ25DRnozazFudXVUeDcvWE5VUkJGRUJaVy9NUHZteUloTENFREl2ekQ2Z0lXd0FTQkFiL3ZaR0x2S0JnQUFJTFFMQUpBQkFBRDRJQXFlNlVVOTJvR1dldHpKVGwzNEYrdWFTRVRLaTFzTG0zN1J5SElIVzNFVDJ5cGJHZjhBQUFBQWZ3QUFBSUFiOXpjQVhOOEFBRENQcEwvOHdQSGFhQllBcEswbTQyTHhBUUQ4NVFzQWdMa0xRSW8vQWVETDN3R0lMZ0FBQUExcDJ4THpZUUE0bHdBUUpRR3dBY0Q3ZjErUElpWFQ1WkxCZ3dkS1A5UGtEZ0FvQVR4bG5KNjkrbzdrRXRTNzl3ZkZoeUNnd2NmY3hnZmdzMGdJQUNvSUFDQzNxQW9ncUlnQ0FBQ2dNbG9WQ29QalZEcTJkems3bXN4RE42d29wdlFIVGxPdTg1SGhCQkNVNlZqM3AxcERBYkRCMDJzK1h4b0pBRGltYlNqQjcrMDd2RE1BMG9TUVd5VmpmNi9LQXZKZ3NoYWpQcmtFb3Exb1MwTUJ6NzR3WW5idjA3WUZSYnBZaSt5bUJUT3pYOVJIUmV5cjNCaWY5NXRXVC8vakk0TS9PRjQ1dGJLWTUvenpjczZWYlUwZWk4bkdrVHVibmozanB6UDNURDExanZLSzhueHYyNkowYVY0ZXVUakdGSFZkQ3hqWXl3SnMxY01uVndRQmVlc2FoTlhUWnhCVmtkZUtpcWoycmQxS2hhMnFuR3c1YytvN2I0NUZmcWMxUk9Jalk1UFJIcmFBQlV0WVlBQ0RBZi8zK0FkUUFBQUFnTGZsR0FBQVlBQUFBSUR4endCKzJMVkZLcStDWFU5T3FTNjI4a1lLalYwZXh3eWR1TGx0Y1dnK1JwS2pQd0FBczA4My90UGxLK0FQQUFBQWNJTEgrQVlBQUJYejl0Y0FzS2ZXRDlRUmJwQnpjbEZ2QU1CL0Z3RFN1Z0NrY1FQK0JJQ2Z2Z2NRWFFBQUFCbzFuWERkdllkcCs2UXFFeENYQkdBUkFNYTZBUUNTTk4xbVQ5bWZ6d0FBeXJaUVhCcnp0QkFLSWJ3dng3bnZpd2RQMnk4NTRBLzJwL0ZCdFR2cC9hVFRsVE1QbmtESUdmS3lGL0oyU2M5N3ZEc0JVVUFCTUdMbkVCUUFBQUJVTWdvQUFBQUFxaVlpNkJvREJydEFKN2ZidEcydjQwUW1aVzIxclJrSkFhQzlvbTZmb2lFQVlIZWQrOFhKUVJhVldRVVl6cS90bXRxSk9BNlFzWVBBRFIrUXgxbUx4VHBocnQrNURUcEtDODlsTm9JYzdxOWk4anB1WnJLemw1TWtKOCsrK3JyZmZWaWFEMHQzVG1ZMEtrTTFHUzY5MUdIS05la3JQcWZlUUJ1L3EyN3QvaUpQMVNWV0pjVlNIV2d4ejNGVmt3WE5vTUZFaEpDZUZNU0FzM3ovYnlzS2lPcmlVQmFxbzdBSE51aExYeDlMbGkvTHQ4RUNaQTFHalVGY3REQ2dvQUNBYlA3Zkx3RUFBQURnQXdBQUFMOEgvdGpsUklLeGZyNjlrK0x3dzdGU2t1Z2lseUJTVWlQZVVlbVNPRGhUU2VnL0FBQUF3QjhBQUFEZ2d1L3hGUUFnditCSGN3QmZCQUJnanpnZUJxb2lGL2tGQVBTL1lhUURBUHpJWDBDS1B3SGd4d2NBMFNBQUFLQXN4K1lWWmcrQXl3U2dLZ0RNWndBOFpSbXpNQWw1c2owdkFFRHdlVTNkSVZjSStIQjZBQUJ5L2xzOENydit5bXJYTG4wZlFBQUFqRTBBQUFDSUpnQUFFRGtQemN1Tkd0aENTbUprcitJVDNmM3QrZnZYZlhweUp2dFBnZUpiQURKTnFiSkkxOWtFQklBVVQ1LzJHMXdBNElTZDg3aTZHZ2dRWjlFTDZUK3hjSHg1UWdDQUpPMDREc0dWUXgwOUdYMFgwSXhuK3JCUjAzVG0zMWR3SHJQSUhBaUltb2N2TklBYmRxOU0wWDlQSmRnU0hMQ2hTSkxtVE96aGxJNzNHWGVibk9tc0w2QVR5cm1hN3pic2YxZlY0Sm85UFltOG82dWVMSGhxNE1sa3VxNDUvZlZGWDhKWlBCd3dHRmg2VFhJeXU1SUROSDJoQlFnTGNjeis1dytJSnVqRHkrTUhIRCtnVkJnSGtDMVpobHNHK0JVeUFQQWNBQ0FBQUJsdUFRQUFBTUR2ZnZjeUFBREFBQUFBZ1BkZkN6N0pSYXlnbS83bzd1b09OZndieW5aQ1ZJSzR4eTFCRTJKc0x6dTRRdzM5UTZXNVNQQi9BQUFBZ0dmYzF4NEJpZ0FBT01GSDhYN3I3N2NBZE9BQkRkdnRyUUZnVHYwWHlGOEVBSmh4QmozOEVjQzhBVzhOQUtRQm5sMHFBQURwNE9KVkI5QWxvQUdJQmdFQUFMRWdjU0I2Z0JCU3U3WUNBRW5hVFFEQ0NqSVF6cThuSUZRNU92STlrSFAyZEVJb29TM0FoM1Z0YjRLSHJsdjRsai94QWU4THdVdWI4YlRxdlVkOFpUaDVVaWNsYSs0b0JRaHdDNEREa1VzQlBSZVZSVUFCQUFDUXg3MHBCQkFBQkFVQUFBQjJ3MDBBQUFBQXdEOUJBQUFBQUVCeDhoZmtHRVdGVG1BSENIWTRSVkJuRGMwZTBlNXlvUGpWOFlZV0FNNk9helVJQWNCMi9PeTZ6VG1WcVNvcUFhSWxlYVNqS1pvRlBvZnpxejhpdmM1eGlUc05HdWo4SlZVNnhzMmNJYnZ6bXZSci9WeWF6d1g1RXVZcmRMcWlIVmlaVGp0ZGthZ2dJTzhVN1FNNU42ZUx0ZkphSDgwVWp4RTNxbHduK1hpTTB1dkFGRldUZVEzVnAxRVFaaTd3aHMrbTdDdTJnYll5Z1F0b2xnMDJOb0QrazZlQUFjTTdHQUQ0b0JVQUFFQUdBQURnSFFIK3VLWFlvUmY2NlZ1bnBSbzY0ejJVRlBhNEpXWEtSYUY4TjZQVnNIRndHbWV4UHdBQUFNQXp1enc1MzRDc0FRQjRBZWI3SjFqZTc3d0IwQUJiVTJmdjkrRDRjK1BZM0E0QThuR2F1Ly8rYjNPQUhFL1U0Uk1DcU1ZYWdKRUdPRlNYS2dBZ0hZeXZPNEF1QVRWQU5BZ0FBTWhLT3FBWENZUitoOTdtOXdDWXFnbUFKd0NBUFlkUTVGU3ZoMVVoZTQ4Ry83d0hXa0szLzNmMFVGWGU1NEpmNlBxdDRzbGtQRnZOSDE3d3N2RjRRcWp1NExLREZDMVRqMmVySXFnb2ZRQjVRQUFBQUFBQUFJQ0h1UlVBQUFBQVVPKzdBZ0FBQUlDUVRTQnBTaWx6QWlSVHY2UnBhZVljOWYvU29hczA2N1krRVdEYkJNazBWeVVBT0pIRm5wRHJwSEhBL1NnYWRyOVRRU2RGazFVazNISElLZDRFcHJ0Y21kVDlPdytxMkI1M3M3a3JKNXNtYWJqb1E3NnU2bXU0ZXNWaDVSTFhrNlNibXN6TnMydlVoN2tqZXIwblorSHc5MXdnRUZCbmd1c0xxaGJNZ0lSWm9WVkFndjVUdGNvQTlPRmhsRWcrSUFmeWdRRForR0w5V2tDRlpnTndDd0FBQUZ4dEFJRC9Bd0lBQXdBQUFON2ZCRjY0NWZnSVkzMmM3SVRzQmw0MWxSajN1TVhNakcwai9UTWErckJ4TkhWS3ZUOEFBQURBTXg3LzRWMkFuQVlBT0E1b1duOFo0QWNBQUdEL3VDRCt4dTNmTlFBQWUyeE1qQThEdU96Z2ZCRUFvSmlteC9ERkFBRDZHL0RYQUVBNkFNQVhYUURTS0F2UUphQUIwQVVBQU9CYTRZQ29BRit4MTY0TUFKNGFBS3dEQU9DbCtQTGk4d1FBZ0FrbE5CbklCZVF5ejc4QWVJQU1QakNaNUFJNVNMeE1DMi82Z0FUNWVMRHVad0JNQkZRQVZVVUFBQUJBOS8wREFnQUFBQUFBQUNJUllQbm1HQUFBQUFCUUFFb0pLckdsMjVheFBIRThBOFlrRTUrNjlOS09jQi9peGFRZUFKbFAydExEQlFDMlBINnR2OUowMFpYSkJqanhMSStZSXUwNEV0SmJPZzBNQ1dNT04wbGhFczd4SC83K2FJbldVa2dDZkg5MnJzKysrdWE1MVJzdjhYczgxMmFmNjFFd2xUaDB2cmpFWlFlaEhVSVlaSnpUVUszcTdFN3lXWnhWU1dDbUliOTIxRVVsN3FwTmw5Rzl6aEZ4L3J0blJqbUUvVzhOQ1FBQVl5RUJib1RXNUM5TXdnRUE4SFlGQUlESG5BRUFBZDRMQUFBQUFBQUFvRzhCSHFuRk5OSzM4Vm9QbTFCdktqVzVMamxkb1piRVB0c091YU5iTDQ3d2ttNS9BQUFBZ0Q4QUFBREFFMkQrK3IvTTJUNy84RzRBcm1nNkFCYy9nZ1ByUFFCNFF2L2RBdUJMQUlEOFJRQ0FtWnNldzljREFPamZBSUJmYWdCR09nQ2dlZEVGSUIwMFh3RFFKYUFHMEFVQUFLQS9ZMktEQ2tEMzBnSFFMZ0FBQU0rK2pqblV6cTUrQ3NDYjQzdFhwaWZqS1ZWOWk1RHRyUkY4RWNSbllHTi9xdUFGRDZ3Q0FJRG5GWUNRQVFBRUJRRUFBTUIrMzBjQVFBQUFBQUFBNlJQUUw2b0FBQUFBSURBR2N2M0pJQ3REcVJXUDdMYk5ieU9NK085OEV3TFUyYjljTUFHQURlUC85Wm5IT3VJQVVMallVeSttRlRZQURIbkhZbXI1c1dwcVFWWEM5ZmgxUHlhb3FDZ2dvb0lFNkQrY2dZTTRveld0T1hnUHg0RndlUFlvTzdDQlBHRWwveDBIck9HcDV3Zmk2b1k5ck0vTDg3bE9YSFdZZ0lrOVI1OVF6Z0FaY01MRG50MlREWE9SN1FVdXVubFFPZjdpMzFwVEMxaHJXQTlBMEsyNUttZW1DbGcxc0dBOS9uOWFNRXdDTUxDTkVvQWtEUnc4dlVBQUFQZzFBQUJ3NmwwQUFFQ0czd0VBQUFBQUFBRElXd0FlbUNYNURwbnZ0S2JVcU1WYnFtemtoVmVZSll6TzVTVDl6SGJxWmJOVG1mOEhBREQzajNEcTFBVHdCd0FBQURnTzhPcTNOSWYzYzQ0QVRkZUIrM01zM3dxNFhVY0FtTk8rUUIyTC9yOExnQmtMK0JucThBa0JuZU1BWU83L0FLa3VsUUJBcWt2QUNRQTBDQUFBYUFaemwrNDNKMTQ3aEFEMlhRSW9LZ0FUQUFIbTBHdVRjKzYzRmxSNTNwZHhac2dBNmh2bjF6b2YwUHZSSjdsbzBKeERWcURrNWVJZklaT0Q5MEFPM2srbW56TlFJTkd5UHZrKzZ3cWVjdkdXRnZ4TDdXVXlYdkM1TW5nOEpXY29KZnQvc3dBQW9BQUFBQUJuRXdFQUFBQUFBS0N5UFlEU01tTTdaNGNpMUl0a3pyYWd1d05pMlNkTmZMZ0VBSFp1Wkp0VlJSUUFuS1pIMTk2RGdTbzZrM3FHNVpKSDI2RWtDdHlCZ2cwMTh5RjU2SnoreWwxdkZwVldkYktYem1wdXpFaGd6TlRuckpua3l0dTZNM1hNOTk5RnJrbXp5RmxuWitYWjBOeGs5cnd1MWp6TkN3TUFZQUFBQUFEK0tBQUE4QVlBd0FYQUJRQUFBQUFBQU1ETEFQejU2OThBQUFBQUFNQ3YzZ3dlaUNYNENVWU9MYnBqSElzRDFsSWp2OGdWWnBGd3lJdis2OS9WVEZVY3ZyOFdGUFlEQUREN21ZMWZQN29IL2dBQUFBQW4rQmF2MmdCQWl3TS9YalNnQVM3SENud0JBSUJ6TE80Zi93TUFXN3dieVYwZzNnQ0F2ellBakRUQTNRVWcxU1hnVXdBTkFnQUFyaGZpOU9SYnhaZzFFL0FCODlvQjBBd0FZZ1VBY0x1VG8xM0krNlMxSVhqQW4xb1N0djduZHlZOG1BSlN1bjlUVVc1elN5alowd2NBNEdzOVFmSEFCQUFBQVBReGd3SUFBQUFBQUlCR0hRQUFpTzQ3UXJCN1ZWZG9aME5peFJPdVNqenFqMW1YOXFqVDloKzFBY0NYMTZmNG94Y0FJQ0xYdGRzUXNLbE1SbFEzNitNRlFNc2ZQcnA5Vm9SazhmTVFxZ0JLdWNDQmJlNy9SNEZqcm5walYxOTdyQUFnTjN4WVlGT3JSdjF0Y3czdmRhditKQ3R2Y1Q2R09sQ2g5a01WbG9ObWluaVk3M3NzWVZ2OHkyVU9PRVlVSjJRTitmU2N6NTlKYUJVcTRCSmc1NHYvcUpycW9xdTZLOWZMSWdBQUFBQ0F0emQvREFBQUtJb0RBdnlCQWdBQUFNRFRQeFVBQUFBQUFQaHRBNzU0aFhobmJYVlpTN2E3SE9vTjdGT29HdmxIRm5nbGpVTmNiN2ZsaCtkY1JybUZpVGpCL3dFQUFBRCtBQUFBQUNmNGdNLzFld0JjQW1EODBtSDUxc0JOQlFCN2F2KzRZWTlqZi93WmdCRS9OUUJFbHlvQTRnRzRmZ3NBQUNBTmNHTkFpajhCNE1VTEFQZ0xBQURJQWdHOEFIQ2VBMENXQUNBSEFZQVNYOXlTSVl4N1A1a00rQ21MbmFCQ3dlOHg5azdZcjdVNjgrUzJHZ09oQkZxNGdxQm9EaUZrQUVyMmt3SStVTGNzN2kxNFdncmdIM3lBc09lL1ExakFDalBVS1pCelR2SGVUOGE1NUJWRlFBRUFBQUFBME8rTGh3SUFBQUFBQUlES0dBQUFSUHFBdURleDdVeGFZbXR0citPc24razZKbTkwSDdaZE9uLzMwZ3JISnRmbzJJTysrLzJBUVk0RGdLZi9vOU9LQUFBcERsdXZPNFM1U0dmTnNLMlgvNmd6QlFCUXNtR21HUDdMbk5rZHFwcHY3L2Y2dyt5SEJHZmptNnkraTFiV2FTNTZTS2g1L3pXd3FQVzdlVThlUWNPUjdnTlVQdXo5bllFdE5KZnVRTGZ2ZkttN0FZQ1hCd0FPQ3hRQTJQNkRLQUFBQUFBQStnNmVpQ1hneWR6b3NZeG1kN2xaRmdkbHl3WkdmaDlmYUFYT0VOZDl0NzZyTWZ2d0g0WlExRkJrMkE4QXdOUmtHKy8rdnczR0R3Q2dubWtBaXF0MHh2MGRudCtNQmNBbEFBQU41L0U5QU5pUDE0bDF1d0dRajJYNWZ4dUEvZ1kxZ0xlSjZGSUpRQno4RlFBQVNPNENrTXlmQUhEeEVvQXVBQUFBR3N4VVFUU3ZsLytENEI5dTl3UVFmRk1Ba0hrOXp3QkFmcGpkNzVReUxuRlkvWkVyK3hXNGZRRGdHUndjbThrNUZ5QzVjbGNqWktVS0FMOVBYcTRVbStBRElZRFBrQ2tqQktETGtETUFGTUY1SWdBQUFKQlJBQUFBQUFBQUdTZktLS1VnVzdMTGppVEJzYmx0VjdVYk80N25HVVVGT0FCb0Jwdk1nc2tFc3UwQ0RzQkdWV2MrTlcxaisrVi9Kd2hZa0F1YS8vVEg0K0hMS2dpZ281aGxvd0FZdG9HcXJDU1YvbXpvdlhlbm03UHZUWXJ5ZnpCUW1WUXBTUzlwWmMwSzJxTjV1eTRudy9uaGFnNmNwbHhvblg0VzQza3NyWG1zQlpRQUQ4Q0RBZ0FBQVB6ekJRQUFBTHk5Zng4QUFBQUErTThQQUFBQUFBRGd6d0ErZU1Wd29WMms3aXJScmxIR1ZYbkp5Ty9qQTZ1azk0SUF4bkU5cTMzM29TLzBGZG9TNC8wQkFBQUEvZ0FBQUFESEFlT3JvZ0dmM3lJT0FIUUFZbjl6dTdGVUFVdkFuSHBIZ0QyV3ZmN2hBWUI5SDBqc0F2RUJBSm92dndBQUFGSmRBRkpkQWk0QURRSUFBS0l3UkI5ZUhBRHhNUUZvQXNBR0FQd2x3NU1pMCtKSURnRFZsa3dBOE9RVGJjc0YxZE9McDZITHBWU1FBd1VBOWpkNkhrQ2l4WlB1bTVhQUo0UWVJVkFiVk1zZkR5RjRBQUFBOUlNSUFBQUFBQUNBOWhaQWFOa2tnOUxFQUlHUDRtcEhmQ0J2c1lSTkxVdmhmSHVORUFKa0hYdXpEUXk0NWxCc0FBd3RKYmJvQlFBNFFSdXgzNVpHRkUzZjBGWDUwL2o3YmVFQUhSQ2g5WU52SmRBNEJRd2JCdTU2aXNseFBKeTlZWUVzb2s4ZW1LUklVTFd2ZitsMStLSVg4VlpEVStyVFQwb3R1c0hMdXhvSHBhdm52L3NFUUZBRUJkWFRadmNPZTVpWm1RWHpBK3Z4QWp3QUFBQUFQQSsvRFFBQUFBZ0FBQUFnaSsrOURRQUFBQUR3Q3dBQUFBQUFRSDhCM25jRjVFVGx0bHRMdG5OMFE2a3BmMnp2bmpkWUJjWVJWNzZzNTJHZlBpaVhPeGxLRVA4SEFBQUFlQ2IvdSs2TEJEZ2pBTUFKenVMelpkMG1BZGdBZlBYK1BmUXY1S3M1QU1mVzV2d2NNSUQrV0R5c3Yya0ErbVlUaVYzNEJnRDh2Z0FBcEFFdURFanVFbkFENEM4QUFLQVUwSWY5Q2dqTHkvcWJBRUR3ZVFHZ3V3VUF1R3g2MVNzbHhUci9aUW9LOVg1VEJSbVlTNjZWUXhEdjl6b2JQQlRnY054Vkh2QU5BQ0ROOEFrQjFBY0FBQUJVeHprQUFBQUFBQUFBUVFFQUFLRkY3U0JEMENCRW9BbHJ1ZGowNk55dytkcTJicDRwdCt6Z1ZMMXNCNGV0TDlzUkFHQTdCKzZhc3Y2RnpnUk1VeVgrckFjQUZFV3QrOCs5d3dPcWVsTXFBc0FzRDA0bkFUQmtDeXhKRjZsVlRkWjJPWURYTVJlQmg1ZWlNVENzeXNrODZpYmZoc3hhL2xFbWg3a25GMmc0R0s4MXcyTjlyNEZoMUYzYTVqRUdlTXdhMWdDekFBQUE0RnQrRHdBQUFFREJCZ1VBL3YvNUJnQUFBQUNBSHdCZVdHVzRNcmRtNnVld2N3bi9KZ3hRV2FzRS9FRXFLU0p0ck9tNkwrKzdodG9mWGFtb3FRVDVmd0FBQUlCbm8zLzlQNjBOYUMwQWdET09YZkI4ZWIwQk1BY0F3UElxQUMvY2ZRR0FjeHRBZnh5M2Yvc0l3TDd6RjlHbEVrQTdSZ0RBL2owZ0RYQjFxUUFBcExvRVhBQXdBQUNnQk13SmVRWHdyTm9VUFhnQ3Rkb0RZRTRvQU9XcGRyLzBsRHhaOG8wSFFHcW5YZ0I4QkxuaGVSdWc1REVaQUQ5cnB4a0tBQmlKci9kV0FQQStJSGplVUUybUovakFKT0VDQUFBQUFBQUEwUGdCQUFDUVZmc2NBQUFBQUFBQTZJVWkxR2RDbkl3TTR1U3YvallmOGVTOGMzWWYwUzJqQTc1NWJ4OEE3cDZoV2dnQWpsM1VPZDg0QU1saWxHdXR2QW5CQ2NIT2pERDlhbk1na1BwVkFBZ0FBWUJhM0pzQjBPd0NBTkJadjdNT25LTkpVa3BSZm8rdnlwMGdJRTRtbFFEa25UVFRTVERYRHk2Z3UrRFovOHBOTkJldFJFME5rM3BIUS8zOWxnS0FBaWlBZUV3RVZEZlFNd0F3QUFIZzZwY0FBQkFDQUFCWC8xa0JBQUFLUGtnVnpCQ1g4dWhtTTRuK0ZDMW1YejBMNWUramtqVFNMbjFaNzhXOE83a3MwbEZKNGY4QUFBQUFIOWsvL1BQOUhKQXo2NjBMWUp4ZnBhOEFBSitpQ2dBSk1QZmo5eThhN0MvOEZ2c0NnRk1Md0g0UkFHRDVBM2IrSXZqeit3VUFJSTBYWElBYmtPcFNDUUNrOFlJdUFUZUFCZ0VBQUNVSkUxd3pBTDlaKzU4QUFHMWc3QW9BdE51S0F0d0J6bzhCQ2xEOTRXV0FnbjFjaHplTHFtcnhLZ0FQa05qa2Zub0FzdmNBUEFNZ1pwRUNZZDhEVXNoT0FnQUFBQUNXQUFBQUFBQ0E5b0lkQUFBQUFOaU9LQUFBQUFDQXZNMW9rSEdIeU1CQkorOC9mUzJsVVp3Syt4alVYQXFtL0duVUFSeENnRXpxcWN4bFNDa280UUFBVTg4bFAxQ0xMMjZBRGdCZ2VmblhKcEJvaUFTSEFIU3hjQURKTGpRQU9mN2l3QmptNVp2VWFZSnZQNkFBTmpiTFhYOFBTNE1ET1hCb2tzeUN1UXB3blJmemtLeVRRa1ZEVkJUNERQKzVBUm9nQUJyQy84TU5BQ1NRQUREOUp3QUFBQUFBQUFCZVB3QUFBRUEvQUg1SFZiZ0lHM1ptb1ZWeHdKTDE2eW9NcEVMb2FWdHhMSE54MmhMNm9VUXEweVhKL3dFQXhOVmx4OVBuRkFHZWVkbit6eGNCeUNvQXdCUGdhcDhGWG44U0E3RGtIdklMbHk4SEFLL3JHYXNCQUhzczd2NzdMd0QwdVFza2RlbDdBRktORlFDUUJyZ2JCS1M2Qkp3R29FRUFBTUNsU3VydXZ6VWZ4KzFreUY1MXlPUHhaQ293bWhvQUFBRFFqbG1lVExsampybHErUnphOHlMTVlFOWJGQUJnZzdyOTErTlhrSmNMVnJqRHlnVVVPU1JQb1FBQUFLQUFBQUFBQUFDZzhqSUFBS0I3RTRSSnNVR1FtblljaFMzT1crdWNmbDdmZnRVR0FNU2kweDRiREZCcmNxMVp6UFd0b2FsZTlvTi84N2RTeWgvMXdLYWhnZlN2cjBCQ0pwQkZVL2d5Z2dKWlEzVVhrOWMvVG1XZXFoelBuelNaZmwwMUo5clRqQUFBNEVFZFZESU80aUVMWU41K25ZdnQ5Wlpxd3FjcUVFbHhwaDhBQUNnQTRLM2VCZ0FBQ0FjQUFBRDREakM4T3dBQUFEL2NBUURlZnYwYkFBQUFBUGpMKy9jQUFBQUFBTUFQWGlkRnBJQ3R1TG1URTdPTG1kZWh0OVRma3pMQ29CdmJLWmVSYXFDTWQ4VmVQVWYvQUFBQUFNLzQ3emYrQ2hBbkFBQnZ3SGh4RVFCd1ArK2ZFdkN3UFFBQWNLbUJyd0FBVDJYcEhKaC9YT0FjaTl2MVZ3RDJ2VUdrdXZRQ2tMeXNBSUEwd00xZlFEcndBWUF1QWVjQjRDOEFBR0EzU1FhNEFBaHhyTDBKQU1WdUJBQUdaQUEvcm40SGVKL2lQUkNnQUtUK3pWUXNhblVueGdPQTdoNm9Ma3VHQWdBQVR3QklXUnNBZFhvb0FKeUtlUUlBL093QUFBQWdvQUFBQUFBQUFLQ0xMd1BJTFFJQUFBQUFJcE1IY055VlViZExwaDNoWE5iZXZkYTl5MnI1TnJjYnFWaTU3WVVkaGlGdzMwTnhBUUE0WXF6YU90TUFBTTB1U3RxUURnS1IvTXNYeDV0Q3FlcVlnVXhwU0gybkRRQTJBRlF2WmdkUXV3QUE4UEwzNjJrU3RJMEM1UFh6NXdvQUFIQUJBTUJqdlVPZ2xQam14dEdXNTJtNkhOaHMyOHVqM2VXemF3Z0FBQUR3eFgvOE5RQUFBQUFBQUFCOEFQandRd0FBQUFBQWdPTzN2Z01BQUFBQUFBRDRCZDRuaFVKUUYvN3JXbkdYR3VwTmlLNE9kMVpiSEpSVUltUjBValZEZE9GVjVUb2pDZHdQQUVEcjh3TTFNMCtBUHdBQUFNQUw0UG9QYy9DWUFnWUFmL2ptQWhyNjZoSUFQT0hIZCs4QU9ENUREQjJzanh2c3NUVCs2ejBBK3hKd0lSdlJwVWNCa0h3RHJnb0FTSFdwQmdCU1hRSXFnR2dRQUFCZ0dUdm9lVkhtUGJPQlFDRytBaEFxQUVBR2tHajZtVlRWblhHVUF1VEowLzl1bXpONGdCMTg2QURlTGp3Q0VFQ0tMUHlRQVFMQXUxZ2RvUEFlZ0xhclpnWUF3SHNBQU9nRlh0MEVBQUFBQUFBQXBMZVNVUUFBQUJ3QkFBQUFBQUJROGx2SXRveU5penFCRThKTFQrSnBPQy8yaGlkUFBjcnlFQURISHZKWFI2RUNoT0FVSEg5ZUdod1BuT3FpZnBEWHB3Y0FBQXNBNFA0S0FJNEpnS0h6NjF0U1JZOTF2QURNQkFVQUFDekFBbFRJN3M1Tm9DdnFJc3VXelhWVHNXbUE3ZHhBMGZVUFFUVU5BRVVGQmdBN0FBQUFBQUFBUGdqQW44MFBBQUFBQndBQXdQOEF2aWNWaGhiWGdaYldqR2NOZmREbGZwV3FnNnJrZ2c1YWhPZ3BlTUNSeXFsR3Z1ai9BQURXRzYzQnJxbTJnVDhBQUFEQVZ3Q0E5NytlQU5oejkrQ0V5WUd2bmljQjRJMTNIellBZ0wxYU4vNUcvZ0lBd0FrLzlGMHFBWWd1TlFDZkFBQi9BS1FCL2k0QXFTNEJKWUFHQVFBQVdXVWFkZHdzRS9HYUM4RHozQUFzQ3dCTUFPUGNBYmw4QnlDSGNITEtBSkREMy91L0xudFkycmJIQTRBSDhyd2JCUkE4QUFDdmg4VURpRmdYbEVZQXlHODlCYmdEQUszUG1jbmlRWUVDZVFjQUFBRjhHRVVCQUFBQUFBQUFvdzRBQUFCcUpnTUFnTkN0Z2tnWkp5RU1wTnYrWEdxcmh6L0N6cHgrdkwrVUdRQ28yWmY1T2pVaEJIQW1mSDFCNkJBQWhQK1BjSWN3UTFBS0pnZ29jR2cvZklTTEwyNGJBR2ppRUFDY3Z2ZHpkNklCbUttMUJ5REovUDBWUGhhd2hvRnc4THM3MHpwQUNCQUFXQXRydUJFRHlGQURNTFBnOGYwWEFBQUhBUHpoUjRBUENBamNBQUFBQVArc0FBQUFBSEQzWHhVQUFBQUFBSDcrQTc0WHhjNEpLaEI5WFNjNVAwdlk4eWVCcHZCdFRvcy9ZQ09WVU4weGUrQmxtODlHL3NIOUFRQUFBSDRBQU0vVUFQQzdTMTZBNXQ5ZU5ITjQvOGYvRG9DUTkrQk9IaHJBTitjQTRJWDFmd0E0OXJUc3V3SExBL29qamllQ00zNVlBdTRqSlFDSlhTQmVBSUN2QUdtQUh3TlMvQWtBWHdLZ0N3QUFRRDloQUE4QStCRUF1YXdJQU16NmNqd0FyTGY2UDFUN3hta1pBUHoveGlWREJzTEE2TzU2VnZDOVhxWUFBSGpma2w5NHdHdjI0S0hjVXg4QWdKTi8vaG5ncUtmSStQOFQ4SVZNem1RSVduWUg3QmNBQ2dBZUFBZzNwdFBCNHdIdytCQUFBQUJBTkFFQUFLRFNEQUFBU2dtd3NHY1oydzZraDMzYXVodjkvdk1uUCtrWVBxVHRMdmpXc3J3Z0JJaWNZYnIrRTRZQ2dCTVpRamdBQU5UeUR3RGcvZVZ4QU9SeWNIay9oY3JNbXVHcGdBWDQvQzhqUDhNYkFBb1dMK0R5Mzl6blBzTUNXRUFBVVBQRkp4b0dBQUFBZko5OUJnQUFBTmp3RlFBQUFLQUF3T0l0QlFBQUFBQUFmZ2IrOWxSRndhL0g4ampCODl2TDRVS0drdVROTlhueW9JM1NLZG1kTzNHSS9jcU5qUHlEL3dFQXFOUTlKcS8vcEFOL0FBQUFnQnNPQW5DLzI3OWJBTnQrRjl3VkRjZXJGd0RnallkZkZnQ0F1ZmJIMjhoSE9BL01CeWdCQUx6Slh5UjFnWGdBcmc4QUFFQnlGNEJrL2dTQXJ3RFFCUUFBWUFFN0JHdGFYdS9JeWJuSzR5a0dnQ2dKd0FZQWxQVVhyaU9sVUVvcEVBRHdtV0FRQ1FyQTN4SXRHUUErK204Mlo3cWNpZStWOXdBQklFQTUzLzBlN3dFQWdOTDNCUUMxT3QzZkZnOWt3bVV1Z0g4L2hBQ2xBQUFRQXNVbjVRSUE0RDJCRUVnK0FRQUFJTXMzRndJQUFBQUFBQWpXUUs1ekNIU21iYnlKQy9wWTJlTUVwZFJEOTFoVTBnQkl6L1ZxNlYxRkFoQjBOdmIzOUdZQnYva0VBQUF1QUlGM0w3S0pEVTRORE1QS013Q0h1SDM5NUlKaE1RQnJzWUNhV2Y5OS93OEF2UDVrOFgwdUFJQ3BxcXFxSW91N0FBQUFBQjdqSHdBQUFBQUhBQUFBY1AvL2N3QUFBQURnL2UwQ0FBQUFBQUQ2SGg3WEpJUkRYR2wzM1l2NXpXNDJ2eVNDa3RQbW1CWStxUXVCcFVSM3p2cWlHdW5JeU85Ny93QUFBQUIvQUFBQWdCUHVNL0Q4NzFjQTZQY0FBSlpUQWsvNGFBSHdWQnZyZGdNZ0g2RUNKN3l3Qk54ZElMcEFIUHdWQUFCSTdnS1EzQ1dnQm9BQkFBQTFPRnpod1FDd2J4TkFYQk1BQ1FXQWIvczNBaVVIYjFaQm9QS2JQUURnYmdVREo3MFUrVUxCK3dKQThmV0Y0QUdBMUszSkFQemNnVXcvZkY1MmxBd0FFSHFhVm9FTVVBREFBd0JoNDJSUkFRQUFBQUFBa0ladkNIYlpUaGpCY2J5RUJSOEc1eDR6cVNlRlUvdGs3UDhhSDRCUUJHSFFQV3duNy9CeU5nQUk2UFB1VmxQR09nQkF3eXA5YnlJUENSU0FodjhhQU1EUXpSLzZidFJTQ0hINXB3UUFBQWdBVzkwQXdBWUFNTTN0UG9CRmtRQkx1ellBNitXZlh4S0F4UUNBc1Z5bm1tNWdHTUFCQUtaL2ZRM3dlQjdoK0FvUmVBVEE1LzgvQXdBQUFCZ0FBQUNBcnhVQUFBRHUvMzBPQUFBQUFQQU9BQUJBQlI3blZHUVJOQURScmMvcS9xdHkxR0NEZEc5T2xidkNWZ1J0Y2RkVkgyTmtrWkcvZEIvTkFKaXVIL2Q3UC83c0libjY3ZDRiK0pnZmkra0JrTlhqYVFEMjVlVjJRemNBcnZzQU9OWndkOFZ5U3VEMjF3Q3c1L2tvd0RsQ0NaWVhZRDlTQVJCZHFnR0lCK0Q5QVFBQVNHRkFVcGVBQmdCL0FhRC9aaVNMWU5XK01PVjJiL3RPSmRlNW4vY3MzUzM4cFdRUmp6WnhVMnRvVmMwWjc3Tm1LUVdLRDZNOXBhVlF2RkFBU2dpQVQyL1gwWWNpUmNUTGVGSU9yZ29BbnJ3Mit1T2xRT2pXazFhTDkyVHdaT2lYMEI3c2pUTVFBQURBMHBzQWFIQXEwaXR6MndVZ013SEFyNzYvcFhqSVpEaHR1b05NQVFCNDFXc2c0SUcrQi9vQUFBQUFBQUFBY2xjL0tBQUFBQUFBZ0NiK0FDdnZHd0FBY0FDb2FlTldBZ0I1dlVEeHdVSEJ3QXdHKzhKYVcrVTF5TFBQZkFiUWVBRVFjRFQvR3c0QUVPQU9XSXpkQXdDQUJ3Y0FBQUFJLzA4QmdFc0dBQUFBQUlBdkNUNW5WTXNobUVCbXkvSytrN24zSG1ZYit6R3dFWGx2eDBIOExhZ0F0Vnh6UjAvUlg5bktLRDhhK2NKZjRsQ0h3bDZURSs5bTBwaE5CRmZ4QndEMjdZZnZmM2gvTndjQVFIS0RnSlFBTFFEY2QxS3ZyVDQwTlQ2ZUQxaWFHcTBBQUlCRUdWc3ZaeXNBQUVEMXB1ZkZTcVpzN0Jqcm1Ld205eVEzY3BSVml3d2pkVnBNaTlIcmp4NlJuK3Z5Y0pVaFNaTml6ajZmTS92N3Q5Ly9RR1ZsSlFDV2d6RFNDVm81SWEwMWF3Q3dXbjM5OHZ1YTZ6bFJBTGk1MmI5cHJIVm1aYVY3bnZlWkF3QUE0Q0VxNnVEcHFzYzg5cHhNWnE3eGNLMnVMdUR0OC91M285ZWJkYkRBK2pjai92eisrKys3cmp1WnByS3lrdnQ4ZnQrUlpTbVl4L2ZQOStPK1pzMTYvbWNmQUFDZ3NvQzhYdjc4L3ZQNzlXVmxBUUJZVzNkdmpKaVJVTTdLeXNyS1NnMEF3T3o4U3c4QU5Cc0FBTEFjL1B6M2N6Y0FBQUNJUHZUMjk3Ny8wRklBRlpqZXZUSUFBQUR5eXorL1h6MEFcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBcImRhdGE6YXVkaW8vbXBlZztiYXNlNjQsZlFiLzR5REFBQUFBQWxnQlFBQUFDQUFCSGtvaDNMZ052eDV2K0RneHY4QjRBWUZ4cC9mRVFTQ1o1Ly80c0VjWGpjNGgvL2pjYm5tRFJnR2YvL2dNRmczQitUZENCUC8vLzhvUWN3OEJnc0pzaEFTLy8vLy93Zmk4UndmazVoZ1B4TGR6REFILy8vLy8vLy9qSU1CYkdLdmVFT0dOT0NIZy9KajRqaThoT0ZrWDFxcXFEemRnS0VUZEJBYW1BNDRoNjNMRElrNmY4bUpsU2xsNncycFpyRE03TW1UdWFtWGNtV1owUS9aeitRblhmNGRoNmZ6Ry8wUDdYdUtzanVOMnlYY2c1anlqN1hNcGM5OXJkOC9mMzNSZC8rTWd3Rk1XQWZwUmxjRVlBV1pkOTVyOXdjZHdUdGRTeGFGc29OVXlEYlBLSVB6cEdTWlhTbmRKN0hkVHJrWWxzT1JMMU5LWjY5NUNMVlV5T0NUTWF2WWRYcHp2RVNsK255cnFQSkh6dGFNeHdvYzcxaDNmMkNxNTZ0eG1qZnR2Wk1keVRUekIydmYvNHlEQVZoWTVrandBR01hUmZpck9sYVNDUmJLcUE4dE1IenJuWHI4dGVXWFpOMTlPZEZJNDJ6SmIwNjJYck40ZitaZlorWFNZNCtSYzl2eVVqTCtSVE9raG1USHpZMFhKclNPYTB2MGM2ZVI5QjZnbzBTT0FZMllCeWplNGV5YlVrMDJBVVIwTEVQL2pJTUJZRmpwK1cvNFloclFnUlVVamJVcW9BMVI4cWJoNnBheHkydzdtNnF6TWF1Y0s2cjBheWFqSG1jc1gvVWdweXdqbXVyKzdpMi9MVC9qNXJFbXp0MVFPNGVsaW1HVTVDWEl4RXpPaTV1bno2WTZlTzlNUzRnWFV3M1QzbjlrbnMvNW56K3hqLytNZ3dGb1dxTEpYL2hqR2JWQVNZY1NwWWNISFV6SHhVbHVRU2cwcEZVNmNJNTlPTXk4aEpKV1NucFcwVldxa1J0bkkxNmxOOC9xZjU1NnY3dEdJbU9tYzdjb2VSbWJWRW5TNzdHVnNNVjIvdlRLMXRHZTlONHdGdC9uRGEwQ244Zm83Z2dxNytHVC80eURBV2hieVZqd0FHTWExdlZnR0ZidkdkaWIwaUllWlJKSk9zTXpKQ2hFcEp1cEN4V0tRZXJ2ejhGS3hLRE80T3lKTTRrdXRFWUM3MTZrRG4rM1JmN2JQZjgvUzR2OGNBVjdiTDFlN0gwYStsMWtoTFdlbDRHekM0U1Y2cnNtVjArTUhZd3ViZVAvaklNQlpGcENtUldvWXhtMzVBR0ZVUzU3TStPSGN2UFVJcEloVlM3OE1FL3BOMFlIR1AzbDUxU0VxOE0yRHBreVpvY2R3YnRUOTFsblR1dVp6S1p2d3N1OC9mWWxKZENQbk1zeGo4S2dSUU52VTNySGQvK1cyZWJ2bkI3emlPdmdZeHZkOGxOM1QvK01nd0ZrVzJqWThBQmpHdGZ3aHdPR1dxUmhBQm5iaFR0TXVHZVpXTlJuZ1FpNTlEaUdOQ2dPU1pCTUZKUEl1UWpPWjlRMmtrN1g3VFV0TCtmVE85NGh4c3l1RHc0SXE4c3RkOTk4NzVzTWw1L01IUFZ0N2xMNFBXRjJ0ZlhNNzllaHQ1ZjR6SVhiLzR5REFXQlpSNGxmNEdFYTE5a0FDS283aHlRR3U3c2hMRE55Mk5RMzVLMmFNWDlwNE1sM1pTb2lzN1dleEV3ZGlHY3hUV2U3cVZ0MW1kbDg3OVVOd2VQT043SEszOHpMemZQNTNUVzFqZXpPeU15RS92Zm9zK3Uxa2RmZjcvaTFPZGJIdnovaDFadi9qSU1CWkZibktRQUFZeEpXNzhFWW1ncENQZmpIMlp3RmJya1JaMHgrck9HVHpQdDduYzFYcFRPbXBubDhOMy9MTDhtOG1UNzVWMzNabXFIVEJ0SFF1aDJwWEE1Sit3K3BsNnprQi8xeVU5L1hzNHdlOFkvaUpmMVgyditFKzcrdzcwbWlnOWJ4ay8rTWd3RjBXYWNwWDloakdsYVFBSEhqY1E4aWxWRXdodWg5YytmdDdGRE8vQ3pLM3lVaithYVBUcGE1NFlYOWF6azZ2bFY5TzJyNjZFeTVudnMwcUpmczZNMVVrUldsYWhtb2x1bTlXWW5LcGthelU1ZXFzaUw2MlZHa29yMGxNdFQ0bEFPcVd2YTMvNHlEQVhoWmJmbGY0R01UWVFRQ1dMa0luWGxySVpiSXZJNklKVFl5Rm9HeWUwa3ZHa2puVTJ5bkQ1Q3RlUnBOZDg1UENVQ3hUa2h1V0I3cEZVWExIc3JKK3JxaWRrR2ZuRWRwYjZ2QWl5TjJ6ODFIKy9aQzhnNy90aTB1THRodHVwRU1CdkZEbit2L2pJTUJmRnlsMlYvZ1lScEZwdUVBQkdMekxSeXU5cVZzQ0FqWmdHM0RqaUlqUXp1UmNQTk8wdk0wNTloTG1LTU8xV2g2enhoVzliZHNmYVZFV2NJK1hZT2NFNUsrcnQwRkhwWlRnbitPOEZmaWNjZEFlNlpQVGR6Y3ZNN0txRFA2Mlc0K2puZWl0LytNZ3dGMFc2VVpYK0JoR2tUTGNhVmNvQUJRSFZjcGQ0YjV2TTV6b1lzcmN6Z3dSSHN0V0loVDNEeWFXYTB4VFExbVJtWFY5WWFHQ3JPNFpja2dhckpWVGNmV3UvanRaS0lQMGdBR0txdG4vK2s5TWxDeGp3cDFIM1AxZnAxdWQ1M09IN2VETTRPNy80eURBWEJhWkxsditHRVNSYXBHTWJ5L2kzbHpXejhFSUg0WVlPUVRCb1kwUFY3UGg0cjJmY2tUV2ZnUG5JU0poOFhRRGk1aUVZNTV6L29jL1JtVWhHVjF2MW94R2tJMS8vLy9iLy8vL3EvYlJ1ZDN1di8vLzkxZVFoR1VPQ2hDNVA4b0FRUjBGeXYvaklNQmNGY3NDWFl0UEtBQVZTV2pWZE9XVjNMMGFmWTNRVE9BZ0NWeDNGT2gxSDBkU2FpNXNPeWo3NEhlZm9vSFlUQUcrSGYxcnNQd2NiL1gvbjB6NzMzUjhtRjFQNmJmc2FUeUVKWjluLy8vL21sRXhaN0dNUS8vM2NVYVNmSFlPd21Iam5NSEgvK01nd0Y4bnMwYndONWxhQWpIdFBzTDRyWlJ4OHZlODZ5Vmw2Yi8rZ2NlbWZjTmcrRzQzZ2pqcEJIWEo1dVRCM0ZsSkdwQms0a0RlYkNrQklyLy8vL3JQbDVNcXo2aTM1YTcrS2FDb0pnSS81Q0ZxeFllTW42bExtZHYvLy8vKy8vLzdUUzFMTTZuLzR5REFHeFJwOXcvNXhTZ0NXUXJJWXpxVXBuQVVBUUJBVVZFZzhJaUpSRXBKakZTaUdFZzhESkU4VENRZENhOE5UeXhROUhpekN4NkpmYXBLSGhOUkVUQjNXSlVGVlE5Zm0wN1hJaFV4QW1IZVpWUUFvZ2c2QUxQLy8vLzFzQk11ZXhpelAvLy8vLy9qSU1Ba0VibWFxQURBanBSbjkwSk9JcnhjQXFzNVpLRGZsZnNlV2ZoM2xVQTB0NGxFUThBZ0k4N2lJa3FzTkNTUTJCYlIvK1NHVTlTaDJxVnd5WEovLzN1cUp0VUJ4LzZsUXh4VVBDSXdBdzUvLzZDcDRVSUVBSUZGZ3Vza2NFclAvV2ozQzY5RC8rTWd3RGdRR1FMbi9rQ0tjbkVSV3FZVkNidjlJRWtrbUJiaC8rY1paeTdKU1JGRlhLK2c3VG0vLysvOEwvVXY4S1gvLy8vWmZZMEU1aW1GZzRSQjhLR213S0FRYXZQdjZkZjZCSksrODdVcEFjS1BBNFRUb0FBQUFCQi9qK2RUY0cwN0o4cVViQUQvNHlEQVVoQnhxdHYrU0lTV1FLcEZ0LytqZi8wVjZGRllLRkEwanR4TFlWY1RNQjBVRWdFRHhkWTBSQWlaVEZnbXMrUVN6L2JVNzFubFBwOHFCaGVzcVdQTFlBUUFBQ0tvYWpSV1oyWExpNk52dGZPd3VLMGJ6Z0QvK2IvLzM4dTFTQlQvLy8zKy8vL2pJTUJyRWZEbW4vNUloR3hJaU1vOXQwWkdzWXJtRml3d1htd1hVcTJCN2VDRzMxZnJUUmZoMTZuZTlBcTRWUGxUM252b1FVUWp1Vm9nUUhpYUsrZGFCNFNxdi82Ly8rNm9sTHFwSFQvb3JTb28vZFBuUlpsa1lkZ3B4ek80UlFUTkNGOEZIR0JFLytNZ3dINFN3Z0tUK0dCR3RKL1g1TC9icmMrS2tuQkFhRGlEVjEzUWd3QUFBQUFTZjgvbUIwM1lxdVlxZjI5dmwwUWNZeFRKLytsSDlLVy9vOUpUSWdxMy8rM2RsWjFXWG1OUWdURHN4Nk9JSEdIRm9RRldDRW9CaEk1NmZLNU5ZMHh0VlE1VGV0VC80eURBamhGWnZxdjRLRVNXV0VJMFJJUVdwSUlZeld1a1ZBUDVhaGdoa1F4eFQvVXJsVC8vLy8rblMxRnBLdjEzSTJ5NUZwa1hJdTVEbk1VeFRrT3hSVEZaZnNpSlluUFkvLy8rdXJJK2M3MmFURWo2UnlSNTI3VTlpUnl4SURBNFU0bXhGOXFlMnYvaklNQ2pGTUhLai81Z2lwVHQyMkFBQURnTURBSUJnWkZNV3JyVEk2VURjeGkzYi9ZdWxZY1hSNFlXTmNYMm11Q2hLS0NCOFJ1YUY4RExwY0ExUVZnTUxoM3hvRjlBcUFvQVFNQkFBTGZ5SXVtaXkwM1FXYmh0Z2xNY1FxSTd0bFo5blRVd3M0aHAvK01nd0tzVW1iNnYrVUlRQXd4UkxsM1dtNmxNNkJvbTZBNlNPR1hJZVFnajhVdFhkbG9NbXROblVob0Jsa0JvRGdNQXNQa0VGeFo1TUROanZVeVNULzF2dSttcG96Q0JDbDA0VEJFeFpBNEIza1FIbFdwYUdnZ21lZGtWSUlXUTZyUFFJTVRwRVN6LzR5REFzek96NXBCL25LZ0FHWjQwVFFMaFRIZ3VGOTB2Ly82YWIwemRELytlUGw0eE9HUm1lQUJBQUFBQVVOSnd5RVIzQUJ3Z2RGMnRPS3ZtSHE2L0xqVHAzWGQ5MTBWQTVaMmNyWlZiWW1Xb1kzeVprK1NYL2pJMFBOUmpxci9xV2N3d2ZKZ3U1di9qSU1BL0dLc2k2aitZT0FBcE1iR29iYzg5RUdoQWthY3VZLzYzLy9adi8vK3YvRkpJaC9yZERCMC8vcm9lUkpnV2FHUUNxUFIybGc1UkFoZ2lSUlcvNkxKVWx0OHpsNmYvL1JxS2xVbk9KaTUwRGdrSFE4SWlnREdHaDBQQjRHZ2FLdEttTTZ6Yy8rTWd3RGNRd1U3WUs4MG9BRWpYMjIvLy8vL1VkbGdhRnlVa0l4dFYvV1JZMUVGZ1JqYi93cGYvR1N1NzlyL2d4VXl6S1ZRb2twVkNpUVVQSEU4eXYzbFN3NFFuV3BsYXpzcy83RVJDYUJ3V0ZSVUloa0FzVi81YjRTNmdBQUFJQWFnNENLL290UnYvNHlEQVR4RGhIdi8rRUVTU0RrYzYvL08vMFkxRGhGRmtBM081NUJDa2NJT3hLai9YaXpPbklKYnQ3NTB5Q3hzTUtRZUVvRG9wZFZwcUZWTktCd0FBRURnQy96ZzFlSk9CaVd4di9MLy8vbUl1ak1oSjBJNmJqaDdSZ01IV1Vxb250cC8vL2xZY0N2L2pJTUJtRHhFMjAvaElCSktlZTdKd2lYcGJSUjBHODVGQ1F1MDdpaWNVL2lVTUtxOUlKSkFVa1ovZjQ5amFTSW9rcW5QLy9tWXdrL3d6WVFoLy8vc2Ryek01Ly9KMXpXNzYxYU16QnhyTzZLWnRiYnNIdTBqQnNRQ0E2MDZVWUptN2x4OTdmOFpkLytNZ3dJUVFhWjdUK0RCS2xsbzJmL2laa0VUcElBQVV2a0JxSXNGcG9vR0J3SlRsYjh3c2c3LzNVclZJYitwVk1QY3lDMTgyN3VTd1FLWkpYWnJPTE03RlNxVEk2L1Nqc2ErciszZGI5WC8vcEpsZFBmL2Qrbi8vNnFzNXBoeUhYTWYyVmlBUUVKYi80eURBblJLaGFzLytNRXlTK3pma1hqQ0NBZk1Sbk0vM1V6NTJZZllLT2ZvMnlidGRlakpEOTJCaE56TXRDMlVSSFNqa00ySkZJdUFBaUd1TkVyQjdOTnhVYi9vanlpZ3FPUFVvWnQvU2d3QlpVRkR3dWp1K2tBQVFraEx6TitRclllRW9kbjFibmYvaklNQ3RFM3NXcC9nNVJMcFRPUDVmLy9iQ2g1R1pRczJ5VzRJQjBNcllrWVNRd09aa1Fpdm95bFkxWFJncklhNk01cUkzcWVuN1VLMy8vNkpUZHFWU2VXaklucDA3YjVqYlRJbFlZNjhVVWUzaWdGQVJod3FMa0dvWktrU0ttMis5Vy8vLy8ycXQvK01nd0xvVDRWNjMvam5La3F1YVloaExzR0FDRktwa1ZUZ2FCRktCakNoaHdrRncyQlJSNmg0dzZOQXJwYUV3eTQyZnEvL1YxNnJPckZIcU5sWGowSlBLRkFRR3VFQUFDREdXQ0F4Q2dOTGVaaFpnbzBCaUlFd1JyNGlCcDlrV0pmRVAyNFUzS0p6LzR5REF4UlZiRHEvK09NUzZBeVZuY2pGR3BUTThseGhBc0xUMCtlRGwwOXE5RXBGTG8zek9NVWxpOVo3M2U4ZTkxRDh2dDRZWTYxcmY3enc1ckRtV1gwOVBiaHpXV1dPT3Q0YTF6bU9wWnhya1U1TEtURE9yUzdwY2FTa3ZkMWxqVnBhM2NmN1lqZi9qSU1ES0UzbGVrKzFIRUFMVDIzOGRpS1MvS3c3L2U4NS85M3JMODhzdi9lRjJYOTdsakQ4L0xMSDRZYy9mWmZuM2xlL1lzWHJlZWVHRkpJN2VYUC8vLy8vdjZxOS85MjNjZnlLTy9HNy8vL3hPVkFBdUF1OGhIeUN4amYvLy8wL2VaTVU4eS8vLy8rTWd3TmN3ZTBiRVY1ckFBdi8vLy8vSXljODg4ODg5bFBQUG1YVTl5QTBSWkVOQlhJU0lhT0xBL0M0R1lxQ29Jc2VpMEpZYVI4Yy8vLy8vNXREanFYNjNNUXVjTEkySkRIMG41NWpLTXhZRmdFUWZ6eXk0Rm1NbFRwUC8yT2ZvanJuWDZPYVlUT1AvNHlEQWNCWkxVeC81d2xBRDF4QWhNQkRENG1XakhUVVo3SGhQRWRLckt5d0dBRGdRVW1vbUNxR0ZLRkV4Z3pLTm42cXJONmw1eXJHOWpiTXRwbHI0VVNuL3k1OWpyTDArUkNUMjhzMGlqc0FCNGx0di85Z0ZCWHlzVzMvNk4xOVRPVjFwK1V4MlN2L2pJTUJ4RmZvMjRBQnFoclJjYWlKWGJiS2lsYVp5dFEwdHFsZVl4akdmS3ZVckt4akd5bFV0eXNqOTlwV1d6bU1iLytrczByaFJJWUNGQWFTQVNLVVF1dmYvNWc5ZFJKcmRLeWZOb2YvZk9xS3o1RHMycFdCU3ZvWXJUR1VSWXdTREgrK2lWNkVzLytNZ3dIUVNVcU15ZmlpRXRxeUczS25aM2lXUmlMUE9VZFNsbzQ2U0xLZlFhRm5OL3RJR2lKN2Rudi95d0ZBQkRWcXNKa0VGT2MxTlc5REhRNENILy9zZ0l5Yi9yUGRWN05PU3lQbmYwck96cFZkcXNkWTZmVnQvUjNNNXRVWisyQ1p1OVZRbUVkLy80eURBaFJLWjZ2ZitRVXEySUgxR0dDZm9vRlVBV21yOE10N28vU0xDb3ZHY05XUXFDWkNkM1AvLzlxYXNyS3hPNUZhWitkMWNpSTdEUmRDVVYwWnkzSlB0L2Y5Zit5VXM2VVpKWld1b1FPaHhjSHdrQ3h3OHNlYk5GeG9CWlYzYVUyRmdaVkZrVmYvaklNQ1ZFREl5NS9nUVJMYWZOQ2dkWE5xVjFFUlJ4N243V1pxVll0cnFabVI1b0VJNkJtSEY2VTBWLyttZ1FuRGkxb2NXTEhwSTd1YzhoQkN5RXFmUVFIRm9VNk1UNS92UmpwKzl0NUg5anYvYlBiWnRBWndObEZrVU9CaTBBeGFvUU9CaTRnT0svK01nd0s4VDRrTHorQmpLdG1jaEZCQVowSkJFVURFS2VkMElJY0FBQkRKQkFFcUpxSllDQ1p0RjJkTW5CaFNpbXk3bTdLaEZaNkxSa2MzdWtYamtaZi8vNU5KYVNrdnlNWnNSdDlXTTdPb0l3b1FjU0pCQjBBd0IwRnVDYkFjUGhGK1V0cjE3dnh6LzR5REF1aHpiZHZ2NEtNVGI1eWk2SDJVMHVQUHYwR1oxWUNVQWtrVG04TDA1QUdBaGtzc29DVjNxUXBVUU9vMDZJTlRLZjJzRk55S2xSS3BIUEQvNVAvLzV0c1poWGVTa3pVMWdVYmVqdzZLL1ZsYy9lSjBIbjg1YU9QOCtCMFBaRCtPREhULy8vdi9qSU1DaEZRbmJBL1lvaHBZV2lHVCtJOGgvbWU3NndHa3c0a25yS0NCZ1FNTUhMcWNiN3JTWmVwUlhrZFdaOUVMMnZlN2tkeFgvYVd6TXpIdHJMLy9uSjZlZ2pkOHpMdW5kM3lMazUyK2JadFBwRVJaa3EzNUdZVmdxRlhUd1NQTnNMSHZ3YWcwKy8rTWd3S2NWa0JMeU5oQkFBYUZpd2RCb0ZaRi9NR0U1SEdrRUFFQUpBYVRiV21mdFg5dVFVTTh5YklTQ2dDTTNoclNCR3RlUWloRzBPUlRLTlB5Yk1kYnBnTWpjOE9QUWlwZkJaVmpUZCsvZzc3dnFmOFdpNy9HY21BbzZ3M0Z5K3Fhbk5jcTZjS2IvNHlEQXF4WTZYd1ArT0lhMnB2dUtmdjMzL21VMlExWTk3UlBua2tUdnY4R1ZoU2lnYVRWR1dhcitST28zdlN2bkdhUkRYYVhiK1JvelV1a2pIS28yaElXMlRwN1RoLzB6dkpWMnpPdVowL3pwL2xxZE9mbnA3WVZhVU1Bck5KcjYwVE9kdi9XVjUvL2pJTUN0R0xrU3kvNWd4bkdxZFFUck15LzYrTnYva0s3MUxmcllhR2tFTlVVS0pFbUJPYlorYkszbXpwZGl5c2NxVXovL29WRXlibXZ2MjBadmg3UnF2ZTltNWRTL3hNNnRaWFEwSXVzZkM5N2t4dzkrTG4xemhGcm1jSld1eXZqYTV5TFVYbHA3LytNZ3dLVVdhaHJEK0JqR3RUZExuT1dydmVHdmxvYjZydHYvWFRmN1dCeCtocytnQWZHNzg3T21tVXgzMytYa1NKemFhUGRLMUp4enYxRHJtdG1sN2lMcS85dXlSTzdJM2hLbG5HcnRlVVJQQXEvUXFNdnhseS81dTRJREZMdWdJTktqL0lmL1lUMy80eURBcGhjcWFxbU1HTWExcFFoOXIvN0VNUExnd2dBakRSck5RaEZRaEVRaUJRS2pVM0FLTVd6S016eFFQZlk5cGIvZlFxL2ZhWmtXYm5kWDNWeXZwNktMeU44c3poTzRqZW45MnJKRTQ3b2hsQ2lrYnVPcEY5NGlSbDg0MFE3bDZFUmRSQ04wNmYvaklNQ2tGRmdHb01OQkFBR2U3cjlMRm5OeXJ4ZEU4T2FSQ3VzM1Focmt5Z0dIalFNa2orQXlRUy9pNGNDSklMQXFxWHdXTWhsb0JYbEdqalpGbEN5U0FvSTFhWC8rMSs3Zk5ySEpXTmJya2g5WDNMTDlwZlQyelltVlAwNHRoMzVUTEt3dFRsTDIvK01nd0swZEl5Ylp2NDBZQUZDSlM0elRPdVI1YWprcGw1VnlobHhxOHBkd1p1U3cwZXlnbUJvd1lVcEdwSGhVTFpqbFpCTmgwTTlQM0kyWVF1ekVnRVhBQU5zR2YrQmlDV3pnMUovLytuL1pTOEYvLy8vLzEvLy9sMGIwUk5POWFXNkk2cGxvdlVELzR5REFreHFMTXRUejBoZ0Jkd1R3amhpakZLcDFQVmd3WnlDbk1XZ295bWlnUU1yRkhDaFFSRE1hS2NpbFd6TUZLaWhsc3JNZ2xGS3llZ2F3ZWxTMUtKUUZRcGtyRjEvL24vLy8vSFAvdWYwdDZPVDd5K216djNiUkhUKzZIcHF6bU4yZlowRFdYUC9qSU1DREZUdG5FLzRRUk5zMUhwOTBjTHlURit1L243MU0rZmtFVnhxL08vUTkrV1dMMytkLy9Wck1LWU5JbEM2aGtLTWtlSU1DYWFmK2lwTEoyaVkzR2hScFpWQXg3WGtOVmdaMmhra1ZpUU9uSUFGVmhvRlJ5ZmRTS2lyVkRualRsN1JFQlZuWC8rTWd3SWtUQWc2d0FIaEV0YUlWZXhZQkFTaFlrTEM2ekxGM3BNaEhoOXpXZW9NLzR0YjMzalF5Ly8vLzYrWi8vWHZRMHlmNmM3WE43L01hMVI4bVVCZUM4VkFNRmg0K2VIaTQ5OEgxTS9vdXU5VnpMMG5GNm1icW5kK3dJaGFKd01GZ2hseEJ3SFAvNHlEQW1CTHdLcVFBdzg0RU5jcUd4TTNYeC8vLzIxVDNOandGelV0K2xaMVR4MUhOOWYvL1h0bzFqbUE2QUFYQk9tSHF5S0Rvb3QrMis2OWYvZi8vNjk2Ly8xL3YvWC8vNjh1bDVoUkp1QURiWmdLa2VMUG9Pb2M5UUl0Lyt5WFd6bnRPekZaM2IvL2pJTUNuRVJIU3JBQjRUcFRHQUF5Ti8vb2prOVAvLy83dUJJQTkvcTMvLy82OHpwWFpOMldobnVqb3FubW5WUTEwYXlaaDdzZXg3bVZPYzk5VGp6M1Yxbkhsa0JGRkp1U3kxUUFIaHhkLzdwblQ5c1JvY1lSdHBpbk9iU0h0emdyNFVTSFp6WUpZLytNZ3dMMFIrM0s4QUVIYTJmQWV4OWZHYmFrbHBtQkpMSjliaVEyTWZpdGR4UG5GZC8vNWZ4NWlYM1RVUjNaV1YyMjVqSzFhbm5udWNGampPbWlFRmo2ZnRiL1ZFbUxlKzZlNnQraUgzTWVrZTc3UWhidFJjTUpvMGJYOVNXdUJsUWlZblRSNjJ1Ly80eURBMEJURGJ2ditPVTdiWXBBbHhCbENnay8vLy8vOFFoT2RNWmY2aXIrL2ljNzcvbzZtV2FwNzQ2SlVhc1hRQVpQNk9hUWhyVW8wbUZUVlJraFlWUXBTanlTYVdCQXBEN3pVSWtHQm9LS0VnQU5YM2NRdnkxOER0dC8vLy9mL3FHNy8rcDMvOGYvaklNRFlIZkxTOC81N3pydXYvOW5Zem9wWldjcktHSlQ5RFBSLy8zWGx6c3l0WXpxblJGTWhkNVdWWGRpVElJRklJaVRISWRzV0sxQlJwa0dxenNWUFRrZUEyd1lsQS8vLzVNRXRzNS9VQkwrZ3NyZi8vOU52b0xiLzhZTS8vaVgwbmNucDk2YUkvK01nd0xzUjRiN1FBSkNPbEdEZ1pXWCsyYi84cEg3WmI5VzUyVm5JUXp1cE5UdlpsM1F4blVTMEp3MVlLdC8xd0hXRXRqRGFROVI0a0FJUUNKZ0Z2LzRqeGpVUThqMEF4OTl2Ly9vOW5JN3NiNHdhUXlmK0lobi96OWtxT3RiN2Y5VFF5djl6dTNYLzR5REF6aE9MR3gvK0tVcTYvc3dxUXkvTmVmOUUxTXJVdTZueWh6RngxNG8vZ01JT29VSzhkdFVHVmwrMXpUS0RBa2NBMzRkdHYvWi81R0NtN1MrRHM1UmF3dlV0U1pNTHg1K3lrVHBnYmwwR0FHUWN4SW1Sa1RTWXRCMmMxQlhCNm1TLy9TTmYvdi9qSU1EYUU4THZJLzQ0aEx2Ti8vL2YzT0hQNy8vL3hQLy8vNlZaVjlrMGRFUldTalVYcHA5bUx2Uk82dUFZd1RJYm9JWmdBYnlBVlYzb1VWaE5UbnAxQ1NmVXRqejVrSnkzL3lJV2YrcHdWb2dQLzYwVHl2KzVuNTZYK2RkZitJZ2svOVdhWi85Uy8rTWd3T1lWaXI3ekhqbE91YUR6K2pmemVyYzFuUjA2SzEwVE5QTmNXME5PbzVpM2Ziem5iU2RzQ3d5aVpJQUhnbGtyLzZ5a0RTQ0pWRlhGbC9NeUR2LzhXcEYvN3NiamxBMGlqS21UZWpkMUYwVjRkNzMxK3hIRlQ5Zi85M1J3SGljYnVaLzEvL3ovNHlEQTZoWmpjeC8rSzByYlR5M05WVVJUVzFmOVZjNGNlWXFMYnZmNGwvV2l0ci9wL3dieUhaWUFBTUNvd0kvbjA3clJTN0Jaa1oxRytPVDZCRnYvb2tZZi82aXlNcUI3QnZScWw5WE9qbERhZHY5SXVyK3YvK3ZIakVKVy85Zi95b3dhKytWWnYvL2pJTURyRlhObTN0NVRUdGh2NmxDNXh2UlgvOUJTWC8vL292L0NSMUNnVGtBbFp0NnVvekFMRTNVWmtKbzkvVTRxRGYrb2xEUlArZ21UQlRBMzBGZ1RWLzFodVJ3TjIrNlJiKy8vL1RjSEJhTy83TTIremZsUmJNWnZLbituN04yS1d6VCtodEcrLytNZ3dQQVZnMmExUkpVVTJUQWRhMS9wL3p2K0lmS0FBQUFBQUFBQUFPZ0JPQkh5VDY2MEdiV1pBbENKSWxrbUxEbWZIMklKLytveUk0YnlUL3V4OFdvR3NVVHFaVmY3a1dEcGIvN0dZNHZ0dC9kMzBxZUxRVTdmOHZRMy82bWtxdDczMVR1ZDlrTC80eURBOVJRcmFyb3ViRTdZSldaLy8vT2YvLy8vOE5Fc2dBQUFBQUFBdUFzQ1ZtR2lpbjdBNXgwZEVaTHJFYmZwbWdyWlAvNCtoZ2Y2MUVxUkVEZzRNMFZYVy84d0VLclMvN0VQTWZYLy8rdXdwS2IrdEtvbnYvMXJxVC9PSmZWOS9RT3QvLyt0Ly8vaklNRC9GTnR5c01aczFOai8vVC8xaTJrQUFBQUFBQUFBQUFBQUFBQ1JBQVRRWmVROGJ4OC8vRU1DUmY2a3I3azQzNWtKSzMvWmlNR0QvV3BNbUQ0R05TQ05FLzdPeGVCQ0VKTTJablg5QXFtWDIvLytwcUFGRm5iKzFCd3YvNm1pS2YrVU0vLzkvK01nd1A4VlcyYWxaSTBVMlFiLy9UK09GLy8vLy9vQldTQUFBQUFBQUhHQUJDQkp4c2lpcDFJNnpnQTRLVnlQVUorM2xrVHVsLzhkUk8vK2ZHT0NGeUxKTWtWZjNLQWhDRnJicVYvVEh5UERkZi8vMVFqQWpMZi9uUC8rWWQ5SC8zWDBvZVV0Ly8vLzR5REEveFBqWnFGRWJOcllJbi8vL3p2OVFhcUFBQUFBQUFBQUFBQUFkZ0FFK0ZFM1VwWm9nbDJDbkl6bFpMWTRQV1RBaE4vMTZhemQvMXFJOGdvSElnT0VhcFZOOVprSi9DOXkraitSWWJEZmIvLzFpd0MzL01HaGxIWC9zaHg2YzlpbzY5TzNtZi9qSU1EL0ZXTm1uZ1I5RHRqc3pmVC82cS8vLy8vMEFOVlFBQUFBQUFCaEYwRWRGSHFNd0FyUytvbWlJeFAvVVE0TE1uditpaU4wMGUzMUdaTUMxZ1kxY0tVTjI2WDBRMVNLamYra2tNaVN2Ly8vMk5CMkhzLzhvUHpodC8vRWRmMVQvL3prYi8vOC8rTWd3UDhVWTJxWjVtMFUySEgvLy9yL3pRQ2xCUlFBQUFBQUFBQUFBTEFCTUFzbW1TU1A4NEFaQ2tpWUR4ZUZRYnltTEdmLzZDUXJJOEwvMFRZYzRCN2NRYWt5cjlkWm1KeUdBNnY2MWl5aTk4My8vNndCUWdJLzQ4SlZRaUxmL01HamZzWC8vK1gvNHlEQS94VnJhcFlFYk03WS8vLzRtYi8vL08vemdCUUFBQUFBQUFBQWxnQUZDaVhUTkk2cE4rd1g4ak9jSWRRYmJlWURsZit0WkdqQVEvclVVeHpRQTBEeEZWMi9TV1RJeGdYWWNXN2ZxR1lKLy8vL1ZxR2c4UmxuTi9scWtaYi8xTUZvay9ULy8vL2pJTUQvRkx0cWpLSnREdG5Kdi8vNXhiLy8rcC8rd0wzQUFBQUFBQUFpbWFQdDZqTUFLMHZzWmlkTTRWajlSdUhBbnYrcFl1eEdyL1VtemtNSFdCajNnZlF2b2E5cTNIOHNpbWx4UGQreVl6WkN2Ly8vK0ZUQmtkWCsxTXhiLzdwcWY2di8vck5QLytNZ3dQOFU4MmFKWkcwTzJQLytWbnYvLzZLdjlJU1hPQUFBQUFBQUFMWUFRSVVJRVZDZG5SZm9CZ21pOFdMQ0QrZEZMdi8yUkdmVzdkdXRJaXdGWWpJbXphdjFpTUE3Zi9zWWx2Ly8vK0dHYi9tWVRjaStpMnNvOVRhTXh5WFJiSXRxWFpCd2ovLy80eURBL3hWemFvb0NiSlRaL3hILy8vLzlnbG5BQUFBQUFBQUFBQUFBRUlBUlNjMlMzOWd6a1owUXNYaUFlc2lnY2tuLzZ3dzRrOXJhNW1vanlDQVNpQmNZcU9ocGV1ZkRmamRDdGF2WWZ4NS8vLy9VQ3NFSmIvUERrcVdiLzBsRHYxVC8veUluZi8vaklNRC9GVHR5ZktCdEd0ai8vVC8vL0tyL25CTnpTemdBQUFBQUFBQ1VDU0IvVWg2ak1ESlRuRHR3MjM2QmVEalQzKzYxQ01SWXJmUlVaa3dPa0RBc2hBQkZCYi95Z0tFSklyMlgrZ1hpby8vLy8wQ0VkelAxSDZnUmYvME5FdS8xLy8rcE4vLy8vK01nd1A4VWcyYU9KbFRLMmNyLy8vMi8yQlNKUUFBQUFBQUFBQUFBQUhHQUFJOUNPNDJkU2wvVUZBYk1vajFpRWZ5eUxHLytwTXdJOG5ML3JtUkFnRjBZYUNmUjFlcEl5RVppUEVuYTMzR1pIai8vLzg0Y0Y3ci9VZW9BZ1hmOTVVSlRpemZMLy8vLzR5REEveFVyZW5YaWJSVFlqb3FmLy84ZGYvLy9UL2NMeVFBQUFBQUFpWUFBaDBEU3JyMTlnM0hIRjQrc0RMYkxKZ1k1ZjFNdFNLUktqdGIxYkhETXFnRGlOTTFUL3JrMExRRjdTMGZUdjlFVUVQUC8vLzhiQUxILzhzcUYzLzkwUElXNlNoVjY3Ly9qSU1EL0ZGTm1kVUJ0RHRqL2xSTS8vLzMvLy9xYi9zSkVnQUFBQUFEMkFBUllFWWdScWhqTXZxQTY5UXNZa2VwdzkxdnBXU1drWFRGSmF0bFdUUEpBQXdJSWZaSmQ3YUNRdVlnNjlmNlJPRjFMLzY3TWk5MWc5QWU2S3pzK1ZFdGppeGR1cVdkbS8rTWd3UDhWaTJaNkpHME8yRUdESFpGUmpqRGx1MUZaNmR6U3phb3I2K3FzN0RjOUZhKzlGVC8vOFZvYWNSV0FhQUFqazZoWkJxNzFCTURaWmdPVlN4citTb2s1c3o4eXJTWTRQZ2FmWFc3NWtKVUJsNklBbXkzL3JRR1pKNU5CVmYweG15SlAvLy8vNHlEQS94V3JabklrVkpUWS9OQmVDNkhmOE1SQlNnaUgxMjlDZ3RHTi8vLzlDZHYvL3hpWC8vL3FaL3NLbTRpU0FoUlVBaEEvRTFjWC9RblcxQy94WldwWmNJNzlYZHhyQ3JTZjkwRE1mQUhtSUhQUC9Xc3ZpdHkrYnZ2NjBDS0UvLy8vK2dUeFVmL2pJTUQvR3ROMmRnUlV6dGtwK2FMTW9Fb3QvNklJazc5VGYvL0trMzM5dlY4VkJTdjEvL3IveC9RQWtRQUVReVVhdXVyMUxEWlB6b3ltWU9yZFNRbjF2MUpxeU9EZ3FUVzNSU1BHZ0M5aHpqVktydlZNUkpSU1NicS91U285UC8vLzV6QmtBdGEvLytNZ3dPNFd1MlpwZ216VTJaUVp4SExkL3JLQlFuLy8vK2FXYi8vNkNCLy8vN2x2K0pGUWpRQUVXREtSWXdTVzZYVUV3UHpvOEtoQm44NkhUbTE3VTAzdW1ZQ3BKMldwcXo1dzRRd0NQUllTMmVTL3NpUmdVUVZhbEpkZEVnWnMvZjA5dHR6R1kwRC80eURBN2hXTGFtNEdYRlRZc0dFUXl1N29ZcDVoYVkxNkl0a0xrREdjODQ5RVpWZG1TWlBwMEs3MVRQWkxQbnpCR0lxaG15dWhpTC8xL3hleWp4a2Mzb0lBZ1JjRmlCQTB3YW9wZncwV3dsd3I2eWdQcGZkcVZLc2ZCOUo2bExSVWxNUnFnTTBiU2YvaklNRHlGV3RxWWdKc3p0aFJaVDB0cEZCU3JJcloveTZUai85OGV0UmV1dnQxd0EwaFBXbyt4QUVxd2V0ZlBGeXVzTzNPelF6U3V6Yld2dDlaTVhmK3ZGOHp0dzBram1hYjY5cmxldUwrS3FMNSs1RHdhT0RvVkhRZ3RaQ1l3REE0Z1dQbEI4eFgvK01nd1BjYzgzWmVCR3pPMmQwZ1JlVUozQTZ2VVhoa1c3TFVrcHpOQWFoOVh0MGtSZGdKZ2JUYi9kU3kyVzNiL3BHcldvOWtyblUvMktDd3QvaVlFblVYdC85RFA2SzN0OXZVN3ZSYk5tL2poanRWVTZOLzIvNHpWU0xncFFBZ0NDMHFuTlpjYnEvLzR5REEzaDJqZW1vc1BGRFpnV1IyWjFBbzZ1ZERqZnVpZ25XcFlueGFuNkZic2tKK0R2Qi9XeW1WMUxvRGhFclBxL1pVWVFvYnRhckdWcWFkZjZVRUhmOURoWXFCbC8vUkM3ZE9odnZ0ZDlLang5N010SFZMbXNaSWlYVTEyNkxUMm1KL3hyeFZ1Ly9qSU1EQ0Z0dDZaalk4anRoRkczU0JUbW9oellQcXZXU2lyYVhyYWFsWVpYNWdNeTEyWkpab2ttWnB5M3E5cDBpaVdoclgvOFRNVzMvelpIci8vL1YzQkIyL3FOYUJRWlQ5YW9nNlI2MVZuWC8va2RqbW9pSG95MjBpc3N0RFZPOU56bTV3MWQ2TC8rTWd3TUVaUTJwWmxGdFUyVDhKamVtc0FMNmRpSGphK1ltV0hidmtDcCtKSVRhUE9sZGt4b3MvVXFtN3FXZ1pyVHFaa0VGSGh6UUFjSGFUZTY5V3FPYVFBMWIrOGZCdGFULzdWNzNVSUF5SVFoQ0VXd3VjVEZ4YzdOL1JUU0l4Snp1cnFldWx2b2YvNHlEQXR4aExhbXBXVzA3WjdGM1U2NzY3TlZjcEhRaENPN25xdDJUcFpBNkpuTUtDaEJEV054czFBOHJZRURwWkdONVh6T0lOaW9TMXB6Nk9WRGZ5cUduRjJPWU16dS9vSUFTTU9UL3g4U1cvOHFTenVoclZ0Tk5lL2ZIeEplNlByUUVEUjFuK2lQL2pJTUN3Rzd0K1dXeGNTdG1PY2FhYXJWTEduWHJYUTZpVGpzcWZWdG0zMTV4eHh5SWh4dnIvdlQveVViRFlhTFkybW5DQVlqSkJNTGFaU3BGZENkTGdUcmhMQ0RyVFVWTFVrNjVncWJ2U0d4UHE5VWR3T1Vzci82aUllZnBWN3NuVTJ6MFpqenIyLytNZ3dKd1k2M0p1VmtuTzJXWCtJaDd0UitlY08xQndkK3JlZDUxVmFlejVscmQxVXpQYWJPcXkvVmg5blZGbkhvN0pzbnU5ZWNmY2E1b2xRTFpYSFpXQXExZGhsSWxNK1Y5cG5CZm5TelFic3pzNHNzcHZPVTAwNDB3UHBwMy9Cd3QvK1l4emY4Zi80eURBa3huYmFtSmVRMDdacHo2WjZJN2FIUGI5eVFtZit5bllXYi84cjYxT2ZNT1pkRnpWdEkzUjlNczFLb2RjVXFlcUsvTW9ZcnYwb2xxWFlzTm40b0Z3MXRrbHRxWjl4UWk1TkVKOThJeDB2QVNSWFBLaGJlY2FjNWhyS2NlUUFwTUswTytqc2YvaklNQ0dHQ05tYmw0eWp0a3YvOS8raW5OLy85ODZqdUtSZW5XbXBIQ0VzOUhlNXRNV1BSMVg2VVRkR2RtNTYwT05Sa2N4M2NlWnFLYVNOZWFhNXFNZXpXTVJYbk90blh4Mjl1TGcrKzExMnBEc2wrQ3VSblRGemxVZFNna29CT1JYY1lFSGJrTEsvK01nd0lBWkcyYVgvaHFPMjZ0QnJzVEw4NExmLzdDMzZmYXkreXZhcnRRaTdLb1RTNm8xbEEzQ0VhM3I3R1dTcm5lbC9aYmIzUk9pMXBMcFlpMFFxdWQyWjNiMTJxYnR2bUlTb3R4QXFtcW9HaW9aN3BMNUZNTGVCeWdDU0dPeHdYcHVxMVV5ZlV2LzR5REFkaGJyZm5wZUdVVFpxYTZvOVdQVUhRbEZIc2w5cW9LNWVpZk9zcHRsVXZlMmRXVlNHNk9MbVlyMUtaWVdKS1FjUi9kNjh0cm1vcjBkVWV6MjNhVk5xTTIydDdjM1RYZjNmVisycUtpa2NXTWsrdWJVUVhGeUFHejBrSjI3V0dPYk1ncU1SLy9qSU1CMUdJTjJWWlFhaXRuaTVMblRIbytKMmExdnBBT0JDLy9qbjBvbkVERjFlVjZJUTVEdC9sS0ZGMVh1SWdXZ0Jqay85Q1dUbFJFeXZSSGVxUFErOVVSa3NpTW1zdWpUSTdqMG5mOEwweEMrTHF0dGRHaC80M0U5c0k5Vll5cUhReUtqRjNSZS8rTWd3RzRYYXc1WnRobkt1YU9lNjIwYVJQV2VQcEpPdE5iS1NMZ1FZWmRNeFhPZWNEOFdaOStsTzdLenV4OVY2UGEycWp3cExIVDcyTlF1a0lXdlVuclNacmJJaEZKMDJlSmlWUk9tOEF5aitRTFN0amFFQlFXS3BXQ09JdHAxaGU3WUdDZytrRG4vNHlEQWF4ZVo4a2pLRzA2MGZtdk5VUU1mZDNFbnpJMVhjcGc1OTNRbjBNTi8rTVhWYjZhUFVuZHY5bTE1amc3cnQ2dlIzNVVVbGsyNkpvWXhMa1JYZSs3cW8rYndTOGV1NW1YMHRQdWp6MVRPNlhmLzNWT3hJUHZxZUM1L0F2ZW03eVdwR1ZpelgvL2pJTUJuRmRxV1lsWVlpclZwVEhubHF5SXlVemVkSi9jSUN3cTZLbjd6bVJaS3o5blJVWjg3Q0tLOTBJdGt1U1VZbXl6K3d0R3M3YzdOdHU5V29YbDZhTmJnams0SEI0OStTL0ZxdSsxL281TFQwOHVjeWluZ256Z2t4M1hET1Vpd2xWTWdTaXEzLytNZ3dHb1hLYnBabEJqS2xicWlPbzVxNmxzUk50YmFzWE4zTlhNQ2tNTHFVVzczMU1adHp6MGJ1WWN6T3lYYVk2S2lJZlJsNXcxMzc1UUVzbVhMdTNLZklHMEtlcG80RHhhZExwSTc3QlpqTHFYdTRzOUxMUkdaL3ZhOFByOE1LRTJKWVhIbGRpUC80eURBYUJhQjlraktHczYwanF4V09qanpFUTltY3hKRmNvK2RtSWJxa0FYLzM1NVVTVGRKRzY2b2hIZWxsN0syakNhZDlwa3FFQjhMVzExMzM2L2lzRWZuNlA2K1hpbWFqRTBuTzg5T093a08rbjVISEV2YW0vemNRTkREUStoT0hZKzVKMVUzVGYvaklNQnBGeEg2VlpRUlNyVno2RktwU2xxVFp6Rkp6WlMzV2hWUUpvZGJLUE1qMWRJcEl6SWt0ZFVSa25ra2s4aEVWM0pXWWpyb3ZVdGdHV2NrcTFWNytPdnFUOWh0dGVnbHA3ZEw3ZmV2MDRoNWZsR2oyYml0WDNEMTNnQ0NJL0tKUk16aUVXeDUvK01nd0djWENmSkFBQnRLdFpuMU5za1dpVnFzdlhmVnJWM1V3enk4NGdnK3RXdnlUOUF4SnRITHR5UkxTYXJJbGswZS8xU1AyRnZ1NkZ1Y0ZzaFo5Z01kQ2RiLzB1WGR2OWtxdnpkaDYxdTVERjdPaS9yd083MWc2Lzl3VTd5SXVJMG00MjBQcXFELzR5REFaUmRwNmtUS0dnYTFVRzZreGJJZlYyNXdYSWlrVWp6TVp2M1lwRVYxd1l2bnJ2L2YwbnM1a3cycEV4ZDM1bFo0ai9ZeTRTMkxEYzZjRUZhWk9QV3lmOXhIK1NmUzJNcXArbi9ZRjNVWUtQc3M3WFhhdjFiZGJybGFqWlJkWUcyMmlrcURTUC9qSU1CaUZ0bm1YLzRZaHJVQWdCT3BZNWIrdFErZis1dTduMCtPTFdpQmQxWll2ajlRWnUvL3ZaLzU1SE81UDVtdWZKMy9YYXoyY21XSVoyUWxrQ3pRay90NjA5UzdUVC9OWWN6SmJMaDRlY1RLRzFzaVEwMVI0TmlwNmxtT2FwRG1zY3RxSnROcC8rTWd3R0VYUW9wYi9ob0d0QXlvSTR6NVVvdlREM3BrZTNweDBxdzVZWm9WbkQ0Zi83QXhjK25aOE02L1g2VUplNTMrK3ZzL0tmZjVMazB2OHlhc1dGS3I5Vi93aDZBbkovT1hFMnZkN3ZpTjBiZjkvZVI2Wi8rVnhURkx4UkJuSkprd2lUYVNTYjcvNHlEQVh4WnA5bHYrR01hMUFHTTVTcTI2WnlWem1WU0VmZkp0b2R4YWlkcXVDblAwTVY1ZVg1TmxjK0VXMnJFWCthNnpsU3YxRi9UcHl6SlhRb2xZZ3ErSDJOak5XNzlJVFhLRU1kc3ppeStsb1N3L3ptcjk4L0NQZFMvMzYxdVhSa1BWSUlybTZQL2pJTUJnRnhvQ1Yvd1l4cldBTUFyWUJCR1JSbVFDTVRJRUR5dWRtVHRGTXREeEhNdHFBZnU5SHFheEVUNnpOMG5lOW1sOHMxaDJmNWZsV2JzdTZ5MnZmOW1kV0MzaHJyZlREZzhVWmV6MTQ5QXl6RnBJK21lVFhkOUN0L2t1MU1IbmpDMFUwcEcxLytNZ3dGNFdRTDVUOWdoR2JhaW5OUlRMNXdvNmx5R0xtM1FVZXdybDlUS3crbElONFo4MjllL3Y0TC9mWk1oUkpLOEpOS3pPeS9jSDhmODBQK3pkRHY5WGg3cmJxNytCL3JmKy80czNyeHRWUVYwMTNHcTg3bkF1L0NwcXBkZ3dxcjBsRXdURGM4VC80eURBWUJXQTNsditHRVp0d3I2c2ovNnNhL1VxQVRBMGFZQ3BVN3hLRWc2SlQwcU1Ca1lEUzNKaG9qL0pFVG9LaUlDaEx2VUJaWUN6d2FVZWVwZnE4U2xkZlBGUjUzOUlBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVAvaklNQmxFV2plSUFBWVJHd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWcvK01nd0hvQUFBSllBQUFBQUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFELzR5REExUUFBQWxnQUFBQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFBQVxcdTAwM2RcXHUwMDNkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgXCJ0YWdzXCI6IFt7XCJmcmFtZXNcIjogW10sIFwic2NlbmVzXCI6IFt7XCJuYW1lXCI6IFwiU2NlbmUgMVwiLCBcIm9mZnNldFwiOiAwfV0sIFwidHlwZVwiOiAyM30sIHtcbiAgICAgICAgICAgICAgICBcImlkXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJkYXRhXCI6IGRhdGEsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDExXG4gICAgICAgICAgICB9LCB7XCJpZFwiOiAxLCBcInR5cGVcIjogMTJ9LCB7XCJ0eXBlXCI6IDJ9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJib3VuZHNcIjogW3tcbiAgICAgICAgICAgICAgICAgICAgXCJ5bWluXCI6IDAsXG4gICAgICAgICAgICAgICAgICAgIFwieW1heFwiOiAyMDAwLFxuICAgICAgICAgICAgICAgICAgICBcInhtaW5cIjogMCxcbiAgICAgICAgICAgICAgICAgICAgXCJ4bWF4XCI6IDIwMDBcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBcImlkXCI6IDIsXG4gICAgICAgICAgICAgICAgXCJmaWxsc3R5bGVzXCI6IFt7XCJjb2xvclwiOiBbLTI1NTU5MDBdLCBcInR5cGVcIjogMX1dLFxuICAgICAgICAgICAgICAgIFwicGF0aHNcIjogW3tcbiAgICAgICAgICAgICAgICAgICAgXCJmaWxsXCI6IDAsXG4gICAgICAgICAgICAgICAgICAgIFwiZGF0YVwiOiBbXCI6MDBqOmIxNEQ6MDdHOTNiYjkzQjkzYjkzQjA3Z2I6MTVkOTNiMDdnYjkzYjkzYjA3ZzkzYmIxNWQ6MDhnOTNCYjkyYjkyQjkyYjA3R2I6MTREOTJCMDdHYjkzQjkzQjA4RzkzQmNcIl1cbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBcImZsYXRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwidGFnc1wiOiBbe1wiaWRcIjogMiwgXCJtYXRyaXhcIjogMCwgXCJ0eXBlXCI6IDMsIFwiZGVwdGhcIjogMX0sIHtcInR5cGVcIjogMn1dLFxuICAgICAgICAgICAgICAgIFwiaWRcIjogMyxcbiAgICAgICAgICAgICAgICBcImZyYW1lQ291bnRcIjogMSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogN1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMyxcbiAgICAgICAgICAgICAgICBcInJhdGlvXCI6IDIsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIxMDEyRTMwMXkzMDBZMTAxMUUyOUwxNjhmXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIzNDA5RTQ5OXo0OThaMzQwOUUyOEwwNzdlXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIktpSzpLOjo6XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCI1NjUwRTc0MjRiNzQyNEI1NjUwRTMxSjA2NmRcIixcbiAgICAgICAgICAgICAgICBcImNvbG9ydHJhbnNmb3JtXCI6IFwiVnFWOlY6OjpcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDFcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjc3MzNFODA5OWI4MDk3Qjc3MzNFMzdHMTYwY1wiLFxuICAgICAgICAgICAgICAgIFwiY29sb3J0cmFuc2Zvcm1cIjogXCIxQ3kxQzoxQzo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiOTgxNEU4NjA0Yjg2MDRCOTgxNEUxM0Q2MndcIixcbiAgICAgICAgICAgICAgICBcImNvbG9ydHJhbnNmb3JtXCI6IFwiMEQyYzBEOjBEOjo6XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIxNTk4Rjg5MTNiODkxMkIxNTk5RjNINTBwXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjhEOGM4RDo4RDo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMzM1NEY5MTA3YjkxMDVCMzM1NEYwM2M1NWpcIixcbiAgICAgICAgICAgICAgICBcImNvbG9ydHJhbnNmb3JtXCI6IFwiNUU0ZDVFOjVFOjo6XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCI0ODgyRjkxODliOTE4OUI0ODgyRjg2ZzI4ZlwiLFxuICAgICAgICAgICAgICAgIFwiY29sb3J0cmFuc2Zvcm1cIjogXCIyRjlkMkY6MkY6OjpcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDFcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjYxNzZGOTE5MmI5MTkxQjYxNzVGMDBtNjRjXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjhGNGU4Rjo4Rjo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiNzMyN0Y5MTQyYjkxNDJCNzMyN0Y4N3Ewd1wiLFxuICAgICAgICAgICAgICAgIFwiY29sb3J0cmFuc2Zvcm1cIjogXCIzRzhlM0c6M0c6OjpcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDFcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjgzNDFGOTA3MGI5MDcwQjgzNDFGMTJ2OXJcIixcbiAgICAgICAgICAgICAgICBcImNvbG9ydHJhbnNmb3JtXCI6IFwiN0cxZjdHOjdHOjo6XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCI4MDkzRjkwNzliOTA3OUI4MDkzRjgzejJ3XCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjFINGYxSDoxSDo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiNzg0M0Y5MDk2YjkwOTZCNzg0M0YxNDVjNjBkXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjVIOGY1SDo1SDo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiNzU4OEY5MTEwYjkxMTBCNzU4OUY1NDBjNThoXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjBJMWcwSTowSTo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiNzMzMEY5MTIyYjkxMjJCNzMzMEY4NjNjNjhtXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjVJNWc1STo1STo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiNzA2OEY5MTMyYjkxMzJCNzA2OEYxMzZkNTJzXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjBKOWcwSjowSjo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiNjcwNEY5MTQyYjkxNDNCNjcwNEYzODFkOTh5XCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjVKNGg1Sjo1Sjo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiNjQzMkY5MTQ2YjkxNDdCNjQzMkY2MTVkMjkzY1wiLFxuICAgICAgICAgICAgICAgIFwiY29sb3J0cmFuc2Zvcm1cIjogXCIxSzhoMUs6MUs6OjpcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDFcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjYwNTlGOTE0OWI5MTUwQjYwNTlGNzU1ZDA1NGRcIixcbiAgICAgICAgICAgICAgICBcImNvbG9ydHJhbnNmb3JtXCI6IFwiN0szaTdLOjdLOjo6XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCI1NjgyRjkxNDdiOTE0OEI1NjgyRjgxOGQ4NzdkXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjRMOWk0TDo0TDo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiNTM5NkY5MTM4YjkxMzlCNTM5NkY4ODhkNzE3ZVwiLFxuICAgICAgICAgICAgICAgIFwiY29sb3J0cmFuc2Zvcm1cIjogXCIxTTRqMU06MU06OjpcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDFcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjQ5NTlGOTEyNWI5MTI2QjQ5NTlGOTE1ZDYxMGZcIixcbiAgICAgICAgICAgICAgICBcImNvbG9ydHJhbnNmb3JtXCI6IFwiOE0wazhNOjhNOjo6XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCI1NzUyRjA2MHMxMzg4RDYwMDhGMTM4ZTE3OWdcIixcbiAgICAgICAgICAgICAgICBcImNvbG9ydHJhbnNmb3JtXCI6IFwiNk81bDZPOjZPOjo6XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCI4MTMzSDM3M3IzNzNSODEzNUgyMzZlMTQwZ1wiLFxuICAgICAgICAgICAgICAgIFwiY29sb3J0cmFuc2Zvcm1cIjogXCIyUTdtMlE6MlE6OjpcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDFcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjg1NjJINzQ1cTc0NlE4NTYySDQ0MWU0MTVmXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjVROW01UTo1UTo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiODk0MUgyMzJxMjMxUTg5NDJINjMxZTc3NmVcIixcbiAgICAgICAgICAgICAgICBcImNvbG9ydHJhbnNmb3JtXCI6IFwiN1ExbjdROjdROjo6XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCI5MjQ2SDc5OXA3OTlQOTI0N0g4NzVlMjIzZVwiLFxuICAgICAgICAgICAgICAgIFwiY29sb3J0cmFuc2Zvcm1cIjogXCI5UTNuOVE6OVE6OjpcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDFcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjk1ODlIMjk2cDI5NlA5NTkwSDIzM2Y4MThkXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjFSNW4xUjoxUjo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiOTgxMEg5NThvOTU4Tzk4MTBINjA0ZjUxNGRcIixcbiAgICAgICAgICAgICAgICBcImNvbG9ydHJhbnNmb3JtXCI6IFwiM1I3bjNSOjNSOjo6XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIwMDE1STYzMW82MzNPMDAxN0k5NThmMzAxZFwiLFxuICAgICAgICAgICAgICAgIFwiY29sb3J0cmFuc2Zvcm1cIjogXCI1UjhuNVI6NVI6OjpcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDFcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjAyMTJJMzE1bzMxN08wMjEySTI5MWcxODhkXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjZSOW42Ujo2Ujo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMDM4NEkxMTFvMTEyTzAzODVJNTgyZzE1N2RcIixcbiAgICAgICAgICAgICAgICBcImNvbG9ydHJhbnNmb3JtXCI6IFwiN1IwbzdSOjdSOjo6XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIxMTA4STkxOG04OTFNMTA1OUk5NjFnMjY4ZFwiLFxuICAgICAgICAgICAgICAgIFwiY29sb3J0cmFuc2Zvcm1cIjogXCI4UjFvOFI6OFI6OjpcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDFcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjE5MjhJNDk2bDQ0NEwxODE5STMzNGg1NDZkXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjlSMm85Ujo5Ujo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMjczMUk4OTlqODI2SjI1NTBJNjY5aDk0MGRcIixcbiAgICAgICAgICAgICAgICBcImNvbG9ydHJhbnNmb3JtXCI6IFwiMFMybzBTOjBTOjo6XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIzNDkxSTExNmkwMzFJMzIzMEk5OTZoMzg4ZVwiLFxuICAgICAgICAgICAgICAgIFwiY29sb3J0cmFuc2Zvcm1cIjogXCIyUzNvMlM6MlM6OjpcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDFcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjQyMDRJMDUyZzk2NUYzODUwSTIyOWk5NThlXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjNTNW8zUzozUzo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiNDc5N0k3OTRkNzE5RDQzNDNJMzM1aTY2MmZcIixcbiAgICAgICAgICAgICAgICBcImNvbG9ydHJhbnNmb3JtXCI6IFwiNVM2bzVTOjVTOjo6XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCI1MjQwSTYxdzE1VzQ2NzhJNDcyaTM5NGdcIixcbiAgICAgICAgICAgICAgICBcImNvbG9ydHJhbnNmb3JtXCI6IFwiN1M3bzdTOjdTOjo6XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCI2MTgySjEyZjkzQjUwOTBINjI2aTc0M2dcIixcbiAgICAgICAgICAgICAgICBcImNvbG9ydHJhbnNmb3JtXCI6IFwiN1M4bzdTOjdTOjo6XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCI2NzYzSTMybzM4TzY4OTFJNjM0aTQxM2dcIixcbiAgICAgICAgICAgICAgICBcImNvbG9ydHJhbnNmb3JtXCI6IFwiMFQ5bzBUOjBUOjo6XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCI2MjMxSTM2NWMzNzZDNjMzNkk3NDFpODc3ZlwiLFxuICAgICAgICAgICAgICAgIFwiY29sb3J0cmFuc2Zvcm1cIjogXCIxVDBwMVQ6MVQ6OjpcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDFcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjU2NjdJOTM0ZDk0NkQ1NzUwSTg1N2kzODRmXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjJUMXAyVDoyVDo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiNTA2NEk0MjBmNDMzRjUxMjhJMDEzajk1MmVcIixcbiAgICAgICAgICAgICAgICBcImNvbG9ydHJhbnNmb3JtXCI6IFwiM1QycDNUOjNUOjo6XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCI0NDgySTY0MGc2NTJHNDUyOUkyMzNqNjA3ZVwiLFxuICAgICAgICAgICAgICAgIFwiY29sb3J0cmFuc2Zvcm1cIjogXCI0VDNwNFQ6NFQ6OjpcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDFcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjM5MjNJNzAwaDcxMEgzOTU1STUwN2ozNzJlXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjVUNHA1VDo1VDo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMzQwMUk2MTFpNjE4STM0MjFJNzkwajI0M2VcIixcbiAgICAgICAgICAgICAgICBcImNvbG9ydHJhbnNmb3JtXCI6IFwiNlQ1cDZUOjZUOjo6XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIyOTY0STI5NGoyOTZKMjk3MkkwNDNrMTg0ZVwiLFxuICAgICAgICAgICAgICAgIFwiY29sb3J0cmFuc2Zvcm1cIjogXCI3VDZwN1Q6N1Q6OjpcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDFcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjI1ODNJOTUzajk1MUoyNTg0STI1NmsxNThlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIzMDA4STc1OGk3NTVJMzAwOUk1NDNrMjI5ZVwiLFxuICAgICAgICAgICAgICAgIFwiY29sb3J0cmFuc2Zvcm1cIjogXCIwVTlwMFU6MFU6OjpcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDFcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjM0NTBJNDMwaDQyNEgzNDUySTgyOWs0MzRlXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjRVMXE0VTo0VTo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMzg2Mkk5NTJmOTQxRjM4NjRJMDc5bDc0N2VcIixcbiAgICAgICAgICAgICAgICBcImNvbG9ydHJhbnNmb3JtXCI6IFwiOVU1cTlVOjlVOjo6XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCI0MjIxSTMyMGUyMTFFNDI0MUkyODNsMTQ0ZlwiLFxuICAgICAgICAgICAgICAgIFwiY29sb3J0cmFuc2Zvcm1cIjogXCI0VjhxNFY6NFY6OjpcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDFcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjQ1MTZJNDQxYzMyN0M0NTMwSTQ0OWw2MDZmXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjlWMnI5Vjo5Vjo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiNDY5NkkxMW45Mkw0NzAySTU3N2wxMjRnXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjVXNnI1Vzo1Vzo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiNDcyOUk1NUc3N2g0NzI2STY1Nmw2ODhnXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjFYMXMxWDoxWDo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiNjYzNUkwM0M4MGI1OTY0SDYzOGw2NzlnXCIsXG4gICAgICAgICAgICAgICAgXCJjb2xvcnRyYW5zZm9ybVwiOiBcIjhYOHM4WDo4WDo6OlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiODUzN0k6bjcxOTNHNjEzbDY3MGdcIixcbiAgICAgICAgICAgICAgICBcImNvbG9ydHJhbnNmb3JtXCI6IFwiNlk0dDZZOjZZOjo6XCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XCJ0eXBlXCI6IDQsIFwiZGVwdGhcIjogMX0sIHtcbiAgICAgICAgICAgICAgICBcImJvdW5kc1wiOiBbe1wieW1pblwiOiAwLCBcInltYXhcIjogMTg2MSwgXCJ4bWluXCI6IDAsIFwieG1heFwiOiA1MzA4fV0sXG4gICAgICAgICAgICAgICAgXCJpZFwiOiA0LFxuICAgICAgICAgICAgICAgIFwiZmlsbHN0eWxlc1wiOiBbe1wiY29sb3JcIjogWy0yNTU1OTAwXSwgXCJ0eXBlXCI6IDF9XSxcbiAgICAgICAgICAgICAgICBcInBhdGhzXCI6IFt7XG4gICAgICAgICAgICAgICAgICAgIFwiZmlsbFwiOiAwLFxuICAgICAgICAgICAgICAgICAgICBcImRhdGFcIjogW1wiOjUxdDd1YjI0ZDozNWkwaWI5N2cxbjcybTk3Y2IwMmY3ejYyZTkzZGJUNGsyVTNzYjNSNmc5MEQ4amI5VXc1MkR3YjYyRDo3OUkxSWI2OUc2TTg0TDk2Q2IxNEUwWjc0RDkzRGIxZDNXMTRmMDFDYjNzVzA4ZFdjOjkxRTdVYjA2Qzo4MEUzY2I4NkM2ZDEzRjVvYjRXMmszWjc1YmI5QjNwM280OGNiNnEwcjIzZTU2Y2IzNWc3MmMzM3I2NWViMjlnOWwzNW05bGIwNmM6ODBlM0NiODZjNkQxM2Y1T2I0dzJLM3o3NUJiOWIzUDNPNDlDYjZROVEyM0U1NUNiMzVHNzFDMzNSNjVFYjI5RzlMMzVNOUxjXCJdXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgXCJmbGF0XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDFcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInRhZ3NcIjogW3tcImlkXCI6IDQsIFwibWF0cml4XCI6IDAsIFwidHlwZVwiOiAzLCBcImRlcHRoXCI6IDF9LCB7XCJ0eXBlXCI6IDJ9XSxcbiAgICAgICAgICAgICAgICBcImlkXCI6IDUsXG4gICAgICAgICAgICAgICAgXCJmcmFtZUNvdW50XCI6IDEsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDdcbiAgICAgICAgICAgIH0sIHtcImlkXCI6IDUsIFwicmF0aW9cIjogNjAsIFwibWF0cml4XCI6IFwiNDQyMkU3M083M280NDIyRTYwNWs0NzZnXCIsIFwidHlwZVwiOiAzLCBcImRlcHRoXCI6IDd9LCB7XG4gICAgICAgICAgICAgICAgXCJib3VuZHNcIjogW3tcbiAgICAgICAgICAgICAgICAgICAgXCJ5bWluXCI6IDAsXG4gICAgICAgICAgICAgICAgICAgIFwieW1heFwiOiA4NDksXG4gICAgICAgICAgICAgICAgICAgIFwieG1pblwiOiAwLFxuICAgICAgICAgICAgICAgICAgICBcInhtYXhcIjogMjA0M1xuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIFwiaWRcIjogNixcbiAgICAgICAgICAgICAgICBcImZpbGxzdHlsZXNcIjogW3tcImNvbG9yXCI6IFstMjU1NTkwMF0sIFwidHlwZVwiOiAxfV0sXG4gICAgICAgICAgICAgICAgXCJwYXRoc1wiOiBbe1xuICAgICAgICAgICAgICAgICAgICBcImZpbGxcIjogMCxcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhXCI6IFtcIjo3OGU6YjVJOjRSamIyM0M3YzgzQzhyYjBGMm8wdDI0Y2IxejNxOTJmNHpiMDRjM2Y1OWUzZmIyazo0dUxiMzVjOUM2NGM1UmI5YjROMlgxNUNiNzFCMFE4MEY3WmI5MUIwRzQwRTBHY1wiXVxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIFwiZmxhdFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgXCJ0YWdzXCI6IFt7XCJpZFwiOiA2LCBcIm1hdHJpeFwiOiAwLCBcInR5cGVcIjogMywgXCJkZXB0aFwiOiAxfSwge1widHlwZVwiOiAyfV0sXG4gICAgICAgICAgICAgICAgXCJpZFwiOiA3LFxuICAgICAgICAgICAgICAgIFwiZnJhbWVDb3VudFwiOiAxLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiA3XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgXCJpZFwiOiA3LFxuICAgICAgICAgICAgICAgIFwicmF0aW9cIjogNjAsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIzNDA3QzYzMEQ2MzBkMzQwN0M1NjlrNDM5Z1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogOVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMjQ2NUU0MVI0MXIyNDY1RTUwOGs0NjJnXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiA3XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIzNDc2Qzk1OEQxNzRjMzk0WTU3M2s4NzVmXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiA5XG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCI5MzgyRDc4Vjc4djkzODJEMzU2azQ0MWdcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjM1NDVDMzYxRTQxajE3M1I1ODNrMzY2ZlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogOVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiNTE3OUQ4NzNCODczYjUxNzlEMTQ3azQxMmdcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjM1OTlDNjQ5RTQ3Tjc5MEs1OTVrOTA3ZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogOVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiOTg1NEM2MjlDNjI5Yzk4NTRDODg1ajM3NmdcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjM2NTRDOTI4RTQyMEQyNjRGNjExazUwMmVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDlcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcImJvdW5kc1wiOiBbe1wieW1pblwiOiAwLCBcInltYXhcIjogMjkyNCwgXCJ4bWluXCI6IDAsIFwieG1heFwiOiA3NTQ5fV0sXG4gICAgICAgICAgICAgICAgXCJpZFwiOiA4LFxuICAgICAgICAgICAgICAgIFwiZmlsbHN0eWxlc1wiOiBbe1wiY29sb3JcIjogWy0yNTU1OTAwXSwgXCJ0eXBlXCI6IDF9XSxcbiAgICAgICAgICAgICAgICBcInBhdGhzXCI6IFt7XG4gICAgICAgICAgICAgICAgICAgIFwiZmlsbFwiOiAwLFxuICAgICAgICAgICAgICAgICAgICBcImRhdGFcIjogW1wiOjk1NmI0MGNiMDVmOjI2bTBuYjMyazl1NDNzMjFmYjk2YzdzOThlOTJjYjR1NnQwcjg0Y2I1QzlxMTRDMDRjYjVaMGwwN0cycWI5NEI0YzI3RjRjYjNQOjM2Q0hiNDRFWjgwSjBNYjk0SjJVMTZSMjFGYjQyQzRTMTFFOTFDYjZRNVQxTjg1Q2I1YzBSNzRiMDRDYjF3MEwyMGYxUWI4MGI3QzkxZTdDYzoyN0g0MENiNDVEOjQ1SDNlYjU1RTNnODVINXhiNDFDN3E5MUMzNGRiMEU3eTB0NDllYjJ4ODJiMzBnNTdlYjg4ZDc2YjQ1azAzZWI4MWY1dzQ3bjgzY2IyOWowdDkxcjB0YjQ0ZDo0NGgzRWI1NWU0Rzg1aDVYYjQxYzdROTFjMzREYjBlN1kxVDQ5RWIyWDgyQjI5RzU3RWI4OEQ3NkI0NUswM0ViODBGNVc0N044NENiMjlKOVM5MFI5U2NcIl1cbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBcImZsYXRcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwidGFnc1wiOiBbe1wiaWRcIjogOCwgXCJtYXRyaXhcIjogMCwgXCJ0eXBlXCI6IDMsIFwiZGVwdGhcIjogMX0sIHtcInR5cGVcIjogMn1dLFxuICAgICAgICAgICAgICAgIFwiaWRcIjogOSxcbiAgICAgICAgICAgICAgICBcImZyYW1lQ291bnRcIjogMSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogN1xuICAgICAgICAgICAgfSwge1wiaWRcIjogOSwgXCJyYXRpb1wiOiA2NSwgXCJtYXRyaXhcIjogXCI5MzU5RTc0SDc0aDkzNTlFNjkxazUwOGdcIiwgXCJ0eXBlXCI6IDMsIFwiZGVwdGhcIjogNX0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjM0MDdDNjMwRDYzMGQzNDA3QzU2NmozMzZnXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiA3XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIzNzA4QzE5OEYzMjJHNTVPNjI3azE0N2VcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDlcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjkxNjZEMTBXMTB3OTE2NkQ5NTJqMzkxZ1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogNVxuICAgICAgICAgICAgfSwge1wicmVwbGFjZVwiOiB0cnVlLCBcIm1hdHJpeFwiOiBcIjM2MjZDODA3RTgwN2UzNjI2QzU1MGo1NTVmXCIsIFwidHlwZVwiOiAzLCBcImRlcHRoXCI6IDd9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIzNzQyQzM1NUYxNzVKNTR3NjQyazg0MmRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDlcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjM0MDdDNjMwRDYzMGQzNDA3QzgxMGkyMTdnXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiA1XG4gICAgICAgICAgICB9LCB7XCJyZXBsYWNlXCI6IHRydWUsIFwibWF0cml4XCI6IFwiMzg1NkM5MDdGOTA3ZjM4NTZDNTM3ajkwMGVcIiwgXCJ0eXBlXCI6IDMsIFwiZGVwdGhcIjogN30sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjM3NzRDNTAzRjYxMkw1NDJlNjU2azU4OWRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDlcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjM2NjdDMjA3RTkyOWQ1Mzc4QzgxNWk1MDZmXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiA1XG4gICAgICAgICAgICB9LCB7XCJyZXBsYWNlXCI6IHRydWUsIFwibWF0cml4XCI6IFwiNDA1OEM3NDRHNzQ0ZzQwNThDNTI5ajM2MWVcIiwgXCJ0eXBlXCI6IDMsIFwiZGVwdGhcIjogN30sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjM4MDRDNjQwRjk3N045NzRnNjY5azM4OGRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDlcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcImJvdW5kc1wiOiBbe1wieW1pblwiOiAtNTA0NCwgXCJ5bWF4XCI6IDYzNDAsIFwieG1pblwiOiAtMzg5OSwgXCJ4bWF4XCI6IDEyMzA0fV0sXG4gICAgICAgICAgICAgICAgXCJpZFwiOiAxMCxcbiAgICAgICAgICAgICAgICBcImZpbGxzdHlsZXNcIjogW3tcImNvbG9yXCI6IFstMTY3MTE5MzZdLCBcInR5cGVcIjogMX1dLFxuICAgICAgICAgICAgICAgIFwicGF0aHNcIjogW3tcbiAgICAgICAgICAgICAgICAgICAgXCJmaWxsXCI6IDAsXG4gICAgICAgICAgICAgICAgICAgIFwiZGF0YVwiOiBbXCI6ODIzQzA0NEVhNkc2NTJqYTU0dDMyZ2EzMHExMDlEYjE5YzgyYzg4bTI1ZmIyNGoydzg3djR4YjJmYTNsYWI1Mmw6MTR2NFdiMzNrNzRCMzZvMDZIYTcybjc5dGEzOTljNDg0SGExMjdQMDBHY1wiXVxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIFwiZmxhdFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAxXG4gICAgICAgICAgICB9LCB7XCJjbGlwXCI6IDQsIFwiaWRcIjogMTAsIFwibWF0cml4XCI6IFwiMzA3NUM6OjMwNzVDMDAwajYwMWZcIiwgXCJ0eXBlXCI6IDMsIFwiZGVwdGhcIjogMX0sIHtcbiAgICAgICAgICAgICAgICBcImJvdW5kc1wiOiBbe1xuICAgICAgICAgICAgICAgICAgICBcInltaW5cIjogMCxcbiAgICAgICAgICAgICAgICAgICAgXCJ5bWF4XCI6IDM4NDEsXG4gICAgICAgICAgICAgICAgICAgIFwieG1pblwiOiAwLFxuICAgICAgICAgICAgICAgICAgICBcInhtYXhcIjogNzQ5NVxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIFwiaWRcIjogMTEsXG4gICAgICAgICAgICAgICAgXCJmaWxsc3R5bGVzXCI6IFt7XCJjb2xvclwiOiBbLTI1NTU5MDBdLCBcInR5cGVcIjogMX1dLFxuICAgICAgICAgICAgICAgIFwicGF0aHNcIjogW3tcbiAgICAgICAgICAgICAgICAgICAgXCJmaWxsXCI6IDAsXG4gICAgICAgICAgICAgICAgICAgIFwiZGF0YVwiOiBbXCI6OjphOjEzd2IxajBxMXkzOWNiaTJOdDNYYjZlMzdFOHMwOEhiMGk0UTJyNFFiMWU6M2o1ZWIzbjNvNHQ0MWZiMWY4OGRlMjVqYUc4ZWIzejhuNzNlNXpiaDJVNWQyNkRiM2kzNEUwNGMyMEhiNm44Uzg5YjhTYjVmOjlsMWRiNnQ5bDg3Yjk4ZWIwaDY5ZE0wMmphTjZnYjQ5ZDdnMjFpN2liajZIdjZPYjJpNDBFNDhjMzFJYjd5OTBDMjhlMDNEYmk6cjpiN3k6NzljNjFjYjdsNzJjNWMxMmlhMkMwcGIxOWMzRDg5ZTlKYTZkOE9iNXAyMkU5M2M5OUhiOHY3OEM4NWM4OUNiZDppOmIxbjozbjIxY2JiMzBjM04yMWhiMjljMVI2M2Q5OENhMzVoNjVUYTo6Yjc0RDY5ZDM1UDc5ZWIzOUMyYzA4RzJjYjU2RzozOFA1TWI0OUwyUzI5VjY4RWIyM0o5M0M4NUwxNkhjXCJdXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgXCJmbGF0XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDFcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInRhZ3NcIjogW3tcImlkXCI6IDExLCBcIm1hdHJpeFwiOiAwLCBcInR5cGVcIjogMywgXCJkZXB0aFwiOiAxfSwge1widHlwZVwiOiAyfV0sXG4gICAgICAgICAgICAgICAgXCJpZFwiOiAxMixcbiAgICAgICAgICAgICAgICBcImZyYW1lQ291bnRcIjogMSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogN1xuICAgICAgICAgICAgfSwge1wiaWRcIjogMTIsIFwicmF0aW9cIjogNjksIFwibWF0cml4XCI6IFwiMzQwN0M2MzBENjMwZDM0MDdDOTQzaTcwNmdcIiwgXCJ0eXBlXCI6IDMsIFwiZGVwdGhcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjM4OTJDNzM2RTE2NmU3MDQwQzgyMGk5MDdlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiA1XG4gICAgICAgICAgICB9LCB7XCJyZXBsYWNlXCI6IHRydWUsIFwibWF0cml4XCI6IFwiNDI0MEM0MjVINDI1aDQyNDBDNTIzajk0M2RcIiwgXCJ0eXBlXCI6IDMsIFwiZGVwdGhcIjogN30sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjM4MzNDNzcxRjcxN1A3NzJpNjgwazIzOGRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDlcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjM0OTNDMDkxRTA5MWUzNDkzQzk0M2kzNzhnXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAyXG4gICAgICAgICAgICB9LCB7XCJyZXBsYWNlXCI6IHRydWUsIFwibWF0cml4XCI6IFwiNDA3NUMxMzdGMjk1ZTgzOTRDODI3aTQxNmVcIiwgXCJ0eXBlXCI6IDMsIFwiZGVwdGhcIjogNX0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjQzOTBDOTU0SDk1NGg0MzkwQzUxOGo2NDhkXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiA3XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIzODQzQzkxOUY5MjRRMDA3azY4NmsxNDBkXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiA5XG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIzNTY4QzUzMEU1MzBlMzU2OEM5NDNpMDQ5Z1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMlxuICAgICAgICAgICAgfSwge1wicmVwbGFjZVwiOiB0cnVlLCBcIm1hdHJpeFwiOiBcIjQyMzZDNTE1RjQyOGU5NDU3QzgzMmkwMzhlXCIsIFwidHlwZVwiOiAzLCBcImRlcHRoXCI6IDV9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCI0NDc0QzIyOEkyMjhpNDQ3NEM1MTZqNDY5ZFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogN1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMzg2MUM5MTJGODAxSjUyMGQ2MzlrMjg3ZFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogOVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMzY2OEMwNzJGMDcyZjM2NjhDOTQyaTcyNWZcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDJcbiAgICAgICAgICAgIH0sIHtcInJlcGxhY2VcIjogdHJ1ZSwgXCJtYXRyaXhcIjogXCI0MzI4QzY2NkY0MTNlMDE5N0Q4MzZpNzU5ZFwiLCBcInR5cGVcIjogMywgXCJkZXB0aFwiOiA1fSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiNDQ4OEMzNzJJMzcyaTQ0ODhDNTE0ajQxMGRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjM4ODZDMDM3RzcyOEQwMVk2MDFrNDQxZFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogOVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMzc3NkM2MTJGNjEyZjM3NzZDOTQxaTQwM2ZcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDJcbiAgICAgICAgICAgIH0sIHtcInJlcGxhY2VcIjogdHJ1ZSwgXCJtYXRyaXhcIjogXCI0MzkyQzc5N0Y0MzFlMDY0N0Q4NDBpNTk2ZFwiLCBcInR5cGVcIjogMywgXCJkZXB0aFwiOiA1fSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiNDUxMUMzNzdJMzc3aTQ1MTFDNTE0ajU5MWRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDdcbiAgICAgICAgICAgIH0sIHtcInJlcGxhY2VcIjogdHJ1ZSwgXCJtYXRyaXhcIjogXCIzODg2QzA1OEdCOTk4STU3MGs1OTVkXCIsIFwidHlwZVwiOiAzLCBcImRlcHRoXCI6IDl9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIzODcyQzA0OEcwNDhnMzg3MkM5NDFpMDczZlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMlxuICAgICAgICAgICAgfSwge1wicmVwbGFjZVwiOiB0cnVlLCBcIm1hdHJpeFwiOiBcIjQ0MTJDOTI4RjUwOGUwNzk0RDgzOWk1NDdkXCIsIFwidHlwZVwiOiAzLCBcImRlcHRoXCI6IDV9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCI0NTQzQzUwNEk1MDRpNDU0M0M1MTRqNzc3ZFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogN1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMzkwOUMxODJHNTczYzgzN1E1NDVrNzUzZFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogOVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMzk5N0M1ODRHNTg0ZzM5OTdDOTQxaTc1MWVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDJcbiAgICAgICAgICAgIH0sIHtcInJlcGxhY2VcIjogdHJ1ZSwgXCJtYXRyaXhcIjogXCI0NDM4QzkzMUY0NzNlMDk4M0Q4NDBpNzI0ZFwiLCBcInR5cGVcIjogMywgXCJkZXB0aFwiOiA1fSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiNDU3NUM2MzBJNjMwaTQ1NzVDNTEzajk2MmRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjM5MzVDMzA1RzExNGY4NzJZNTI4azkxNGRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDlcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjQxMDBDMDkzSDA5M2g0MTAwQzk0MWk0MjZlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAyXG4gICAgICAgICAgICB9LCB7XCJyZXBsYWNlXCI6IHRydWUsIFwibWF0cml4XCI6IFwiNDQ2MUMxMTVHNTc5ZTExNjlEODM5aTkxM2RcIiwgXCJ0eXBlXCI6IDMsIFwiZGVwdGhcIjogNX0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjQ1NjhDNzMzSTczM2k0NTY4QzUxMWoxNDdlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiA3XG4gICAgICAgICAgICB9LCB7XCJyZXBsYWNlXCI6IHRydWUsIFwibWF0cml4XCI6IFwiMzkyOEMzOTRHMzk0ZzM5MjhDNTE5azA3NGVcIiwgXCJ0eXBlXCI6IDMsIFwiZGVwdGhcIjogOX0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogNCxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDFcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogNCwgXCJkZXB0aFwiOiAyfSwge1widHlwZVwiOiA0LCBcImRlcHRoXCI6IDV9LCB7XCJ0eXBlXCI6IDQsIFwiZGVwdGhcIjogN30sIHtcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogNCxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDlcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcImJvdW5kc1wiOiBbe1wieW1pblwiOiA2NDEsIFwieW1heFwiOiA2MDk2LCBcInhtaW5cIjogMzQzLCBcInhtYXhcIjogNzg3OH1dLFxuICAgICAgICAgICAgICAgIFwiaWRcIjogMTMsXG4gICAgICAgICAgICAgICAgXCJmaWxsc3R5bGVzXCI6IFt7XCJjb2xvclwiOiBbLTI1NDc5MzBdLCBcInR5cGVcIjogMX1dLFxuICAgICAgICAgICAgICAgIFwicGF0aHNcIjogW3tcbiAgICAgICAgICAgICAgICAgICAgXCJmaWxsXCI6IDAsXG4gICAgICAgICAgICAgICAgICAgIFwiZGF0YVwiOiBbXCI6NDIwYzYzaWI3NmU6NTdsMWxhOHI1Y2I1Mmo0dDcxcTYyZWI3MGc4NGMxOGcyM2diMUMydDkzQjM1Y2JMODFCNjdGODJFYjI1RzM0QzEwUjk1RGI3MEYxSjM1TDFKYjUyQzo2M0Y5Y2I4NkU0ZzgxRzV5YjdMM1AzSjIzQ2I3ZTgwQzk0aDE1RWIzOWM0RTI0ZzRFYzo5NmQxMGhiMTVkOjA3aTFnYjA4aDZrNDhtNTFjYjQyZTd3MDJlNTVkYjBEOHU0MEY5MWJhNDhEOWJhMEtFYjZyMkUwdTZPYjhiOE05WDA4Q2I4NkI2UTA0RzFaYjBZMUU2OEQxRWI2Tjo3OEJ3YjIyQzRlNTFDM3RiOEIwbzR4MTFjYTdnMmRiNzhDM0k3NkYyVmI0MEU3VzAyRTU1RGIwZDhVMzlmODlCYjR3OUI5OWQ5QmM6NDlMMzJLYjY0RTo1N0owaGI2MkswczQ3TDExZ2IxRDJ5MXIxMWViNnc3NmI3Mmc2MGViNDBqNTBlOTR5MDZoYjkzaDduNTVwN25iNjZlOjYxajFIYjU4azdSNDRsMTFHYjdoMjFFNTNJNzFKYjUySDUxRDUzVDA0R2IyWjVFNDFFMUpiOTNIN041NlA3TmM6MjVXNDdxYTlmOTV2YjlqOXAwejMwY2FsMlhiOGMyOEUzcTA4SGI3aDhRMHI4UWI5ZDowajBlYjRuN24ydjMwZmI0Zzg2ZDZjMTlqYUU3ZWIzejhtNzZlN3hiZTZVMWMyNURiOGc0MEU3OWIyNEhiMW41VDg0YjVUYjNmOjZsOWNiOXQ5azAzYzgzZWIzaTUwZHE5NWlhTDZnYjU3ZDZmMTdpOWZiajlKczdPYjZnNDJFMThjMzZJYjR4OTNDMTFlMTREYm9BMGNBYjh4Ojc1YzQ3Y2I4bTYyYzJmMDVpYkc2ZloxcGIwOGMyRTgwZTZMYnEzSDNkOU9iNW4yM0U2M2MwNUliNXU4MUM2OWMwMERiZDpoOmIwbjozbzE1Y2JsMzdjOEsyMGhiMjBjNVI1MGQwOERhNjVnNzdUYTo6YjU5RDgwZDA2UDIzZmI1M0Q4ZTY3SThlYjM3Rjo2N005SGI2N0w3TzI5VjkzRGIyNko1OEMwMU03MkdjXCJdXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgXCJmbGF0XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDFcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInRhZ3NcIjogW3tcImlkXCI6IDEzLCBcIm1hdHJpeFwiOiAwLCBcInR5cGVcIjogMywgXCJkZXB0aFwiOiAyfSwge1widHlwZVwiOiAyfV0sXG4gICAgICAgICAgICAgICAgXCJpZFwiOiAxNCxcbiAgICAgICAgICAgICAgICBcImZyYW1lQ291bnRcIjogMSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogN1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMTQsXG4gICAgICAgICAgICAgICAgXCJyYXRpb1wiOiA3NyxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjM2NTJDMDkwRjM1MmU3NTIxQzY2N2k0MDdkXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxNVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMzQ1OUM4MjdEMjE3ZDc1MTJDNzEwaTI1MWRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDE1XG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIzMzY0QzEyM0Q1OTBjNzUyNkM3MzRpMTYxZFwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMTVcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjMzMzNDOTcxQzQ1M2M3NTMwQzczOGkxMzdkXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxNVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMzA3OEM0NDJDOTM3Yjc4MzJDNzQ0aTIzNWRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDE1XG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIyMzQyQzYxVDYxcDg3NzJDNzUwaTU0NWRcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDE1XG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIxMjUwQzlxOUwwNDYxRDc1MGkwNzBlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxNVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMDAzMUM4OTFjNjVYMzAzOEQ3NjJpNzgxZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMTVcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjIyNzdDODBoOTNHNTU0NkM4MzRpMjc0ZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMTVcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjMwNzVDOjozMDc1Qzg0OWkxMDBlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxNVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwiYm91bmRzXCI6IFt7XG4gICAgICAgICAgICAgICAgICAgIFwieW1pblwiOiAwLFxuICAgICAgICAgICAgICAgICAgICBcInltYXhcIjogOTEyMixcbiAgICAgICAgICAgICAgICAgICAgXCJ4bWluXCI6IC0yODAsXG4gICAgICAgICAgICAgICAgICAgIFwieG1heFwiOiAyMjAwNlxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIFwiaWRcIjogMTUsXG4gICAgICAgICAgICAgICAgXCJmaWxsc3R5bGVzXCI6IFt7XCJjb2xvclwiOiBbMTM4MTUxNTg0Ml0sIFwidHlwZVwiOiAxfV0sXG4gICAgICAgICAgICAgICAgXCJwYXRoc1wiOiBbe1wiZmlsbFwiOiAwLCBcImRhdGFcIjogW1wiOjA0MWM6YTMyMUMxMjJpYTI4NnY6YToxMjJJY1wiXX1dLFxuICAgICAgICAgICAgICAgIFwiZmxhdFwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgXCJ0YWdzXCI6IFt7XCJpZFwiOiAxNSwgXCJtYXRyaXhcIjogMCwgXCJ0eXBlXCI6IDMsIFwiZGVwdGhcIjogMX0sIHtcInR5cGVcIjogMn1dLFxuICAgICAgICAgICAgICAgIFwiaWRcIjogMTYsXG4gICAgICAgICAgICAgICAgXCJmcmFtZUNvdW50XCI6IDEsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcImNsaXBcIjogMTMsXG4gICAgICAgICAgICAgICAgXCJpZFwiOiAxNixcbiAgICAgICAgICAgICAgICBcInJhdGlvXCI6IDk0LFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMTM2Uzo6MTM2UzYyNmw0MzJjXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgXCJib3VuZHNcIjogW3tcInltaW5cIjogMzMyLCBcInltYXhcIjogMzA4MSwgXCJ4bWluXCI6IDI2NCwgXCJ4bWF4XCI6IDE1MjY4fV0sXG4gICAgICAgICAgICAgICAgXCJpZFwiOiAxNyxcbiAgICAgICAgICAgICAgICBcImZpbGxzdHlsZXNcIjogW3tcImNvbG9yXCI6IFstMTY3NzcyMTZdLCBcInR5cGVcIjogMX1dLFxuICAgICAgICAgICAgICAgIFwicGF0aHNcIjogW3tcbiAgICAgICAgICAgICAgICAgICAgXCJmaWxsXCI6IDAsXG4gICAgICAgICAgICAgICAgICAgIFwiZGF0YVwiOiBbXCI6MDk5ajY4Y2I0TDo2VjdpYjZJM2o2STR2YjozbTZpOXZiMmkyaTZ2MmliMG46NnYySWIzaTZIM2k5VmI6MU0zSTRWYjNJN0k2VjdJYzo1MTdIMDlpYTl6OTVmYTQ1RTphNzZiOTVGYzowNDRlNjJkYjdvOjJ6OWphZ2ViMGs1ajJrOXlhOnZiQjVuMks0eWFHY2I1SjJrMloya2I3SjowUzBFYjRDUTlHMkZhOkNiNks5SjZLOFpiOjVPNms3MkJiNGMzQzlnOUViM2gwRTBzMEVjOjA3dDpiN286Nno5amFjZWI0ajJqMWs5eWE6dmJHMG8xSzR5YUNjYjlKMms2WjJrYjBQOjlaMkthOkNiMks3SjJLOFpiOjVPMms3MkJiNGs5Sjl6OUpjOjMwMUc5M01hNjhKNzI4YmExMWY6YTJ1MzFFYTkwaTphMHUzMWVhMTFmOmE3MUo3MjhCYzo1OHUwMGhiMTREOjUzRjFsYjFSMkoyOEQ0S2E6MjZzYTY5ZTphOjE3S2I6Mko4ZzlPYjFvNkgwMmQ2SGJzOjhjOmFxOmE6NzFFYUk6Ykc6TjpjOjFwMTJIYTo3NDViYTcxZTphOjE0RmE3NmQxNGZhMjZnOmE1NEc2OUlhMzVnNDdJYWNDYTI0RzphNjJEOThlYToxMkxhNzFFMlVjOjg2MWIyNmhhOjFoYjhSOEc4MUM4R2IwSjowU3NiODhCN2U4NkQ0emEwSThpYVYzY2IxUTV4MVE0M2ViOjdpeDR0YjhjNnI3bjQ1Y2IwZjZnMms2bGE6Y2I3bzdvNjRjMXdhNWZwYTdlb2EwamxhMWdnYXM6YTZoR2E5bzdCYjlsMUM4eDJKYjR2N2s2NGQxbWE6MTRTYzowNnQyOEhhNzZFMHVhOjk5ZmI4UThHODBDOEdiOTZDOjc2RjgzYmI4MUI3NGI4MUI3NGZiOjAyZDgxYjc1ZmFiY2I0cDJwNjRjMXdhMmZwYTdvN2JhMmdnYXM6YTBpR2E3bzdCYjNuNUMweDJKYjFyMmo2OWQ2bWE6NzQ3QmM6NnYyNmhhOjIxc2E3MmU6YToyMVNiOUwxaDg4QjFoYjBPOjg0QjFIYzo2NGc6YTo4M2piOjQ3YzZ4OTNlYjlvOW81N2MxdWE1bTdiYTFoZ2EzZDphNGdHYTBuN0JiOWsyRDFyNkdiMnQwajE0ZDBrYToyMVNhNzFFOmE6OTBqYjo1ajRHOXFhRGJiN0c4ZzRSOGdiMks6MFM4R2E6QmI5RzRHOUc2UmE6ODNKYzoyODVjOmIxN0M6NTVFOXRiM1c0VDUwRTRUYjBXOjE2RDlqYjJQOEcyMUQ3SmE6MTZzYTcxZTphOjkwSmJlNUo4ZzlRYWNCYjhnOEc1cjhHYjVqOjhyOGdiOWcyZzlnMXJhOjkwamE3MWU6YTowMEtiOjlJOWc4UWE6ZWIxZzlHOHI5R2Iyazo1cjRnYWVlYjRnMWc0ZzNyYTo4OGphNzFlOmE6ODhKYjo0NUMzWDg4RWFEOmE6QmI2VzNYODhFM1hjXCJdXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgXCJmbGF0XCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDFcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInRhZ3NcIjogW3tcImlkXCI6IDE3LCBcIm1hdHJpeFwiOiAwLCBcInR5cGVcIjogMywgXCJkZXB0aFwiOiA5fSwge1widHlwZVwiOiAyfV0sXG4gICAgICAgICAgICAgICAgXCJpZFwiOiAxOCxcbiAgICAgICAgICAgICAgICBcImZyYW1lQ291bnRcIjogMSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogN1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMTgsXG4gICAgICAgICAgICAgICAgXCJyYXRpb1wiOiA5NCxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjMwNzVDOjozMDc1QzExOWUxNDNmXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAzXG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XCJyZXBsYWNlXCI6IHRydWUsIFwibWF0cml4XCI6IFwiMTM2Uzo6MTM2Uzc4MGs0MzJjXCIsIFwidHlwZVwiOiAzLCBcImRlcHRoXCI6IDF9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIzMDc1Qzo6MzA3NUMxMzJmMTQzZlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogM1xuICAgICAgICAgICAgfSwge1wicmVwbGFjZVwiOiB0cnVlLCBcIm1hdHJpeFwiOiBcIjMwNzVDOjozMDc1Qzk5MWgxMDBlXCIsIFwidHlwZVwiOiAzLCBcImRlcHRoXCI6IDE1fSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMTM2Uzo6MTM2UzkxNmo0MzJjXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJyZXBsYWNlXCI6IHRydWUsIFwibWF0cml4XCI6IFwiMzA3NUM6OjMwNzVDMTY2ZzE0M2ZcIiwgXCJ0eXBlXCI6IDMsIFwiZGVwdGhcIjogM30sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjMwNzVDOjozMDc1QzExNGgxMDBlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxNVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1wicmVwbGFjZVwiOiB0cnVlLCBcIm1hdHJpeFwiOiBcIjEzNlM6OjEzNlMzNjlqNDMyY1wiLCBcInR5cGVcIjogMywgXCJkZXB0aFwiOiAxfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMzA3NUM6OjMwNzVDODIxZzE0M2ZcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDNcbiAgICAgICAgICAgIH0sIHtcInJlcGxhY2VcIjogdHJ1ZSwgXCJtYXRyaXhcIjogXCIzMDc1Qzo6MzA3NUM1NTlnMTAwZVwiLCBcInR5cGVcIjogMywgXCJkZXB0aFwiOiAxNX0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjEzNlM6OjEzNlM5NzhpNDMyY1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1wicmVwbGFjZVwiOiB0cnVlLCBcIm1hdHJpeFwiOiBcIjMwNzVDOjozMDc1QzI4OWgxNDNmXCIsIFwidHlwZVwiOiAzLCBcImRlcHRoXCI6IDN9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIzMDc1Qzo6MzA3NUMxNjNnMTAwZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMTVcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcInJlcGxhY2VcIjogdHJ1ZSwgXCJtYXRyaXhcIjogXCIxMzZTOjoxMzZTNjgyaTQzMmNcIiwgXCJ0eXBlXCI6IDMsIFwiZGVwdGhcIjogMX0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjMwNzVDOjozMDc1QzY0M2gxNDNmXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAzXG4gICAgICAgICAgICB9LCB7XCJyZXBsYWNlXCI6IHRydWUsIFwibWF0cml4XCI6IFwiMzA3NUM6OjMwNzVDODYzZjEwMGVcIiwgXCJ0eXBlXCI6IDMsIFwiZGVwdGhcIjogMTV9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIxMzZTOjoxMzZTNDUyaTQzMmNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDFcbiAgICAgICAgICAgIH0sIHtcInJlcGxhY2VcIjogdHJ1ZSwgXCJtYXRyaXhcIjogXCIzMDc1Qzo6MzA3NUM5MTloMTQzZlwiLCBcInR5cGVcIjogMywgXCJkZXB0aFwiOiAzfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMzA3NUM6OjMwNzVDNjI5ZjEwMGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDE1XG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XCJyZXBsYWNlXCI6IHRydWUsIFwibWF0cml4XCI6IFwiMTM2Uzo6MTM2UzI2OWk0MzJjXCIsIFwidHlwZVwiOiAzLCBcImRlcHRoXCI6IDF9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIzMDc1Qzo6MzA3NUMxMzhpMTQzZlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogM1xuICAgICAgICAgICAgfSwge1wicmVwbGFjZVwiOiB0cnVlLCBcIm1hdHJpeFwiOiBcIjMwNzVDOjozMDc1QzQ0NGYxMDBlXCIsIFwidHlwZVwiOiAzLCBcImRlcHRoXCI6IDE1fSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMTM2Uzo6MTM2UzEyNGk0MzJjXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJyZXBsYWNlXCI6IHRydWUsIFwibWF0cml4XCI6IFwiMzA3NUM6OjMwNzVDMzExaTE0M2ZcIiwgXCJ0eXBlXCI6IDMsIFwiZGVwdGhcIjogM30sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjMwNzVDOjozMDc1QzI5N2YxMDBlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxNVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1wicmVwbGFjZVwiOiB0cnVlLCBcIm1hdHJpeFwiOiBcIjEzNlM6OjEzNlMwMTBpNDMyY1wiLCBcInR5cGVcIjogMywgXCJkZXB0aFwiOiAxfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMzA3NUM6OjMwNzVDNDQ4aTE0M2ZcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDNcbiAgICAgICAgICAgIH0sIHtcInJlcGxhY2VcIjogdHJ1ZSwgXCJtYXRyaXhcIjogXCIzMDc1Qzo6MzA3NUMxODFmMTAwZVwiLCBcInR5cGVcIjogMywgXCJkZXB0aFwiOiAxNX0sIHtcInR5cGVcIjogMn0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjEzNlM6OjEzNlM5MjFoNDMyY1wiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMVxuICAgICAgICAgICAgfSwge1wicmVwbGFjZVwiOiB0cnVlLCBcIm1hdHJpeFwiOiBcIjMwNzVDOjozMDc1QzU1NWkxNDNmXCIsIFwidHlwZVwiOiAzLCBcImRlcHRoXCI6IDN9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIzMDc1Qzo6MzA3NUMwOTBmMTAwZVwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogMTVcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn0sIHtcInJlcGxhY2VcIjogdHJ1ZSwgXCJtYXRyaXhcIjogXCIxMzZTOjoxMzZTODUzaDQzMmNcIiwgXCJ0eXBlXCI6IDMsIFwiZGVwdGhcIjogMX0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjMwNzVDOjozMDc1QzYzNmkxNDNmXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAzXG4gICAgICAgICAgICB9LCB7XCJyZXBsYWNlXCI6IHRydWUsIFwibWF0cml4XCI6IFwiMzA3NUM6OjMwNzVDMDIyZjEwMGVcIiwgXCJ0eXBlXCI6IDMsIFwiZGVwdGhcIjogMTV9LCB7XCJ0eXBlXCI6IDJ9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIxMzZTOjoxMzZTODA0aDQzMmNcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDFcbiAgICAgICAgICAgIH0sIHtcInJlcGxhY2VcIjogdHJ1ZSwgXCJtYXRyaXhcIjogXCIzMDc1Qzo6MzA3NUM2OTVpMTQzZlwiLCBcInR5cGVcIjogMywgXCJkZXB0aFwiOiAzfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMzA3NUM6OjMwNzVDOTcyZTEwMGVcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDE1XG4gICAgICAgICAgICB9LCB7XCJ0eXBlXCI6IDJ9LCB7XCJyZXBsYWNlXCI6IHRydWUsIFwibWF0cml4XCI6IFwiMTM2Uzo6MTM2Uzc3MWg0MzJjXCIsIFwidHlwZVwiOiAzLCBcImRlcHRoXCI6IDF9LCB7XG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJtYXRyaXhcIjogXCIzMDc1Qzo6MzA3NUM3MzRpMTQzZlwiLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiAzLFxuICAgICAgICAgICAgICAgIFwiZGVwdGhcIjogM1xuICAgICAgICAgICAgfSwge1wicmVwbGFjZVwiOiB0cnVlLCBcIm1hdHJpeFwiOiBcIjMwNzVDOjozMDc1QzkzOGUxMDBlXCIsIFwidHlwZVwiOiAzLCBcImRlcHRoXCI6IDE1fSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMTM2Uzo6MTM2Uzc1Mmg0MzJjXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxXG4gICAgICAgICAgICB9LCB7XCJyZXBsYWNlXCI6IHRydWUsIFwibWF0cml4XCI6IFwiMzA3NUM6OjMwNzVDNzU3aTE0M2ZcIiwgXCJ0eXBlXCI6IDMsIFwiZGVwdGhcIjogM30sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjMwNzVDOjozMDc1QzkxOWUxMDBlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxNVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1wicmVwbGFjZVwiOiB0cnVlLCBcIm1hdHJpeFwiOiBcIjEzNlM6OjEzNlM3NDZoNDMyY1wiLCBcInR5cGVcIjogMywgXCJkZXB0aFwiOiAxfSwge1xuICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiOiB0cnVlLFxuICAgICAgICAgICAgICAgIFwibWF0cml4XCI6IFwiMzA3NUM6OjMwNzVDNzY0aTE0M2ZcIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMyxcbiAgICAgICAgICAgICAgICBcImRlcHRoXCI6IDNcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBcInJlcGxhY2VcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBcIm1hdHJpeFwiOiBcIjMwNzVDOjozMDc1QzkxMmUxMDBlXCIsXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IDMsXG4gICAgICAgICAgICAgICAgXCJkZXB0aFwiOiAxNVxuICAgICAgICAgICAgfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1widHlwZVwiOiAyfSwge1xuICAgICAgICAgICAgICAgIFwiaWRcIjogMSxcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogMTJcbiAgICAgICAgICAgIH0sIHtcInR5cGVcIjogMn1dLFxuICAgICAgICAgICAgXCJmaWxlU2l6ZVwiOiAxNjkxNSxcbiAgICAgICAgICAgIFwidlwiOiBcIjUuMC4wXCIsXG4gICAgICAgICAgICBcImZyYW1lU2l6ZVwiOiB7XCJ5bWluXCI6IDAsIFwieW1heFwiOiAxNDAwMCwgXCJ4bWluXCI6IDAsIFwieG1heFwiOiAyNDAwMH0sXG4gICAgICAgICAgICBcImZyYW1lQ291bnRcIjogMjYyLFxuICAgICAgICAgICAgXCJmcmFtZVJhdGVcIjogMzAsXG4gICAgICAgICAgICBcImNvZGVcIjogXCJcIixcbiAgICAgICAgICAgIFwidmVyc2lvblwiOiAxMVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBlbmRyZWdpb25cbn07IiwidmFyIFV0aWxzID0ge1xuICAgIGNvbnRhaW5zT2JqZWN0OiBmdW5jdGlvbihvYmosIGxpc3QpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxpc3RbaV0gPT09IG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgY29uc3RyYWluOiBmdW5jdGlvbihtaW4sIHZhbHVlLCBtYXgpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKHZhbHVlLCBtYXgpKTtcbiAgICB9LFxuXG4gICAgY2xvbmVPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZW1wID0gb2JqLmNvbnN0cnVjdG9yKCk7IC8vIGNoYW5nZWRcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGVtcFtrZXldID0gdGhpcy5jbG9uZU9iamVjdChvYmpba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbXA7XG4gICAgfSxcblxuICAgIGNvbnZlcnRNU3RvVGltZTogZnVuY3Rpb24obXMpIHtcbiAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIHZhciBtaW5zID0gTWF0aC5mbG9vcihtcyAvIDYwMDAwKTtcbiAgICAgICAgdmFyIHNlY3MgPSBNYXRoLmZsb29yKG1zIC8gMTAwMCkgJSA2MDtcbiAgICAgICAgdmFyIHNlY1N0cmluZyA9IChzZWNzID4gOSkgPyAoXCJcIiArIHNlY3MpIDogKFwiMFwiICsgc2Vjcyk7XG4gICAgICAgIHJldHVybiBtaW5zICsgXCI6XCIgKyBzZWNTdHJpbmc7XG4gICAgfSxcblxuICAgIGNvdW50TnVtRGlnaXRzOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICB2YXIgbnVtRGlnaXRzID0gMDtcbiAgICAgICAgd2hpbGUgKG4+PTEpIHtcbiAgICAgICAgICAgIG4gLz0gMTA7XG4gICAgICAgICAgICArK251bURpZ2l0cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtRGlnaXRzO1xuICAgIH0sXG5cbiAgICBkb2VzRmlsZUV4aXN0OiBmdW5jdGlvbih1cmxUb0ZpbGUpXG4gICAge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbignSEVBRCcsIHVybFRvRmlsZSwgZmFsc2UpO1xuICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PSBcIjQwNFwiKSB7Ly90aGlzIG5lZWRzIHRvIGJlIGEgPT1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVdGlsczsiXX0=
